<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="Python、Java、powershell、shell、Elasticsearch、MySQL、Redis、Django、Flask、爬虫、RPC、数据分析" />
   
  <meta name="description" content="多喝热水，热水治百病 &lt;- &lt;-" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    计算机网络知识点总结 |  小闫同学劝你多喝烫水
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>

  

  

<link rel="alternate" href="/atom.xml" title="小闫同学劝你多喝烫水" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-计算机网络知识点总结" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  计算机网络知识点总结
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/02/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2020-02-02T07:43:23.000Z" itemprop="datePublished">2020-02-02</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.7k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">17分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><strong>《计算机网络》第五版 谢希仁</strong> 知识点大汇总</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-OSI、TCP-IP、五层协议的体系结构以及各层协议"><a href="#1-OSI、TCP-IP、五层协议的体系结构以及各层协议" class="headerlink" title="1.OSI、TCP/IP、五层协议的体系结构以及各层协议"></a>1.OSI、TCP/IP、五层协议的体系结构以及各层协议</h2><p><img src="https://github.com/EthanYan6/pic/raw/master/1.png" alt="img"></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/2.png" alt="img"></p>
<p><strong>OSI分层（7层）</strong>：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p><strong>TCP/IP分层（4层）</strong>：网络接口层、网际层、运输层、应用层。</p>
<p><strong>五层协议（5层）</strong>：物理层、数据链路层、网络层、运输层、应用层。</p>
<p><strong><em>每一层的协议如下：</em></strong></p>
<p><strong>物理层：</strong><code>RJ45</code>、<code>CLOCK</code>、<code>IEEE802.3</code>   （中继器，集线器，网关）</p>
<p><strong>数据链路：</strong><code>PPP</code>、<code>FR</code>、<code>HDLC</code>、<code>VLAN</code>、<code>MAC</code>  （网桥，交换机）</p>
<p><strong>网络层：</strong><code>IP</code>、<code>ICMP</code>、<code>ARP</code>、<code>RARP</code>、<code>OSPF</code>、<code>IPX</code>、<code>RIP</code>、<code>IGRP</code> （路由器）</p>
<p><strong>传输层：</strong><code>TCP</code>、<code>UDP</code>、<code>SPX</code></p>
<p><strong>会话层：</strong><code>NFS</code>、<code>SQL</code>、<code>NETBIOS</code>、<code>RPC</code></p>
<p><strong>表示层：</strong><code>JPEG</code>、<code>MPEG</code>、<code>ASII</code></p>
<p><strong>应用层：</strong><code>FTP</code>、<code>DNS</code>、<code>Telnet</code>、<code>SMTP</code>、<code>HTTP</code>、<code>WWW</code>、<code>NFS</code></p>
<p><strong><em>每一层的作用如下：</em></strong></p>
<p><strong>物理层：</strong>通过媒介传输比特,确定机械及电气规范（比特 <code>Bit</code>）</p>
<p><strong>数据链路层</strong>：将比特组装成帧和点到点的传递（帧 <code>Frame</code>）</p>
<p><strong>网络层</strong>：负责数据包从源到宿的传递和网际互连（包 <code>PackeT</code>）</p>
<p><strong>传输层</strong>：提供端到端的可靠报文传递和错误恢复（段 <code>Segment</code>）</p>
<p><strong>会话层</strong>：建立、管理和终止会话（会话协议数据单元 <code>SPDU</code>）</p>
<p><strong>表示层</strong>：对数据进行翻译、加密和压缩（表示协议数据单元 <code>PPDU</code>）</p>
<p><strong>应用层</strong>：允许访问 <code>OSI</code> 环境的手段（应用协议数据单元 <code>APDU</code>）</p>
<h2 id="2-IP地址分类"><a href="#2-IP地址分类" class="headerlink" title="2.IP地址分类"></a>2.IP地址分类</h2><p>　　<code>IP</code> 地址是32位的二进制数值，用于在 <code>TCP/IP</code> 通讯协议中标记每台计算机的地址。通常我们使用点式十进制来表示，如192.168.0.5等等。</p>
<p>　　每个 <code>IP</code> 地址又可分为两部分。即网络号部分和主机号部分：网络号表示其所属的网络段编号，主机号则表示该网段中该主机的地址编号。按照网络规模的大小，<code>IP</code> 地址可以分为 <code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>、<code>E</code> 五类。</p>
<p>A类地址：以0开头，第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）；</p>
<p>B类地址：以10开头，第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；</p>
<p>C类地址：以110开头，第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">类别         网络号                  /占位数      主机号             /    占位数    用途</span><br><span class="line"></span><br><span class="line">A（以0开头）  1～126                 /  8      0～255 0～255 1～254 /     24      国家级</span><br><span class="line"></span><br><span class="line">B（以10开头） 128～191 0～255        /  16     0～255 1～254        /     16      跨过组织</span><br><span class="line"></span><br><span class="line">C（以110开头）192～223 0～255 0～255 /  24     1～254               /     8       企业组织</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>1）以下是留用的内部私有地址，<code>Internet</code> 上没使用的地址</p>
<p><code>A</code> 类 10.0.0.0–10.255.255.255</p>
<p><code>B</code> 类 172.16.0.0–172.31.255.255</p>
<p><code>C</code> 类 192.168.0.0–192.168.255.255</p>
<p>2）<code>IP</code> 地址与子网掩码相与得到网络号</p>
<p>3）主机号，全为0的是网络号（例如：192.168.2.0），主机号全为1的为广播地址（192.168.2.255）</p>
<h2 id="3-ARP是地址解析协议，简单语言解释一下工作原理"><a href="#3-ARP是地址解析协议，简单语言解释一下工作原理" class="headerlink" title="3.ARP是地址解析协议，简单语言解释一下工作原理"></a>3.ARP是地址解析协议，简单语言解释一下工作原理</h2><p>地址解析协议，即 <code>ARP</code>（<code>Address Resolution Protocol</code>），是根据 <code>IP</code> 地址获取物理地址的一个 <code>TCP/IP</code> 协议。</p>
<p>1.首先，每个主机都会在自己的 <code>ARP</code> 缓冲区中建立一个 <code>ARP</code> 列表，以表示 <code>IP</code> 地址和 <code>MAC</code> 地址之间的对应关系。</p>
<p>2.当源主机要发送数据时，首先检查ARP列表中是否有对应 <code>IP</code> 地址的目的主机的 <code>MAC</code> 地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送 <code>ARP</code> 数据包，该数据包包括的内容有：源主机<code>IP</code>地址，源主机 <code>MAC</code> 地址，目的主机的 <code>IP</code> 地址</p>
<p>3.当本网络的所有主机收到该 <code>ARP</code> 数据包时，首先检查数据包中的 <code>IP</code> 地址是否是自己的 <code>IP</code> 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 <code>IP</code> 和 <code>MAC</code> 地址写入到 <code>ARP</code> 列表中，如果已经存在，则覆盖，然后将自己的 <code>MAC</code> 地址写入 <code>ARP</code> 响应包中，告诉源主机自己是它想要找的 <code>MAC</code> 地址。</p>
<p>4.源主机收到 <code>ARP</code> 响应包后。将目的主机的 <code>IP</code> 和 <code>MAC</code> 地址写入 <code>ARP</code> 列表，并利用此信息发送数据。如果源主机一直没有收到 <code>ARP</code> 响应数据包，表示 <code>ARP</code> 查询失败。</p>
<p><strong>注意：广播（255.255.255.255）发送 <code>ARP</code> 请求，单播发送 <code>ARP</code> 响应。</strong></p>
<h2 id="4-简单介绍几种协议"><a href="#4-简单介绍几种协议" class="headerlink" title="4.简单介绍几种协议"></a>4.简单介绍几种协议</h2><p><code>ICMP</code> 协议： 因特网控制报文协议。它是 <code>TCP/IP</code> 协议族的一个子协议，用于在 <code>IP</code> 主机、路由器之间传递控制消息</p>
<p><code>TFTP</code> 协议： 是 <code>TCP/IP</code> 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</p>
<p><code>HTTP</code> 协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统</p>
<p><code>NAT</code> 协议：网络地址转换属接入广域网( <code>WAN</code> )技术，是一种将私有（保留）地址转化为合法 <code>IP</code> 地址的转换技术</p>
<p><code>DHCP</code> 协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段，使用 <code>UDP</code> 协议工作。<strong>具体用途</strong>：给内部网络或网络服务供应商自动分配 <code>IP</code> 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<h2 id="5-TCP三次握手四次挥手"><a href="#5-TCP三次握手四次挥手" class="headerlink" title="5.TCP三次握手四次挥手"></a>5.TCP三次握手四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次握手：客户端发送 <code>syn</code> 包( <code>seq=x</code> )到服务器，并进入 <code>SYN_SEND</code> (发送)状态，等待服务器确认；</p>
<p>第二次握手：服务器收到 <code>syn</code>包，必须确认客户的 <code>SYN</code>（<code>ack=x+1</code>），同时自己也发送一个 <code>SYN</code> 包（<code>seq=y</code> ），即 <code>SYN+ACK</code> 包，此时服务器进入 <code>SYN_RECV</code>（接收）状态；</p>
<p>第三次握手：客户端收到服务器的 <code>SYN＋ACK</code> 包，向服务器发送确认包 <code>ACK</code> ( <code>ack=y+1</code> )，此包发送完毕，客户端和服务器进入 <code>ESTABLISHED</code>（已建立）状态，完成三次握手。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/3.png" alt="img"></p>
<p><strong>说明：</strong><br>1）<code>SYN</code> 和 <code>ACK</code> 是标志位（0/1）（<code>ACK=1</code>表明 <code>ack</code> 有效），<code>seq</code> 是序列号，<code>ack</code> 是确认号。</p>
<p>2）给对方的确认方式就是把对方传来的 <code>seq+1</code> 并赋给 <code>ack</code>。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>第一次挥手：主动关闭方发送一个 <code>FIN</code>，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在 <code>fin</code> 包之前发送出去的数据，如果没有收到对应的 <code>ack</code> 确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p>
<p>第二次挥手：被动关闭方收到 <code>FIN</code> 包后，发送一个 <code>ACK</code> 给对方，确认序号为收到序号 +1。</p>
<p>第三次挥手：被动关闭方发送一个 <code>FIN</code>，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
<p>第四次挥手：主动关闭方收到 <code>FIN</code> 后，发送一个 <code>ACK</code> 给被动关闭方，确认序号为收到序号 +1，至此，完成四次挥手。</p>
<p><strong>说明：</strong></p>
<p>1）<strong>SYN攻击：用众多伪造ip地址向服务器发送SYN=1（请求连接）</strong>，让服务器处于<strong>SYN-RCVD状态</strong>，但都无法第三次握手（因为伪造 <code>ip</code> 不存在）</p>
<p>2）4次挥手中的 <code>FIN</code> 就相当于三次握手中的 <code>SYN</code>。</p>
<p>3）序号 <code>seq</code>，确认序号 <code>ack</code>，确认标志位 <code>ACK</code> 作用还是一样的，就是确认作用（把 <code>seq</code> 加上1赋给 <code>ack</code>，并把 <code>ACK</code> 置1）</p>
<p>4）为什么一个3次1个4次不一样？</p>
<p>因为两端的数据并不是同时发送完，所以两端谁发送完数据都需要自己告诉对方一次，并且对方确认一次。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/4.png" alt="img"></p>
<h2 id="6-在浏览器中输入www-baidu-com后执行的全部过程"><a href="#6-在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="6.在浏览器中输入www.baidu.com后执行的全部过程"></a>6.在浏览器中输入<a href="http://www.baidu.com后执行的全部过程" target="_blank" rel="noopener">www.baidu.com后执行的全部过程</a></h2><p>1、客户端浏览器通过 <code>DNS</code> 解析到<a href="http://www.baidu.com的" target="_blank" rel="noopener">www.baidu.com的</a> <code>IP</code> 地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个 <code>HTTP</code> 会话到 220.161.27.48，然后通过 <code>TCP</code> 进行封装数据包，输入到网络层。</p>
<p> 2、在客户端的<strong>传输层(添加TCP头)</strong>，把 <code>HTTP</code> 会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的 5000 端口。然后使用IP层的IP地址查找目的端。</p>
<p> 3、客户端的<strong>网络层（添加IP头）</strong>不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
<p> 4、客户端的<strong>链路层（添加MAC头）</strong>包通过链路层发送到路由器，通过邻居协议查找给定 <code>IP</code> 地址的 <code>MAC</code> 地址，然后发送 <code>ARP</code> 请求查找目的地址，如果得到回应后就可以使用 <code>ARP</code> 的请求应答交换的 <code>IP</code> 数据包现在就可以传输了，然后发送 <code>IP</code> 数据包到达服务器的地址。</p>
<h2 id="7-TCP和UDP的区别"><a href="#7-TCP和UDP的区别" class="headerlink" title="7.TCP和UDP的区别"></a>7.TCP和UDP的区别</h2><p><strong>这是传输层的两个协议，先说一下传输层的两大功能：</strong></p>
<ol>
<li><strong>复用：</strong>在发送端，多个应用进程公用一个传输层；</li>
<li><strong>分用：</strong>在接收端，传输层会根据端口号将数据分给不同的应用进程。 </li>
</ol>
<p><strong>传输层和网络层的区别：</strong></p>
<ol>
<li>网络层为不同的<strong>主机</strong>提供通信服务，传输层为不同应用<strong>进程</strong>提供通信服务。</li>
<li>网络层只对报文头部进行差错检测，而传输层对整个报文进行差错检测。</li>
</ol>
<p><strong>UDP（User Data Protocol）用户数据报协议</strong></p>
<ol>
<li>无连接</li>
<li>不可靠（不能保证都送达）</li>
<li>面向报文（<code>UDP</code> 数据传输单位是报文，不会对数据进行拆分和拼接操作，只是给上层传来的数据加个 <code>UDP</code> 头或者给下层来的数据去掉 <code>UDP</code> 头）</li>
<li>没有拥塞控制，始终以恒定速率发送数据</li>
<li>支持一对一、一对多、多对多、多对一</li>
<li>首部开销小，只有8字节</li>
</ol>
<p><strong>TCP（Transmission Control Protocol）传输控制协议</strong></p>
<ol>
<li>有连接</li>
<li>可靠的</li>
<li>面向字节流</li>
<li>全双工通信，<code>TCP</code> 两端既可以作为发送端也可以作为接收端</li>
<li>连接的两端只能是两个端点，即一对一，不能一对多</li>
<li>至少20个字节，比 <code>UDP</code> 大的多</li>
</ol>
<p><strong>什么是TCP连接</strong></p>
<p><code>TCP</code> 连接是一种抽象的概念，表示一条可以通信的链路。<br>每个 <code>TCP</code> 连接有且仅有两个端点，表示通信的双方，且双方在任意时刻都可以作为发送者和接受者。</p>
<p><strong>什么是套接字</strong></p>
<p>一条 <code>TCP</code> 连接的两端就是两个套接字。<br>套接字 = <code>IP</code> 地址:端口号<br>因此，<code>TCP</code> 连接 = （套接字1，套接字2）= （<code>IP1</code>：端口号1，<code>IP2</code>：端口号2）</p>
<h2 id="8-TCP对应的协议和UDP对应的协议"><a href="#8-TCP对应的协议和UDP对应的协议" class="headerlink" title="8.TCP对应的协议和UDP对应的协议"></a>8.TCP对应的协议和UDP对应的协议</h2><p><strong>TCP对应的协议：</strong></p>
<p>（1） <strong>FTP</strong>：定义了文件传输协议，使用<strong>21</strong>端口。</p>
<p>（2） <strong>Telnet</strong>：一种用于远程登陆的端口，使用<strong>23</strong>端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。</p>
<p>（3） <strong>SMTP</strong>：邮件传送协议，用于发送邮件。服务器开放的是<strong>25</strong>号端口。</p>
<p>（4） <strong>POP3</strong>：它是和 <code>SMTP</code> 对应，<code>POP3</code> 用于接收邮件。<code>POP3</code> 协议所用的是<strong>110</strong>端口。</p>
<p>（5）<strong>HTTP</strong>：是从 <code>Web</code> 服务器传输超文本到本地浏览器的传送协议。</p>
<p><strong>UDP对应的协议：</strong></p>
<p>（1） <strong>DNS</strong>：用于域名解析服务，将域名地址转换为IP地址。DNS用的是<strong>53</strong>号端口。</p>
<p>（2） <strong>SNMP</strong>：简单网络管理协议，使用<strong>161</strong>号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>
<p>（3） <strong>TFTP</strong>(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口<strong>69</strong>上使用UDP服务。</p>
<h2 id="9-DNS域名系统，简单描述其工作原理。"><a href="#9-DNS域名系统，简单描述其工作原理。" class="headerlink" title="9.DNS域名系统，简单描述其工作原理。"></a>9.DNS域名系统，简单描述其工作原理。</h2><p>　　当 <code>DNS</code> 客户机需要在程序中使用名称时，它会查询 <code>DNS</code> 服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的 <code>DNS</code> 域名，指定的查询类型，<code>DNS</code> 域名的指定类别。基于 <code>UDP</code> 服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如 <code>HTTP</code>，<code>SMTP</code>等在其中需要完成主机名到IP地址的转换。</p>
<h2 id="10-面向连接和非面向连接的服务的特点是什么？"><a href="#10-面向连接和非面向连接的服务的特点是什么？" class="headerlink" title="10.面向连接和非面向连接的服务的特点是什么？"></a>10.面向连接和非面向连接的服务的特点是什么？</h2><ul>
<li><p>面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。</p>
</li>
<li><p>非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。</p>
</li>
</ul>
<h2 id="11-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"><a href="#11-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？" class="headerlink" title="11.TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"></a>11.TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</h2><p>答：建立连接的过程是利用客户服务器模式，假设主机 <code>A</code> 为客户端，主机 <code>B</code> 为服务器端。</p>
<p>（1）<code>TCP</code> 的三次握手过程：主机 <code>A</code> 向 <code>B</code> 发送连接请求；主机 <code>B</code> 对收到的主机 <code>A</code> 的报文段进行确认；主机 <code>A</code> 再次对主机 <code>B</code> 的确认进行确认。</p>
<p>（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机 <code>B</code>，因而产生错误。失效的连接请求报文段是指：<strong>主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。</strong>考虑这样一种特殊情况，主机 <code>A</code> 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 <code>B</code>，<strong>主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会</strong>，主机 <code>B</code> 就一直在等待主机 <code>A</code> 发送数据，导致主机 <code>B</code> 的资源浪费。（这就是缺少第三次握手( <code>A</code> 再给 <code>B</code> 确认））</p>
<p>（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。</p>
<h2 id="12-了解交换机、路由器、网关的概念，并知道各自的用途"><a href="#12-了解交换机、路由器、网关的概念，并知道各自的用途" class="headerlink" title="12.了解交换机、路由器、网关的概念，并知道各自的用途"></a>12.了解交换机、路由器、网关的概念，并知道各自的用途</h2><p><strong>1）交换机</strong></p>
<p>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，当控制电路收到数据包以后，<strong>处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上</strong>，通过内部 交换矩阵迅速将数据包传送到目的端口。目的 <code>MAC</code> 若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。</p>
<p><strong>交换机工作于OSI参考模型的第二层，即数据链路层</strong>。交换机内部的 <code>CPU</code> 会在每个端口成功连接时，通过 <code>ARP</code> 协议学习它的 <code>MAC</code> 地址，保存成一张 <code>ARP</code>表。在今后的通讯中，发往该 <code>MAC</code> 地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。</p>
<p>交换机被广泛应用于二层网络交换，俗称“二层交换机”。</p>
<p>交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在 <code>OSI</code> 七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。</p>
<p><strong>2）路由器</strong></p>
<p><strong>路由器</strong>（<strong>Router</strong>）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（ <code>host</code> 到 <code>host</code> 之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转送。路由工作在<strong>OSI模型的第三层——即网络层</strong>，例如网际协议。</p>
<p><strong>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。</strong> 路由器与交换器的差别，路由器是属于 <code>OSI</code> 第三层的产品，交换器是 <code>OSI</code> 第二层的产品(这里特指二层交换机)。</p>
<p><strong>3）网关</strong></p>
<p><strong>网关</strong>（<code>Gateway</code>），<strong>网关</strong>顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关<code>TCP/IP</code> 的文献曾经把网络层使用的路由器（<code>Router</code>）称为网关，<strong>在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP</strong>），经常在家庭中或者小型企业网络中使用，用于连接局域网和 <code>Internet</code>。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。</p>
<blockquote>
<p>文章来源于网络</p>
<p>原文链接：<a href="https://www.cnblogs.com/xdyixia/p/9275246.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdyixia/p/9275246.html</a></p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>

      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://www.pythonnote.cn/2020/02/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/02/07/elasticsearch%E4%B8%ADjoin%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%88%B6%E5%AD%90%E6%96%87%E6%A1%A3%E6%9F%A5%E8%AF%A2/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            elasticsearch中join类型数据如何进行父子文档查询
          
        </div>
      </a>
    
    
      <a href="/2020/01/31/elasticsearch%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">elasticsearch的一些小知识点</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: '',
        app_id: 'KyuIqv0TGYfFpt5wguqvikhD-gzGzoHsz',
        app_key: 'f6Vbsc3Y9hlCH2zJDPMpL6gj',
        path: window.location.pathname,
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s4.cnzz.com/z_stat.php?id=1278605887&amp;web_id=1278605887'></script>
        
      </li>
    </ul>
    
    <ul class="list-inline">
      <li>
        友情链接：<a href="https://www.javastudy.cloud" target="_blank" rel="noopener">&gt; javaDemo站 &lt;</a><br>
      </li>
    </ul>

    <ul class="list-inline">
      <li>
        更多精彩文章请关注微信公众号『全栈技术精选』，id 为『Pythonnote』
      </li>
    </ul>
        
    <ul class="list-inline">
      <li>
        &copy;
        2019-2020
        小闫同学
      </li>
      <li>
        
          Created by
        
        
        <a href="https://github.com/EthanYan6" target="_blank">EthanYan</a> Thanks <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>

  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="小闫同学劝你多喝烫水"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://www.pythonnote.cn/OfficialDocuments/">文档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://www.pythonnote.cn/resume/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>
<script src="/js/share.js"></script>

<script src="/fancybox/jquery.fancybox.min.js"></script>



<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['小闫不才','世间纵有弱水三千，偏我眼中只有姑娘一人，勿怪','请关注微信公众号「Pythonnote」'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>



<script src="/js/tocbot.min.js"></script>
<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: false
  }
</script>

<script src="/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>