<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>机器学习算法之线性回归的损失和优化</title>
    <url>/2020/02/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%92%8C%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>学习了线性回归，接下来就需要考虑其损失以及优化了。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p><strong>我们仍然选择房子的例子，假设真实的数据之间存在这样的关系：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">真实关系：真实房子价格 = <span class="number">0.02</span>×中心区域的距离 + <span class="number">0.04</span>×城市一氧化氮浓度 + (<span class="number">-0.12</span>×自住房平均房价) + <span class="number">0.254</span>×城镇犯罪率</span><br></pre></td></tr></table></figure>

<p>那么现在，我们随意指定一个关系（猜测）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">随机指定关系：预测房子价格 = <span class="number">0.25</span>×中心区域的距离 + <span class="number">0.14</span>×城市一氧化氮浓度 + <span class="number">0.42</span>×自住房平均房价 + <span class="number">0.34</span>×城镇犯罪率</span><br></pre></td></tr></table></figure>

<p>思考一下，这样的话，会发生什么？真实结果与我们预测的结果之间是不是存在一定的误差呢？类似下图所示：</p>
<img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221093806586.png" alt="房屋示例" style="zoom:50%;">

<p>既然存在这个误差，那我们就需要将这个误差给衡量出来。</p>
<h3 id="1-损失函数"><a href="#1-损失函数" class="headerlink" title="1.损失函数"></a>1.损失函数</h3><p>总损失定义为：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.png" alt="线性回归损失函数"></p>
<ul>
<li><code>yi</code> 为第 <code>i</code> 个训练样本的真实值</li>
<li><code>h(xi)</code> 为第 <code>i</code> 个训练样本特征值组合预测函数</li>
<li>又称最小二乘法</li>
</ul>
<p>如何去减少这个损失，使预测更加准确呢？我们一直说机器学习有自动学习的功能，在线性回归中更能体现。此处可以通过一些优化方法去优化（其实运用了是数学当中的求导功能）回归的总损失！！！</p>
<h3 id="2-优化算法"><a href="#2-优化算法" class="headerlink" title="2.优化算法"></a>2.优化算法</h3><p><strong>如何去求模型当中的 <code>W</code>，使得损失最小？（目的是找到最小损失对应的 <code>W</code> 值）</strong></p>
<p>下面即线性回归经常使用的两种优化算法：</p>
<h4 id="2-1-正规方程"><a href="#2-1-正规方程" class="headerlink" title="2.1 正规方程"></a>2.1 正规方程</h4><h5 id="2-1-1-什么是正规方程"><a href="#2-1-1-什么是正规方程" class="headerlink" title="2.1.1 什么是正规方程"></a>2.1.1 什么是正规方程</h5><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B.png" alt="正规方程"></p>
<blockquote>
<p><strong>理解：</strong><code>X</code> 为特征值矩阵，<code>y</code> 为目标值矩阵。根据公式直接求出最好的结果。</p>
<p><strong>缺点：</strong>当特征过多且十分复杂时，求解速度太慢并且很难得到甚至得不到正确结果</p>
</blockquote>
<img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221094805620.png" alt="求解示意图" style="zoom:50%;">

<h5 id="2-1-2-正规方程求解举例"><a href="#2-1-2-正规方程求解举例" class="headerlink" title="2.1.2 正规方程求解举例"></a>2.1.2 正规方程求解举例</h5><p>以下图片展示数据为例：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221100240178.png" alt="示例1"></p>
<p>即：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221100305355.png" alt="示例2"></p>
<p>运用<strong>正规方程</strong>方法求解参数：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221100324767.png" alt="求解"></p>
<h5 id="2-1-3-正规方程的推导"><a href="#2-1-3-正规方程的推导" class="headerlink" title="2.1.3 正规方程的推导"></a>2.1.3 正规方程的推导</h5><p>把该损失函数转换成矩阵写法：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190319162703732.png" alt="矩阵写法"></p>
<p>其中 <code>y</code> 是真实值矩阵，<code>X</code> 是特征值矩阵，<code>w</code> 是权重矩阵。</p>
<p>对其求解关于 <code>w</code> 的最小值，起止 <code>y</code> , <code>X</code>  均已知二次函数，直接求导，导数为零的位置，即为最小值。</p>
<p>求导：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190320211408492.png" alt="求导"></p>
<p><strong>注：</strong>式(1) 到 式(2) 推导过程中, <code>X</code> 是一个 <code>m</code> 行 <code>n</code> 列的矩阵，并不能保证其有逆矩阵，但是右乘 <code>XT</code> 可把其变成一个方阵，保证其有逆矩阵。</p>
<p>式(5)  到 式(6) 推导过程中，和上面类似。</p>
<h4 id="2-2-梯度下降-Gradient-Descent"><a href="#2-2-梯度下降-Gradient-Descent" class="headerlink" title="2.2 梯度下降(Gradient Descent)"></a>2.2 梯度下降(Gradient Descent)</h4><h5 id="2-2-1-什么是梯度下降"><a href="#2-2-1-什么是梯度下降" class="headerlink" title="2.2.1 什么是梯度下降"></a>2.2.1 什么是梯度下降</h5><p>梯度下降法的基本思想可以类比为一个下山的过程。</p>
<p>假设这样一个场景：一个人被困在山上，需要从山上下来(i.e. 找到山的最低点，也就是山谷)。但此时山上浓雾密布，可视度很低，下山的路径根本无法确定。他必须利用自己周围的信息去找到下山路径（根据身边信息不断摸索前进）。此时，就可以利用<strong>梯度下降算法</strong>来下山了。换成直白的话语，以他当前的所处的位置为基准，<strong>寻找这个位置最陡峭的地方，然后朝着 山高度下降的地方 走</strong>，（同理，如果我们的目标是上山，也就是爬到山顶，那么此时应该是朝着最陡峭的方向往上走）。然后每走一段距离，都反复采用同一种方法，最后就能成功的抵达山谷。</p>
<blockquote>
<p>英文中 <code>e.g.</code> 的全称是 exempli gratia；<code>i.e.</code> 的全称是 id est 。</p>
<p>英文中 <code>e.g.</code> 的意思是 <code>例如</code>、<code>比如</code>；<code>i.e.</code> 的意思是 <code>那就是说</code>、<code>换句话说</code>。</p>
</blockquote>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221112607972.png" alt="下山"></p>
<p>梯度下降的基本过程同下山的场景类似。首先，有一个<strong>可微分的函数</strong>。此函数就代表着一座山。我们的目标就是找到<strong>这个函数的最小值</strong>，也就是山底。</p>
<p>根据之前的场景假设，最快的下山的方式就是找到当前位置最陡峭的方向，然后沿着此方向向下走，对应到函数中，就是<strong>找到给定点的梯度</strong> ，然后朝着梯度相反的方向，就能让函数值下降的最快！因为梯度的方向就是函数变化最快的方向。 重复利用此方法，反复求取梯度，最后就能到达局部的最小值，这就类似于下山的过程。而求取梯度就确定了最陡峭的方向，也就是场景中测量方向的手段。</p>
<blockquote>
<p>百度百科：梯度的本意是一个向量（矢量），表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（此梯度的方向）变化最快，变化率最大（为该梯度的模）。梯度向量的方向即为函数值增长最快的方向。</p>
</blockquote>
<p>如果梯度的概念你还不是很清楚，请看下方解释</p>
<h5 id="2-2-2-梯度的概念"><a href="#2-2-2-梯度的概念" class="headerlink" title="2.2.2 梯度的概念"></a>2.2.2 梯度的概念</h5><p>梯度是微积分中一个很重要的概念。在单变量的函数中，梯度其实就是函数的微分，代表着函数在某个给定点的切线的斜率。在多变量函数中，梯度是一个向量，向量有方向，梯度的方向就指出了函数在给定点的上升最快的方向。</p>
<p>这也就说明了为什么我们需要千方百计的求取梯度！我们需要到达山底，就需要在每一步观测到此时最陡峭的地方，梯度就恰巧告诉了我们这个方向。梯度的方向是函数在给定点上升最快的方向，那么梯度的反方向就是函数在给定点下降最快的方向，这正是我们所需要的。所以我们只要沿着梯度的反方向一直走，就能走到局部的最低点！</p>
<h5 id="2-2-3-梯度下降举例"><a href="#2-2-3-梯度下降举例" class="headerlink" title="2.2.3 梯度下降举例"></a>2.2.3 梯度下降举例</h5><ul>
<li><strong>1. 单变量函数的梯度下降</strong></li>
</ul>
<p>假设有一个单变量的函数：J(θ) = θ的平方</p>
<p>函数的微分：J(θ)的微分 = 2θ</p>
<p>初始化，起点为： θ0 = 1</p>
<p>学习率：α = 0.4</p>
<p>我们开始进行梯度下降的迭代计算过程:</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221102707528.png" alt="image-20190221102707528"></p>
<p>如下示意图，经过四次的运算，也就是走了四步，基本就抵达了函数的最低点，也就是山底</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221102725918.png" alt="迭代计算示意图"></p>
<ul>
<li><strong>2.多变量函数的梯度下降</strong></li>
</ul>
<p>我们假设有一个目标函数 ：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E5%A4%9A%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="目标函数"></p>
<p>现在要利用梯度下降法计算这个函数的最小值。通过观察就能发现最小值其实就是  (0，0) 点。但是不能直接看，需要论证。接下来，我们会从梯度下降算法开始，一步步计算到这个最小值! </p>
<p>我们假设初始的起点为：θ0 = (1, 3)</p>
<p>初始的学习率为：α = 0.1</p>
<p>函数的梯度为：▽J(θ) =&lt; 2θ1 ,2θ2&gt;</p>
<p>进行多次迭代:</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221103158740.png" alt="image-20190221103158740"></p>
<p>我们发现，已经基本靠近函数的最小值点</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221103220033.png" alt="image-20190221103220033"></p>
<h5 id="2-2-4-梯度下降（Gradient-Descent）公式"><a href="#2-2-4-梯度下降（Gradient-Descent）公式" class="headerlink" title="2.2.4 梯度下降（Gradient Descent）公式"></a>2.2.4 梯度下降<strong>（</strong>Gradient Descent）公式</h5><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E5%85%AC%E5%BC%8F.png" alt="梯度下降公式"></p>
<ul>
<li><p><strong>1) <code>α</code> 是什么含义？</strong></p>
<p><code>α</code> 在梯度下降算法中被称作 <strong>学习率</strong> 或者 <strong>步长</strong>，意味着我们可以通过 <code>α</code> 来控制每一步走的距离，以保证不要步子跨的太大扯着蛋，哈哈。其实就是不要走太快，错过了最低点。同时也要保证不要走的太慢，导致太阳下山了，还没有走到山下。所以 <code>α</code> 的选择在梯度下降法中往往是很重要的！<code>α</code> 不能太大也不能太小，太小的话，可能导致迟迟走不到最低点，太大的话，会导致错过最低点！</p>
</li>
</ul>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221113408141.png" alt="image-20190221113408141"></p>
<ul>
<li><strong>2) 为什么梯度要乘以一个负号</strong>？</li>
</ul>
<p>梯度前加一个负号，就意味着朝着梯度相反的方向前进。在前文提到，梯度的方向实际就是函数在此点上升最快的方向。而我们需要朝着下降最快的方向走，自然就是负的梯度的方向，所以此处需要加上负号。</p>
<p>通过两个图更好理解梯度下降的过程：</p>
<p><strong>单变量的梯度下降：</strong></p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E5%8D%95%E5%8F%98%E9%87%8F%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D.png" alt="单变量的梯度下降"></p>
<p><strong>多变量的梯度下降：</strong></p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E5%A4%9A%E5%8F%98%E9%87%8F%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D.png" alt="多变量的梯度下降"></p>
<p><strong>正因为有了梯度下降这样一个优化算法，回归才具有「自动学习」的能力</strong></p>
<ul>
<li><h5 id="优化动态图演示"><a href="#优化动态图演示" class="headerlink" title="优化动态图演示"></a><strong>优化动态图演示</strong></h5></li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/19/3EMkS1.gif" alt="线性回归优化动态图"></p>
<ul>
<li>梯度下降和正规方程的对比</li>
</ul>
<table>
<thead>
<tr>
<th>梯度下降</th>
<th>正规方程</th>
</tr>
</thead>
<tbody><tr>
<td>需要选择学习率</td>
<td>不需要</td>
</tr>
<tr>
<td>需要迭代求解</td>
<td>一次运算得出</td>
</tr>
<tr>
<td>特征数量较大可以使用</td>
<td>需要计算方程，时间复杂度高O(n的立方)</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>选择上</strong></p>
<p>小规模数据：</p>
<ul>
<li><strong><code>LinearRegression</code>(不能解决拟合问题)</strong></li>
<li>岭回归</li>
</ul>
<p>大规模数据：<code>SGDRegressor</code></p>
</li>
</ul>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul>
<li>线性回归的损失函数 - 均方误差</li>
<li>线性回归的优化方法<ul>
<li>正规方程</li>
<li>梯度下降</li>
</ul>
</li>
</ul>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法之线性回归</title>
    <url>/2020/02/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>机器学习中最常见的一类问题：线性回归问题。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1.应用场景"></a>1.应用场景</h2><ul>
<li>房价预测</li>
</ul>
<p>通过以往房屋面积与房屋价格对应情况，推断出现有房屋的价格。</p>
<ul>
<li>销售额度预测</li>
</ul>
<p>销售额度受影响因素很多，比如广告，市场环境等等。我们可以分析出其中的关系，从而预测销售额度。</p>
<ul>
<li>贷款额度预测</li>
</ul>
<p>银行对于每个人的贷款额度参考，预测出某人的贷款额度。</p>
<p>……</p>
<h2 id="2-线性回归"><a href="#2-线性回归" class="headerlink" title="2.线性回归"></a>2.线性回归</h2><p>在说线性回归之前，需要先搞清楚『分类』和『回归』这两个概念，这也是机器学习中很重要的概念。简单来讲，『分类』和『回归』都是预测目标值的过程，但是『分类』预测的是离散型变量，而『回归』预测的是连续型变量。下面开始介绍线性回归：</p>
<p>线性回归(<code>Linear regression</code>)是利用<strong>回归方程(函数)</strong>对<strong>一个或多个自变量(特征值)和因变量(目标值)之间</strong>关系进行建模的一种分析方式。下面即对应公式：</p>
<blockquote>
<p>只有一个自变量的情况称为单变量回归，多于一个自变量情况的叫做多元回归</p>
</blockquote>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%85%AC%E5%BC%8F.png" alt="线性回归公式"></p>
<p>那么怎么理解呢？我们来看几个例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">期末成绩 = 0.7 × 考试成绩 + 0.3 × 平时成绩</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">房子价格 = 0.02 × 中心区域的距离 + 0.04 × 城市一氧化氮浓度 + (-0.12 × 自住房平均房价) + 0.254 × 城镇犯罪率</span><br></pre></td></tr></table></figure>

<p>上面两个例子，<strong>我们看到特征值与目标值之间建立了一个关系，这个关系可以理解为线性模型</strong>。</p>
<p>如果还是难以理解的话，那么再通俗易懂的解释一下：</p>
<p>假设有很多小点点在屏幕上，他们看似杂乱，但貌似又有些关系。线性回归就是找出一条直线，尽可能的让给定的特征值点（屏幕上的小点点）都落到线上或均匀分布于两侧并靠近于这条线。</p>
<blockquote>
<p>当然这些点分布的不能过于散乱，他们的整体趋势必须是线性的，否则拟合结果就是非线性。</p>
</blockquote>
<p>这样看来，像不像给定几个点，然后求直线方程呢？（无限趋于完美情况，所有点都在直线上）这个直线方程就是<strong>「线性回归方程」</strong>，要求的参数就是「回归参数」</p>
<h2 id="3-特征值与目标值关系分析"><a href="#3-特征值与目标值关系分析" class="headerlink" title="3.特征值与目标值关系分析"></a>3.特征值与目标值关系分析</h2><p>线性回归当中线性模型有两种：<strong>一种是线性关系，另一种是非线性关系。</strong>在这里我们只能画一个平面更好去理解，所以都用单个特征或两个特征举例子。</p>
<h3 id="3-1-线性关系"><a href="#3-1-线性关系" class="headerlink" title="3.1 线性关系"></a>3.1 线性关系</h3><h4 id="3-1-1-单变量线性关系"><a href="#3-1-1-单变量线性关系" class="headerlink" title="3.1.1 单变量线性关系"></a>3.1.1 单变量线性关系</h4><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E7%BA%BF%E6%80%A7%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="单变量线性关系"></p>
<h4 id="3-1-2-多变量线性关系"><a href="#3-1-2-多变量线性关系" class="headerlink" title="3.1.2 多变量线性关系"></a>3.1.2 多变量线性关系</h4><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E5%A4%9A%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%85%B3%E7%B3%BB.png" alt="多变量线性关系"></p>
<p><strong>注释：</strong>单特征与目标值的关系呈直线关系，或者两个特征与目标值呈现平面的关系。</p>
<p>更高维度的我们不用自己去想，记住这种关系即可</p>
<h3 id="3-2-非线性关系"><a href="#3-2-非线性关系" class="headerlink" title="3.2 非线性关系"></a>3.2 非线性关系</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%85%B3%E7%B3%BB.png" alt="非线性关系"></p>
<h2 id="4-线性回归api初步使用"><a href="#4-线性回归api初步使用" class="headerlink" title="4.线性回归api初步使用"></a>4.线性回归api初步使用</h2><h3 id="4-1-api"><a href="#4-1-api" class="headerlink" title="4.1 api"></a>4.1 api</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sklearn.linear_model.LinearRegression()</span><br><span class="line"><span class="meta">#</span><span class="bash"> LinearRegression.coef_：回归系数</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-举例"><a href="#4-2-举例" class="headerlink" title="4.2 举例"></a>4.2 举例</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190320204457160.png" alt="示例表格"></p>
<h4 id="4-2-1-步骤分析"><a href="#4-2-1-步骤分析" class="headerlink" title="4.2.1 步骤分析"></a>4.2.1 步骤分析</h4><ul>
<li>1.获取数据集</li>
<li>2.数据基本处理（该案例中省略）</li>
<li>3.特征工程（该案例中省略）</li>
<li>4.机器学习</li>
<li>5.模型评估（该案例中省略）</li>
</ul>
<h4 id="4-2-2-代码过程"><a href="#4-2-2-代码过程" class="headerlink" title="4.2.2 代码过程"></a>4.2.2 代码过程</h4><ul>
<li>导入模块</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br></pre></td></tr></table></figure>

<ul>
<li>构造数据集</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [[<span class="number">80</span>, <span class="number">86</span>],</span><br><span class="line">[<span class="number">82</span>, <span class="number">80</span>],</span><br><span class="line">[<span class="number">85</span>, <span class="number">78</span>],</span><br><span class="line">[<span class="number">90</span>, <span class="number">90</span>],</span><br><span class="line">[<span class="number">86</span>, <span class="number">82</span>],</span><br><span class="line">[<span class="number">82</span>, <span class="number">90</span>],</span><br><span class="line">[<span class="number">78</span>, <span class="number">80</span>],</span><br><span class="line">[<span class="number">92</span>, <span class="number">94</span>]]</span><br><span class="line">y = [<span class="number">84.2</span>, <span class="number">80.6</span>, <span class="number">80.1</span>, <span class="number">90</span>, <span class="number">83.2</span>, <span class="number">87.6</span>, <span class="number">79.4</span>, <span class="number">93.4</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>机器学习– 模型训练</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例化API</span></span><br><span class="line">estimator = LinearRegression()</span><br><span class="line"><span class="comment"># 使用fit方法进行训练</span></span><br><span class="line">estimator.fit(x,y)</span><br><span class="line"><span class="comment"># 回归系数</span></span><br><span class="line">estimator.coef_</span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">estimator.predict([[<span class="number">100</span>, <span class="number">80</span>]])</span><br></pre></td></tr></table></figure>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法之kd树</title>
    <url>/2020/02/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B9%8Bkd%E6%A0%91/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>上篇文章讲了 <code>K-近邻算法</code> ，但是引出了一个问题：</p>
<p>实现 <code>K-近邻算法</code> 时，<strong>主要考虑的问题是如何对训练数据进行快速 k 近邻搜索。</strong>这在特征空间维数大及训练数据容量大时尤其必要。<strong>k 近邻法最简单的实现是线性扫描（穷举搜索），即要计算输入实例与每一个训练实例的距离。计算并存储好以后，再查找 K 近邻。</strong>当训练集很大时，计算非常耗时。为了提高 <code>KNN</code> 搜索的效率，可以考虑使用特殊的结构存储训练数据，以减小计算距离的次数。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>为了解决上述问题，我们引入了 <code>kd</code> 树，下面来了解一下吧。</p>
<h2 id="1-初识-kd-树"><a href="#1-初识-kd-树" class="headerlink" title="1.初识 kd 树"></a>1.初识 kd 树</h2><p><strong><code>KNN</code></strong> 在每次预测一个点时，都需要计算训练数据集里每个点到这个点的距离，然后选出距离最近的 k 个点进行投票。<strong>当数据集很大时，这个计算成本非常高，针对 N 个样本，D 个特征的数据集，其算法复杂度为 <code>O(DN^2)</code></strong>。</p>
<p><strong>kd 树</strong>：为了避免每次都重新计算一遍距离，算法会把距离信息保存在一棵树里，这样就可以在每次计算之前从树里查询距离信息，尽量避免重新计算。其基本原理是，<strong>如果 A 和 B 距离很远，B 和 C 距离很近，那么 A 和 C 的距离也很远</strong>。有了这个信息，就可以在合适的时候跳过距离远的点。这样优化后的算法复杂度可降低到 <strong><code>O(DNlog(N))</code></strong>。</p>
<blockquote>
<p>感兴趣的读者可参阅论文：Bentley，J.L.，Communications of the ACM（1975）。</p>
</blockquote>
<p>1989年，另外一种称为 <strong><code>Ball Tree</code></strong> 的算法，在 <code>kd Tree</code> 的基础上对性能进一步进行了优化。</p>
<blockquote>
<p>感兴趣的读者可以搜索 <strong>Five balltree construction algorithms</strong> 来了解详细的算法信息。</p>
</blockquote>
<h2 id="2-树的构建"><a href="#2-树的构建" class="headerlink" title="2.树的构建"></a>2.树的构建</h2><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190213191654082.png" alt="kd树1"></p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190213191739222.png" alt="kd2"></p>
<p>上方左侧图片中：黄色的点作为根节点，上面的点归左子树，下面的点归右子树。接下来再不断地划分，如上方右图，分割的那条线叫做分割超平面（splitting hyperplane），在一维中是一个点，二维中是线，三维的是面。</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219101722826.png" alt="kd3"></p>
<p>黄色节点就是 <code>Root</code> 节点，下一层是红色，再下一层是绿色，再下一层是蓝色。</p>
<h3 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h3><p>（1）构造根结点，使根结点对应于 k 维空间中包含所有实例点的超矩形区域；</p>
<p>（2）通过递归的方法，不断地对 k 维空间进行切分，生成子结点。在超矩形区域上选择一个坐标轴和在此坐标轴上的一个切分点，确定一个超平面，这个超平面通过选定的切分点并垂直于选定的坐标轴，将当前超矩形区域切分为左右两个子区域（子结点）；这时，实例被分到两个子区域。</p>
<p>（3）上述过程直到子区域内没有实例时终止（终止时的结点为叶结点）。在此过程中，将实例保存在相应的结点上。</p>
<p>（4）通常，循环的选择坐标轴对空间切分，选择训练实例点在坐标轴上的中位数为切分点，这样得到的 <code>kd树</code> 是平衡的</p>
<blockquote>
<p>平衡二叉树：它是一棵空树，或其左子树和右子树的深度之差的绝对值不超过1，且它的左子树和右子树都是平衡二叉树。</p>
</blockquote>
<p> <code>kd树</code> 中每个节点是一个向量，和二叉树按照数的大小划分不同的是， <code>kd树</code> 每层需要选定向量中的某一维，然后根据这一维按左小右大的方式划分数据。在构建 <code>kd树</code> 时，关键需要解决2个问题：</p>
<p><strong>（1）选择向量的哪一维进行划分；</strong></p>
<p><strong>（2）如何划分数据；</strong></p>
<p>第一个问题简单的解决方法可以是随机选择某一维或按顺序选择，但是<strong>更好的方法应该是在数据比较分散的那一维进行划分（分散的程度可以根据方差来衡量）</strong>。好的划分方法可以使构建的树比较平衡，可以每次选择中位数来进行划分，这样问题2也得到了解决。</p>
<h2 id="3-最近邻域搜索（Nearest-Neighbor-Lookup）"><a href="#3-最近邻域搜索（Nearest-Neighbor-Lookup）" class="headerlink" title="3.最近邻域搜索（Nearest-Neighbor Lookup）"></a>3.最近邻域搜索（Nearest-Neighbor Lookup）</h2><p><code>kd 树</code>(K-dimension tree) 是<strong>一种对 k 维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。</strong><code>kd树</code> 是一种二叉树，表示对 k 维空间的一个划分，<strong>构造 <code>kd树</code> 相当于不断地用垂直于坐标轴的超平面将 K 维空间切分，构成一系列的 K 维超矩形区域</strong>。<code>kd树</code> 的每个结点对应于一个 k 维超矩形区域。<strong>利用 <code>kd树</code> 可以省去对大部分数据点的搜索，从而减少搜索的计算量。</strong> </p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190213223817957.png" alt="kd4"></p>
<p>接下来需要引入一个概念「<strong>最近邻域搜索</strong>」，类比「二分查找」：给出一组数据：[9 1 4 7 2 5 0 3 8]，要查找8。如果挨个查找（线性扫描），那么将会把数据集都遍历一遍。而如果排一下序那数据集就变成了：[0 1 2 3 4 5 6 7 8 9]，按前一种方式我们进行了很多没有必要的查找，现在如果我们以5为分界点，那么数据集就被划分为了左右两个 <code>簇</code> ： [0 1 2 3 4] 和 [6 7 8 9]。</p>
<p>因此，根本就没有必要进入第一个簇，可以直接进入第二个簇进行查找。把二分查找中的数据点换成 k 维数据点，这样的划分就变成了用超平面对 k 维空间的划分。空间划分就是对数据点进行分类，「挨得近」的数据点就在一个空间里面。</p>
<h2 id="4-示例"><a href="#4-示例" class="headerlink" title="4.示例"></a>4.示例</h2><h3 id="4-1-树的建立"><a href="#4-1-树的建立" class="headerlink" title="4.1 树的建立"></a>4.1 树的建立</h3><p>给定一个二维空间数据集：T={(2,3),(5,4),(9,6),(4,7),(8,1),(7,2)}，构造一个平衡 <code>kd树</code>。</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219102142984.png" alt="kd5"></p>
<p>（1）思路引导：</p>
<p>根结点对应包含数据集 T 的矩形，选择 x(1) 轴，6个数据点的 x(1) 坐标中位数是6，这里选最接近的 (7,2) 点，以平面 x(1)=7 将空间分为左、右两个子矩形（子结点）；接着左矩形以 x(2)=4 分为两个子矩形（左矩形中{(2,3),(5,4),(4,7)}点的 x(2) 坐标中位数正好为4），右矩形以 x(2)=6 分为两个子矩形，如此递归，最后得到如下图所示的特征空间划分和 <code>kd树</code>。</p>
<blockquote>
<p>「百度百科」中位数，又称中点数，中值。中位数是按顺序排列的一组数据中居于中间位置的数，即在这组数据中，有一半的数据比他大，有一半的数据比他小</p>
</blockquote>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219102409567.png" alt="kd6"></p>
<h3 id="4-2-最近领域的搜索"><a href="#4-2-最近领域的搜索" class="headerlink" title="4.2 最近领域的搜索"></a>4.2 最近领域的搜索</h3><p>假设标记为星星的点是 test point， 绿色的点是找到的近似点，在回溯过程中，需要用到一个队列，存储需要回溯的点，在判断其他子节点空间中是否有可能有距离查询点更近的数据点时，做法是以查询点为圆心，以当前的最近距离为半径画圆，这个圆称为候选超球（candidate hypersphere），如果圆与回溯点的轴相交，则需要将轴另一边的节点都放到回溯队列里面来。</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190213224152601.png" alt="kd7"></p>
<p>样本集{(2,3),(5,4), (9,6), (4,7), (8,1), (7,2)}</p>
<h4 id="4-2-1-查询点为-2-1-3-1"><a href="#4-2-1-查询点为-2-1-3-1" class="headerlink" title="4.2.1 查询点为(2.1,3.1)"></a>4.2.1 查询点为(2.1,3.1)</h4><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190213224414342.png" alt="kd8"></p>
<p>星号表示要查询的点（2.1,3.1）。通过二叉搜索，顺着搜索路径很快就能找到最邻近的近似点，也就是叶子节点（2,3）。而找到的叶子节点并不一定就是最邻近的，最邻近肯定距离查询点更近，应该位于以查询点为圆心且通过叶子节点的圆域内。为了找到真正的最近邻，还需要进行相关的「回溯」操作。也就是说，算法首先沿搜索路径反向查找是否有距离查询点更近的数据点。</p>
<p>首先进行二叉树搜索：在 (7,2) 点测试到达 (5,4) ，在 (5,4) 点测试到达 (2,3) ，然后 <code>search_path</code> 中的结点为 &lt;(7,2),(5,4), (2,3)&gt; ，从 <code>search_path</code> 中取出 (2,3) 作为当前最佳结点 <code>nearest</code>，<code>dist</code> 为0.141；</p>
<p>然后回溯至 (5,4)，以 (2.1,3.1) 为圆心，以 dist=0.141 为半径画一个圆，并不和超平面 y=4 相交，如上图，所以不必跳到结点 (5,4) 的右子空间去搜索，因为右子空间中不可能有更近样本点了。</p>
<p>于是再回溯至 (7,2) ，同理，以 (2.1,3.1) 为圆心，以 dist=0.141 为半径画一个圆并不和超平面 x=7 相交，所以也不用跳到结点 (7,2) 的右子空间去搜索。</p>
<p>至此，<code>search_path</code> 为空，结束整个搜索，返回 nearest(2,3) 作为(2.1,3.1) 的最近邻点，最近距离为 0.141。</p>
<h4 id="4-2-2-查询点为-2-4-5"><a href="#4-2-2-查询点为-2-4-5" class="headerlink" title="4.2.2 查询点为(2,4.5)"></a>4.2.2 查询点为(2,4.5)</h4><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219103050940.png" alt="kd9"></p>
<p>类比上个例子，首先进行二叉树搜索：在 (7,2) 处测试到达 (5,4)，在 (5,4) 处测试到达 (4,7)【优先选择在本域搜索】，然后 <code>search_path</code> 中的结点为 &lt;(7,2),(5,4), (4,7)&gt;，从<code>search_path</code> 中取出 (4,7 ) 作为当前最佳结点 <code>nearest</code>，<code>dist</code>为3.202；</p>
<p>然后回溯至 (5,4)，以 (2,4.5) 为圆心，以 dist=3.202 为半径画一个圆与超平面 y=4 相交，所以需要跳到 (5,4) 的左子空间去搜索。还要将 (2,3) 加入到 <code>search_path</code> 中，现在 <code>search_path</code> 中的结点为 &lt;(7,2),(2, 3)&gt;；另外，(5,4) 与 (2,4.5) 的距离为 3.04 &lt; dist = 3.202，所以将 (5,4) 赋给 <code>nearest</code>，并且 dist=3.04。</p>
<p>回溯至 (2,3) 。(2,3) 是叶子节点，直接判断 (2,3) 是否离 (2,4.5) 更近，计算得到距离为1.5，所以 <code>nearest</code> 更新为(2,3)，<code>dist</code> 更新为(1.5)</p>
<p>回溯至 (7,2)，同理，以 (2,4.5) 为圆心，以 dist=1.5 为半径画一个圆并不和超平面 x=7 相交, 所以不用跳到结点 (7,2) 的右子空间去搜索。</p>
<p>至此，<code>search_path</code> 为空，结束整个搜索，返回 nearest(2,3) 作为(2,4.5) 的最近邻点，最近距离为1.5。</p>
<h4 id="4-2-3-总结"><a href="#4-2-3-总结" class="headerlink" title="4.2.3 总结"></a>4.2.3 总结</h4><p>首先通过二叉树搜索（比较待查询节点和分裂节点的分裂维的值，小于等于就进入左子树分支，大于就进入右子树分支直到叶子结点），顺着「搜索路径」很快能找到最近邻的近似点，也就是与待查询点处于同一个子空间的叶子结点；然后再回溯搜索路径，并判断搜索路径上的结点的其他子结点空间中是否可能有距离查询点更近的数据点。如果有可能，则需要跳到其他子结点空间中去搜索（将其他子结点加入到搜索路径）。重复这个过程直到搜索路径为空。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法之K-近邻算法</title>
    <url>/2020/02/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B9%8BK-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p><code>K Nearest Neighbor</code> 算法又叫 <code>KNN</code> 算法，此算法最早是由 <code>Cover</code> 和 <code>Hart</code> 提出的一种分类算法，是机器学习里面一个经典之作， 总体来说 <code>KNN</code> 算法是相对比较容易理解的。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="1.算法简介"></a>1.算法简介</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>如果一个样本在特征空间中的 <strong>k 个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别</strong>，则该样本也属于这个类别。</p>
<p><strong>实现流程：</strong></p>
<p>1）计算已知类别数据集中的点与当前点之间的距离</p>
<p>2）按距离递增次序排序</p>
<p>3）选取与当前点距离最小的 <code>k</code> 个点</p>
<p>4）统计前 <code>k</code> 个点所在的类别出现的频率</p>
<p>5）返回前 <code>k</code> 个点出现频率最高的类别作为当前点的预测分类</p>
<h3 id="1-2-欧式距离"><a href="#1-2-欧式距离" class="headerlink" title="1.2 欧式距离"></a>1.2 欧式距离</h3><p>两个样本的距离可以通过如下公式计算，又叫<strong>欧式距离</strong> 。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/1.3%20%E6%AC%A7%E5%BC%8F%E8%B7%9D%E7%A6%BB1.png" alt="欧式距离1"></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/1.4%20%E6%AC%A7%E5%BC%8F%E8%B7%9D%E7%A6%BB2.png" alt="欧式距离2"></p>
<h3 id="1-3-示例"><a href="#1-3-示例" class="headerlink" title="1.3 示例"></a>1.3 示例</h3><p>假设我们现在有几部电影</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/image-20190316204421392.png" alt="示例1"></p>
<p>其中 <code>?</code> 号电影不知道类别，如何去预测？我们可以利用K近邻算法的思想</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/image-20190316204448303.png" alt="示例2"></p>
<p>分别计算每个电影和被预测电影的距离，然后求解</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/image-20190316204517137.png" alt="示例3"></p>
<h2 id="2-KNN-api-初步使用"><a href="#2-KNN-api-初步使用" class="headerlink" title="2.KNN api 初步使用"></a>2.KNN api 初步使用</h2><h3 id="2-1-Scikit-learn工具介绍"><a href="#2-1-Scikit-learn工具介绍" class="headerlink" title="2.1 Scikit-learn工具介绍"></a>2.1 Scikit-learn工具介绍</h3><ul>
<li><code>Python</code> 语言的机器学习工具</li>
<li><code>Scikit-learn</code> 包括许多知名的机器学习算法的实现</li>
<li><code>Scikit-learn</code> 文档完善，容易上手，丰富的 <code>API</code></li>
<li>目前稳定版本0.19.1</li>
</ul>
<h3 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install scikit-learn==0.19.1</span><br></pre></td></tr></table></figure>

<p>安装好之后可以通过以下命令查看是否安装成功</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>安装 <code>scikit-learn</code> 需要 <code>Numpy</code>,  <code>Scipy</code> 等库。</p>
<h3 id="2-3-包含内容"><a href="#2-3-包含内容" class="headerlink" title="2.3 包含内容"></a>2.3 包含内容</h3><ul>
<li>分类、聚类、回归</li>
<li>特征工程</li>
<li>模型选择、调优</li>
</ul>
<h3 id="2-4-KNN-算法-api"><a href="#2-4-KNN-算法-api" class="headerlink" title="2.4 KNN 算法 api"></a>2.4 KNN 算法 api</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sklearn.neighbors.KNeighborsClassifier(n_neighbors=5)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>n_neighbors</code>：<code>int</code>,可选（默认= 5），<code>k_neighbors</code> 查询默认使用的邻居数</p>
</blockquote>
<h3 id="2-5-示例"><a href="#2-5-示例" class="headerlink" title="2.5 示例"></a>2.5 示例</h3><h4 id="2-5-1-步骤分析"><a href="#2-5-1-步骤分析" class="headerlink" title="2.5.1 步骤分析"></a>2.5.1 步骤分析</h4><p>1.获取数据集</p>
<p>2.数据基本处理（该案例中省略）</p>
<p>3.特征工程（该案例中省略）</p>
<p>4.机器学习</p>
<p>5.模型评估（该案例中省略）</p>
<h4 id="2-5-2-实现"><a href="#2-5-2-实现" class="headerlink" title="2.5.2 实现"></a>2.5.2 实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="comment"># 构造数据集</span></span><br><span class="line">x = [[<span class="number">0</span>], [<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]]</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># 机器学习 -- 模型训练</span></span><br><span class="line"><span class="comment"># 实例化API</span></span><br><span class="line">estimator = KNeighborsClassifier(n_neighbors=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 使用fit方法进行训练</span></span><br><span class="line">estimator.fit(x, y)</span><br><span class="line">estimator.predict([[<span class="number">1</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="3-距离度量"><a href="#3-距离度量" class="headerlink" title="3.距离度量"></a>3.距离度量</h2><h3 id="3-1-欧式距离-Euclidean-Distance"><a href="#3-1-欧式距离-Euclidean-Distance" class="headerlink" title="3.1 欧式距离(Euclidean Distance)"></a>3.1 欧式距离(Euclidean Distance)</h3><p>欧氏距离是最容易直观理解的距离度量方法，我们小学、初中和高中接触到的两个点在空间中的距离一般都是指欧氏距离。</p>
<p>举例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>]];</span><br><span class="line">经计算得:</span><br><span class="line">d = <span class="number">1.4142</span>    <span class="number">2.8284</span>    <span class="number">4.2426</span>    <span class="number">1.4142</span>    <span class="number">2.8284</span>    <span class="number">1.4142</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-曼哈顿距离-Manhattan-Distance"><a href="#3-2-曼哈顿距离-Manhattan-Distance" class="headerlink" title="3.2 曼哈顿距离(Manhattan Distance)"></a>3.2 曼哈顿距离(Manhattan Distance)</h3><p>在曼哈顿街区要从一个十字路口开车到另一个十字路口，驾驶距离显然不是两点间的直线距离。这个实际驾驶距离就是「曼哈顿距离」。曼哈顿距离也称为「城市街区距离」(City Block distance)。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/1.5%20%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB.png" alt="曼哈顿距离1"></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/1.6%20%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB.png" alt="曼哈顿距离2"></p>
<p>举例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>]];</span><br><span class="line">经计算得:</span><br><span class="line">d =   <span class="number">2</span>     <span class="number">4</span>     <span class="number">6</span>     <span class="number">2</span>     <span class="number">4</span>     <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-切比雪夫距离-Chebyshev-Distance"><a href="#3-3-切比雪夫距离-Chebyshev-Distance" class="headerlink" title="3.3 切比雪夫距离 (Chebyshev Distance)"></a>3.3 切比雪夫距离 (Chebyshev Distance)</h3><p>国际象棋中，国王可以直行、横行、斜行，所以国王走一步可以移动到相邻8个方格中的任意一个。国王从格子(x1,y1)走到格子(x2,y2)最少需要多少步？这个距离就叫切比雪夫距离。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/1.7%20%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB.png" alt="切比雪夫距离1"></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/1.8%20%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB.png" alt="切比雪夫距离2"></p>
<p>举例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>]];</span><br><span class="line">经计算得:</span><br><span class="line">d =   <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-闵可夫斯基距离-Minkowski-Distance"><a href="#3-4-闵可夫斯基距离-Minkowski-Distance" class="headerlink" title="3.4 闵可夫斯基距离(Minkowski Distance)"></a>3.4 闵可夫斯基距离(Minkowski Distance)</h3><p>闵氏距离不是一种距离，而是一组距离的定义，是对多个距离度量公式的概括性的表述。</p>
<p>两个n维变量a(x11,x12,…,x1n)与b(x21,x22,…,x2n)间的闵可夫斯基距离定义为：</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/image-20190225182628694.png" alt="闵可夫斯基距离"></p>
<p>其中p是一个变参数：</p>
<p>当p=1时，就是曼哈顿距离；</p>
<p>当p=2时，就是欧氏距离；</p>
<p>当p→∞时，就是切比雪夫距离。</p>
<p>根据p的不同，闵氏距离可以表示某一 类/种 的距离。</p>
<p><strong>小结：</strong></p>
<p>1.闵氏距离，包括曼哈顿距离、欧氏距离和切比雪夫距离都存在明显的缺点:</p>
<p>比如： 二维样本(身高[单位:cm],体重[单位:kg]),现有三个样本：a(180,50)，b(190,50)，c(180,60)。</p>
<p>a与b的闵氏距离（无论是曼哈顿距离、欧氏距离或切比雪夫距离）等于a与c的闵氏距离。但实际上身高的10cm并不能和体重的10kg划等号。</p>
<p><strong>2.闵氏距离的缺点：</strong></p>
<p> <strong>(1)将各个分量的量纲(scale)，也就是“单位”相同的看待了;</strong></p>
<p> <strong>(2)未考虑各个分量的分布（期望，方差等）可能是不同的。</strong></p>
<h3 id="3-5-标准化欧氏距离-Standardized-EuclideanDistance"><a href="#3-5-标准化欧氏距离-Standardized-EuclideanDistance" class="headerlink" title="3.5 标准化欧氏距离 (Standardized EuclideanDistance)"></a>3.5 标准化欧氏距离 (Standardized EuclideanDistance)</h3><p>标准化欧氏距离是针对欧氏距离的缺点而作的一种改进。</p>
<p>思路：既然数据各维分量的分布不一样，那先将各个分量都「标准化」到均值、方差相等。假设样本集X的均值(mean)为m，标准差(standard deviation)为s，X的「标准化变量」表示为：</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/image-20190213184012294.png" alt="image-20190213184012294"></p>
<p>如果将方差的倒数看成一个权重，也可称之为加权欧氏距离(Weighted Euclidean distance)。</p>
<p>举例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>]];（假设两个分量的标准差分别为<span class="number">0.5</span>和<span class="number">1</span>）</span><br><span class="line">经计算得:</span><br><span class="line">d =   <span class="number">2.2361</span>    <span class="number">4.4721</span>    <span class="number">6.7082</span>    <span class="number">2.2361</span>    <span class="number">4.4721</span>    <span class="number">2.2361</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-余弦距离-Cosine-Distance"><a href="#3-6-余弦距离-Cosine-Distance" class="headerlink" title="3.6 余弦距离(Cosine Distance)"></a>3.6 余弦距离(Cosine Distance)</h3><p>几何中，夹角余弦可用来衡量两个向量方向的差异；机器学习中，借用这一概念来衡量样本向量之间的差异。</p>
<ul>
<li>二维空间中向量A(x1,y1)与向量B(x2,y2)的夹角余弦公式：</li>
</ul>
<p><img src="https://github.com/EthanYan6/pic/raw/master/14200251_RZRZ.png" alt="余弦距离"></p>
<ul>
<li>两个n维样本点a(x11,x12,…,x1n)和b(x21,x22,…,x2n)的夹角余弦为：</li>
</ul>
<p><img src="https://github.com/EthanYan6/pic/raw/master/14200252_SE1M.png" alt="余弦距离"></p>
<p>即：</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/14200252_tITR.png" alt="余弦距离"></p>
<p>夹角余弦取值范围为[-1,1]。余弦越大表示两个向量的夹角越小，余弦越小表示两向量的夹角越大。当两个向量的方向重合时余弦取最大值1，当两个向量的方向完全相反余弦取最小值-1。</p>
<p>举例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">-4</span>]]</span><br><span class="line">经计算得:</span><br><span class="line">d =   <span class="number">0.9487</span>    <span class="number">0.9191</span>   <span class="number">-0.5145</span>    <span class="number">0.9965</span>   <span class="number">-0.7593</span>   <span class="number">-0.8107</span></span><br></pre></td></tr></table></figure>

<h3 id="3-7-汉明距离-Hamming-Distance-【了解】"><a href="#3-7-汉明距离-Hamming-Distance-【了解】" class="headerlink" title="3.7 汉明距离(Hamming Distance)【了解】"></a>3.7 汉明距离(Hamming Distance)【了解】</h3><p>两个等长字符串s1与s2的汉明距离为：将其中一个变为另外一个所需要作的最小字符替换次数。</p>
<p>另外还有一些距离，但是并不需要详细学习：<strong>杰卡德距离(Jaccard Distance)</strong>、<strong>马氏距离(Mahalanobis Distance)</strong></p>
<h2 id="4-k-值的选择"><a href="#4-k-值的选择" class="headerlink" title="4.k 值的选择"></a>4.k 值的选择</h2><p><strong>K值过小</strong>：</p>
<p> 容易受到异常点的影响</p>
<p><strong>k值过大：</strong></p>
<p> 受到样本均衡的问题</p>
<hr>
<p><strong>K值选择问题，李航博士的「统计学习方法」一书中所说：</strong></p>
<p>1) 选择较小的K值，就相当于用较小的领域中的训练实例进行预测，「学习」近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是「学习」的估计误差会增大，换句话说，<strong>K值的减小就意味着整体模型变得复杂，容易发生过拟合；</strong></p>
<p>2) 选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，<strong>与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。</strong></p>
<p>3) K=N（N为训练样本个数），则完全不足取，因为此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的类，模型过于简单，忽略了训练实例中大量有用信息。</p>
<p>在实际应用中，K值一般取一个比较小的数值，例如采用交叉验证法（简单来说，就是把训练数据在分成两组:训练集和验证集）来选择最优的K值。对这个简单的分类器进行泛化，用核方法把这个线性模型扩展到非线性的情况，具体方法是把低维数据集映射到高维特征空间。</p>
<hr>
<p><strong>近似误差</strong>：对现有训练集的训练误差，关注训练集，如果近似误差过小可能会出现过拟合的现象，对现有的训练集能有很好的预测，但是对未知的测试样本将会出现较大偏差的预测。模型本身不是最接近最佳模型。</p>
<p><strong>估计误差</strong>：可以理解为对测试集的测试误差，关注测试集，估计误差小说明对未知数据的预测能力好，模型本身最接近最佳模型。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>关系数据库之视图</title>
    <url>/2020/02/10/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>请问视图是什么？视图相关语句有哪些？视图在什么场景下使用？夺命三连</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>对于关系数据库来说，绕不开的一个概念便是『视图』，带着篇首的几个问题，我们来认真学习一下。</p>
<h2 id="视图是什么"><a href="#视图是什么" class="headerlink" title="视图是什么"></a>视图是什么</h2><p>官方文档中如此描述视图：A view is a stored SELECT statement（视图是存储的 <code>SELECT</code> 语句）。我们需要注意，<strong>视图实质上是一组查询语句，是一张虚拟表（可视化的表）而非真正的表</strong>。它将单张表或者多张表中的某些字段或全部字段使用一些特定的查询组合成一张可见的表，如同一张真实的表一样。</p>
<h2 id="视图相关语法"><a href="#视图相关语法" class="headerlink" title="视图相关语法"></a>视图相关语法</h2><h3 id="1-创建视图"><a href="#1-创建视图" class="headerlink" title="1. 创建视图"></a>1. 创建视图</h3><p>执行以下语句创建一个非常简单的视图，该视图执行 <code>SELECT</code> 语句，并将产品的名称和价格返回给用户。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vw_Names  </span><br><span class="line">   <span class="keyword">AS</span>  </span><br><span class="line">   <span class="keyword">SELECT</span> ProductName, Price <span class="keyword">FROM</span> Products;  </span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<h3 id="2-删除视图"><a href="#2-删除视图" class="headerlink" title="2. 删除视图"></a>2. 删除视图</h3><p>使用 <code>DROP</code> 语句删除视图 <code>vw_Names</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> vw_Names;  </span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<h3 id="3-查询视图"><a href="#3-查询视图" class="headerlink" title="3. 查询视图"></a>3. 查询视图</h3><p>如同查询表一样，可以做一些查询操作，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> vw_Names</span><br></pre></td></tr></table></figure>

<p>当然也可以添加一些条件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> vw_Names <span class="keyword">WHERE</span> ProductName=<span class="string">'武汉热干面'</span></span><br></pre></td></tr></table></figure>

<h3 id="4-更新视图"><a href="#4-更新视图" class="headerlink" title="4.更新视图"></a>4.更新视图</h3><p>使用 <code>SQL CREATE OR REPLACE VIEW</code> 语法来进行更新。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> 视图名称 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名称(s)</span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure>

<p><strong>注意：此处的更新实质上是更新视图的查询语句，看到的效果便是展示的数据发生了变化</strong></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>比如我们要在视图 <code>vw_Names</code> 中添加一个字段 <code>Counts</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vw_Names  </span><br><span class="line">   <span class="keyword">AS</span>  </span><br><span class="line">   <span class="keyword">SELECT</span> ProductName, Price, Counts <span class="keyword">FROM</span> Products;  </span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<h2 id="视图适用场景"><a href="#视图适用场景" class="headerlink" title="视图适用场景"></a>视图适用场景</h2><ol>
<li>因权限问题或者数据敏感，不能向外透露全部字段信息</li>
<li>查询逻辑复杂，再与其他表进行关联使得语句更复杂，使用视图后，可简单的将其理解为一个变量</li>
</ol>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>我们在使用视图的时候，相当于执行了视图中的查询语句。更直白的讲<strong>视图是实时更新的</strong>。</p>
<blockquote>
<p>每当用户查询视图时，数据库引擎通过使用 SQL 语句来重建数据。</p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>git仓库上传了个无法点开的空文件夹是什么鬼？</title>
    <url>/2020/02/09/git%E4%BB%93%E5%BA%93%E4%B8%8A%E4%BC%A0%E4%BA%86%E4%B8%AA%E6%97%A0%E6%B3%95%E7%82%B9%E5%BC%80%E7%9A%84%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 

<p>诡异之事年年有，只是今年有点多，在仓库上传到 GitHub 后，偶然在 GitHub 中瞄了一眼，我的天？这个图标不像文件夹啊？这个怎么点不开？git 上传正常啊？本地工作区和暂存区都是干净的了啊？</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>本地仓库提交后，<code>GitHub</code> 中某文件夹无法正常点击，内容无法显示。</p>
<h2 id="二、原因分析"><a href="#二、原因分析" class="headerlink" title="二、原因分析"></a>二、原因分析</h2><p>经排查，定位到原因：之前仓库中包含了一个特殊的文件夹（此文件夹是另外一个 <code>git</code> 仓库），在执行下面语句时：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>提示仓库中包含其他仓库，需要解决此问题。本人操作是删除掉此文件夹中的 <code>.git</code> 配置目录，然后依次执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m 'add the new file'</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>顺利推送仓库到远程，过程中并无报错。这个过程或许是导致问题的原因。</p>
<h2 id="三、解决办法"><a href="#三、解决办法" class="headerlink" title="三、解决办法"></a>三、解决办法</h2><p>现在问题是本地工作区与暂存区干净如新，远程仓库有问题。该如何解决？这时用到了一个命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;dir_name&gt;</span><br></pre></td></tr></table></figure>

<p>我们先来看一下手册：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usage: git rm [&lt;options&gt;] [--] &lt;file&gt;...</span><br><span class="line"></span><br><span class="line">    -n, --dry-run         dry run</span><br><span class="line">    -q, --quiet           do not list removed files</span><br><span class="line">    --cached              only remove from the index</span><br><span class="line">    -f, --force           override the up-to-date check</span><br><span class="line">    -r                    allow recursive removal</span><br><span class="line">    --ignore-unmatch      exit with a zero status even if nothing matched</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>--cached</code> 的作用：将文件仅仅从索引中移除，翻译成人能看懂的话便是 「之前已经提交，现在将此目录释放掉，恢复到工作区，未被追踪的状态，即 <code>git add .</code> 命令之前的状态」</p>
<p>我们执行完此命令之后使用如下命令查看所有改变后的文件状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>发现出问题的目录已经变成了红色未被追踪的状态，此时将出问题的目录中所有包含 <code>git</code> 信息的文件和目录都删除，然后再依次执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m 'add the new file'</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>去远程仓库中查看后发现问题解决。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>当出现未知问题致使远程仓库同预期结果不一致时，本地可以将问题目录恢复到未被追踪状态，核查完问题之后再次提交最新结果，操作步骤如下：</p>
<p>1.删除缓存，释放目录，恢复到未被追踪状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;dir_name&gt;</span><br></pre></td></tr></table></figure>

<p>2.依次执行如下操作再次提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m 'Information you need to submit'</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>3.完美解决问题。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch中join类型数据如何进行父子文档查询</title>
    <url>/2020/02/07/elasticsearch%E4%B8%ADjoin%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%88%B6%E5%AD%90%E6%96%87%E6%A1%A3%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 

<p>ES 中 join 类型数据如何根据父文档查询全部子文档？又如何根据子文档查询其父文档呢？</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-join-简介"><a href="#1-join-简介" class="headerlink" title="1.join 简介"></a>1.join 简介</h2><p>在 <code>ES</code> 中有一种特殊的数据类型『<code>join</code>』，被形象地称为父子文档。它是一种可以在同一索引中存放两种有关系数据的数据类型，类似于关系数据库中让两张表发生关系的<strong>外键 <code>FOREIGN KEY</code></strong> 。</p>
<p>在官方文档中这样介绍：<code>join</code> 数据类型的字段是一个特殊字段，它可以在同一个索引的文档中创建 <code>父子关系</code> 。通过参数 <code>relations</code> 定义可能存在关系的一组文档，这个关系的参数由 <code>父名</code> 和 <code>子名</code> 构成。下方是原文档描述：</p>
<p>The <code>join</code> datatype is a special field that creates parent/child relation within documents of the same index. The <code>relations</code> section defines a set of possible relations within the documents, each relation being a parent name and a child name. </p>
<h2 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义"></a>2.定义</h2><p>我们需要在设置 <code>mapping</code> 时将其关系定义好，如下示例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT 索引名称</span><br><span class="line">&#123;</span><br><span class="line">  "mappings": &#123;</span><br><span class="line">    "properties": &#123;</span><br><span class="line">      "join类型的字段名称": &#123; </span><br><span class="line">        "type": "join",</span><br><span class="line">        "relations": &#123;</span><br><span class="line">          "父文档标示字段名": "子文档标示字段名" </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-1-父文档"><a href="#2-1-父文档" class="headerlink" title="2.1 父文档"></a>2.1 父文档</h3><p>构建父文档时可以通过如下方法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT 索引名称/类型/文档id?refresh</span><br><span class="line">&#123;</span><br><span class="line">  "text": "EthanYan",</span><br><span class="line">  ...		// 父文档中其他的字段与值</span><br><span class="line">  "join类型的字段名称": &#123;</span><br><span class="line">    "name": "父文档标示字段名" </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式是为了便于理解，与下方子文档中构建方式对应。当你运用熟练后，有一种简便的构建方法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT 索引名称/类型/文档id?refresh</span><br><span class="line">&#123;</span><br><span class="line">  "text": "EthanYan",</span><br><span class="line">  ...		// 父文档中其他的字段与值</span><br><span class="line">  "join类型的字段名称": "父文档标示字段名" </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-子文档"><a href="#2-2-子文档" class="headerlink" title="2.2 子文档"></a>2.2 子文档</h3><p>构建子文档时可以通过如下方法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT 索引名称/类型/文档id?routing=父文档id&amp;refresh </span><br><span class="line">&#123;</span><br><span class="line">  "text": "xiaoyan",</span><br><span class="line">  ...		// 子文档中其他的字段与值</span><br><span class="line">  "join类型的字段名称": &#123;</span><br><span class="line">    "name": "子文档标示字段名", </span><br><span class="line">    "parent": "父文档id" </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>构建子文档时与父文档有些许不同，以下几点需要特别注意：</p>
<p>1.<code>url</code> 中可以看到有一个参数 <code>routing</code> ，<strong>此参数必须设置</strong>，因为我们需要保证父文档与子文档在同一分片中。其原文描述为：The routing value is mandatory because parent and child documents must be indexed on the same shard.</p>
<p>2.我们可以看到子文档在 <code>join</code> 类型字段中除了参数 <code>name</code> 外，还多了一个参数 <code>parent</code> ，故名思义，此字段为了指明父文档的所在，其值填写为父文档的 <code>id</code></p>
<h2 id="3-查询"><a href="#3-查询" class="headerlink" title="3.查询"></a>3.查询</h2><p>此字段类型当然是为了查询而存在，要不然没有灵魂。下面举例进行说明。索引名为 <code>sales_org</code></p>
<p>有一个父文档为下方示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"node_name_cn"</span>: <span class="string">"川渝"</span>,</span><br><span class="line">  <span class="attr">"node_code"</span>: <span class="string">"LP.IIB.RW.CTU"</span>,</span><br><span class="line">  <span class="attr">"node_type"</span>: <span class="string">"办事处"</span>,</span><br><span class="line">  <span class="attr">"node_id_fqdn"</span>: <span class="string">"SI/LP/LP.IIB.RW/LP.IIB.RW.CTU"</span>,</span><br><span class="line">  <span class="attr">"node_name_fqdn"</span>: <span class="string">"SI/LP//川渝"</span>,</span><br><span class="line">  <span class="attr">"node_name_en"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"mgmt_territory"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"node_tree_level"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">"node_name_short"</span>: <span class="string">"LP.IIB.RW.CTU"</span>,</span><br><span class="line">  <span class="attr">"node_info"</span>: <span class="string">"node_parent"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个子文档示例如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;	</span><br><span class="line">  <span class="attr">"empl_id"</span>: <span class="string">"*******"</span>,</span><br><span class="line">  <span class="attr">"email_addr"</span>: <span class="string">"*****@fafa.com"</span>,</span><br><span class="line">  <span class="attr">"dept_id"</span>: <span class="string">"LP.IIB.RW.CTU"</span>,</span><br><span class="line">  <span class="attr">"name_cn"</span>: <span class="string">"Nie Cong"</span>,</span><br><span class="line">  <span class="attr">"node_info"</span>: &#123;</span><br><span class="line">    <span class="attr">"parent"</span>: <span class="string">"LP.IIB.RW.CTU"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"node_child"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>join</code> 类型字段名为 <code>node_info</code> ，父文档标示字段名为 <code>node_parent</code> ，子文档标示字段名为 <code>node_child</code> 。</p>
<h3 id="3-1-基于父文档查询全部子文档"><a href="#3-1-基于父文档查询全部子文档" class="headerlink" title="3.1 基于父文档查询全部子文档"></a>3.1 基于父文档查询全部子文档</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST sales_org/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "has_parent": &#123;</span><br><span class="line">      "parent_type": "node_parent",		// 填写父文档标示字段名</span><br><span class="line">      "query": &#123;		// 填写查询条件，注意填写的查询条件是查询父文档，该查询条件是为定位到要基于的父文档</span><br><span class="line">        "match": &#123;</span><br><span class="line">          "_id": "LP.IIB.RW.CTU"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-基于子文档查询其父文档"><a href="#3-2-基于子文档查询其父文档" class="headerlink" title="3.2 基于子文档查询其父文档"></a>3.2 基于子文档查询其父文档</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "has_child": &#123;</span><br><span class="line">      "type": "node_child",		// 填写子文档标示字段名</span><br><span class="line">      "query": &#123;		// 填写查询条件，注意填写的查询条件是查询子文档，该查询条件是为定位到要基于的子文档</span><br><span class="line">        "match": &#123;</span><br><span class="line">          "dept_id": "LP.IIB.RW.CTU"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点总结</title>
    <url>/2020/02/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>《计算机网络》第五版 谢希仁</strong> 知识点大汇总</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-OSI、TCP-IP、五层协议的体系结构以及各层协议"><a href="#1-OSI、TCP-IP、五层协议的体系结构以及各层协议" class="headerlink" title="1.OSI、TCP/IP、五层协议的体系结构以及各层协议"></a>1.OSI、TCP/IP、五层协议的体系结构以及各层协议</h2><p><img src="https://github.com/EthanYan6/pic/raw/master/1.png" alt="img"></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/2.png" alt="img"></p>
<p><strong>OSI分层（7层）</strong>：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p><strong>TCP/IP分层（4层）</strong>：网络接口层、网际层、运输层、应用层。</p>
<p><strong>五层协议（5层）</strong>：物理层、数据链路层、网络层、运输层、应用层。</p>
<p><strong><em>每一层的协议如下：</em></strong></p>
<p><strong>物理层：</strong><code>RJ45</code>、<code>CLOCK</code>、<code>IEEE802.3</code>   （中继器，集线器，网关）</p>
<p><strong>数据链路：</strong><code>PPP</code>、<code>FR</code>、<code>HDLC</code>、<code>VLAN</code>、<code>MAC</code>  （网桥，交换机）</p>
<p><strong>网络层：</strong><code>IP</code>、<code>ICMP</code>、<code>ARP</code>、<code>RARP</code>、<code>OSPF</code>、<code>IPX</code>、<code>RIP</code>、<code>IGRP</code> （路由器）</p>
<p><strong>传输层：</strong><code>TCP</code>、<code>UDP</code>、<code>SPX</code></p>
<p><strong>会话层：</strong><code>NFS</code>、<code>SQL</code>、<code>NETBIOS</code>、<code>RPC</code></p>
<p><strong>表示层：</strong><code>JPEG</code>、<code>MPEG</code>、<code>ASII</code></p>
<p><strong>应用层：</strong><code>FTP</code>、<code>DNS</code>、<code>Telnet</code>、<code>SMTP</code>、<code>HTTP</code>、<code>WWW</code>、<code>NFS</code></p>
<p><strong><em>每一层的作用如下：</em></strong></p>
<p><strong>物理层：</strong>通过媒介传输比特,确定机械及电气规范（比特 <code>Bit</code>）</p>
<p><strong>数据链路层</strong>：将比特组装成帧和点到点的传递（帧 <code>Frame</code>）</p>
<p><strong>网络层</strong>：负责数据包从源到宿的传递和网际互连（包 <code>PackeT</code>）</p>
<p><strong>传输层</strong>：提供端到端的可靠报文传递和错误恢复（段 <code>Segment</code>）</p>
<p><strong>会话层</strong>：建立、管理和终止会话（会话协议数据单元 <code>SPDU</code>）</p>
<p><strong>表示层</strong>：对数据进行翻译、加密和压缩（表示协议数据单元 <code>PPDU</code>）</p>
<p><strong>应用层</strong>：允许访问 <code>OSI</code> 环境的手段（应用协议数据单元 <code>APDU</code>）</p>
<h2 id="2-IP地址分类"><a href="#2-IP地址分类" class="headerlink" title="2.IP地址分类"></a>2.IP地址分类</h2><p>　　<code>IP</code> 地址是32位的二进制数值，用于在 <code>TCP/IP</code> 通讯协议中标记每台计算机的地址。通常我们使用点式十进制来表示，如192.168.0.5等等。</p>
<p>　　每个 <code>IP</code> 地址又可分为两部分。即网络号部分和主机号部分：网络号表示其所属的网络段编号，主机号则表示该网段中该主机的地址编号。按照网络规模的大小，<code>IP</code> 地址可以分为 <code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>、<code>E</code> 五类。</p>
<p>A类地址：以0开头，第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）；</p>
<p>B类地址：以10开头，第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；</p>
<p>C类地址：以110开头，第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类别         网络号                  /占位数      主机号             /    占位数    用途</span><br><span class="line"></span><br><span class="line">A（以0开头）  1～126                 /  8      0～255 0～255 1～254 /     24      国家级</span><br><span class="line"></span><br><span class="line">B（以10开头） 128～191 0～255        /  16     0～255 1～254        /     16      跨过组织</span><br><span class="line"></span><br><span class="line">C（以110开头）192～223 0～255 0～255 /  24     1～254               /     8       企业组织</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>1）以下是留用的内部私有地址，<code>Internet</code> 上没使用的地址</p>
<p><code>A</code> 类 10.0.0.0–10.255.255.255</p>
<p><code>B</code> 类 172.16.0.0–172.31.255.255</p>
<p><code>C</code> 类 192.168.0.0–192.168.255.255</p>
<p>2）<code>IP</code> 地址与子网掩码相与得到网络号</p>
<p>3）主机号，全为0的是网络号（例如：192.168.2.0），主机号全为1的为广播地址（192.168.2.255）</p>
<h2 id="3-ARP是地址解析协议，简单语言解释一下工作原理"><a href="#3-ARP是地址解析协议，简单语言解释一下工作原理" class="headerlink" title="3.ARP是地址解析协议，简单语言解释一下工作原理"></a>3.ARP是地址解析协议，简单语言解释一下工作原理</h2><p>地址解析协议，即 <code>ARP</code>（<code>Address Resolution Protocol</code>），是根据 <code>IP</code> 地址获取物理地址的一个 <code>TCP/IP</code> 协议。</p>
<p>1.首先，每个主机都会在自己的 <code>ARP</code> 缓冲区中建立一个 <code>ARP</code> 列表，以表示 <code>IP</code> 地址和 <code>MAC</code> 地址之间的对应关系。</p>
<p>2.当源主机要发送数据时，首先检查ARP列表中是否有对应 <code>IP</code> 地址的目的主机的 <code>MAC</code> 地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送 <code>ARP</code> 数据包，该数据包包括的内容有：源主机<code>IP</code>地址，源主机 <code>MAC</code> 地址，目的主机的 <code>IP</code> 地址</p>
<p>3.当本网络的所有主机收到该 <code>ARP</code> 数据包时，首先检查数据包中的 <code>IP</code> 地址是否是自己的 <code>IP</code> 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 <code>IP</code> 和 <code>MAC</code> 地址写入到 <code>ARP</code> 列表中，如果已经存在，则覆盖，然后将自己的 <code>MAC</code> 地址写入 <code>ARP</code> 响应包中，告诉源主机自己是它想要找的 <code>MAC</code> 地址。</p>
<p>4.源主机收到 <code>ARP</code> 响应包后。将目的主机的 <code>IP</code> 和 <code>MAC</code> 地址写入 <code>ARP</code> 列表，并利用此信息发送数据。如果源主机一直没有收到 <code>ARP</code> 响应数据包，表示 <code>ARP</code> 查询失败。</p>
<p><strong>注意：广播（255.255.255.255）发送 <code>ARP</code> 请求，单播发送 <code>ARP</code> 响应。</strong></p>
<h2 id="4-简单介绍几种协议"><a href="#4-简单介绍几种协议" class="headerlink" title="4.简单介绍几种协议"></a>4.简单介绍几种协议</h2><p><code>ICMP</code> 协议： 因特网控制报文协议。它是 <code>TCP/IP</code> 协议族的一个子协议，用于在 <code>IP</code> 主机、路由器之间传递控制消息</p>
<p><code>TFTP</code> 协议： 是 <code>TCP/IP</code> 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</p>
<p><code>HTTP</code> 协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统</p>
<p><code>NAT</code> 协议：网络地址转换属接入广域网( <code>WAN</code> )技术，是一种将私有（保留）地址转化为合法 <code>IP</code> 地址的转换技术</p>
<p><code>DHCP</code> 协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段，使用 <code>UDP</code> 协议工作。<strong>具体用途</strong>：给内部网络或网络服务供应商自动分配 <code>IP</code> 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<h2 id="5-TCP三次握手四次挥手"><a href="#5-TCP三次握手四次挥手" class="headerlink" title="5.TCP三次握手四次挥手"></a>5.TCP三次握手四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次握手：客户端发送 <code>syn</code> 包( <code>seq=x</code> )到服务器，并进入 <code>SYN_SEND</code> (发送)状态，等待服务器确认；</p>
<p>第二次握手：服务器收到 <code>syn</code>包，必须确认客户的 <code>SYN</code>（<code>ack=x+1</code>），同时自己也发送一个 <code>SYN</code> 包（<code>seq=y</code> ），即 <code>SYN+ACK</code> 包，此时服务器进入 <code>SYN_RECV</code>（接收）状态；</p>
<p>第三次握手：客户端收到服务器的 <code>SYN＋ACK</code> 包，向服务器发送确认包 <code>ACK</code> ( <code>ack=y+1</code> )，此包发送完毕，客户端和服务器进入 <code>ESTABLISHED</code>（已建立）状态，完成三次握手。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/3.png" alt="img"></p>
<p><strong>说明：</strong><br>1）<code>SYN</code> 和 <code>ACK</code> 是标志位（0/1）（<code>ACK=1</code>表明 <code>ack</code> 有效），<code>seq</code> 是序列号，<code>ack</code> 是确认号。</p>
<p>2）给对方的确认方式就是把对方传来的 <code>seq+1</code> 并赋给 <code>ack</code>。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>第一次挥手：主动关闭方发送一个 <code>FIN</code>，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在 <code>fin</code> 包之前发送出去的数据，如果没有收到对应的 <code>ack</code> 确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p>
<p>第二次挥手：被动关闭方收到 <code>FIN</code> 包后，发送一个 <code>ACK</code> 给对方，确认序号为收到序号 +1。</p>
<p>第三次挥手：被动关闭方发送一个 <code>FIN</code>，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
<p>第四次挥手：主动关闭方收到 <code>FIN</code> 后，发送一个 <code>ACK</code> 给被动关闭方，确认序号为收到序号 +1，至此，完成四次挥手。</p>
<p><strong>说明：</strong></p>
<p>1）<strong>SYN攻击：用众多伪造ip地址向服务器发送SYN=1（请求连接）</strong>，让服务器处于<strong>SYN-RCVD状态</strong>，但都无法第三次握手（因为伪造 <code>ip</code> 不存在）</p>
<p>2）4次挥手中的 <code>FIN</code> 就相当于三次握手中的 <code>SYN</code>。</p>
<p>3）序号 <code>seq</code>，确认序号 <code>ack</code>，确认标志位 <code>ACK</code> 作用还是一样的，就是确认作用（把 <code>seq</code> 加上1赋给 <code>ack</code>，并把 <code>ACK</code> 置1）</p>
<p>4）为什么一个3次1个4次不一样？</p>
<p>因为两端的数据并不是同时发送完，所以两端谁发送完数据都需要自己告诉对方一次，并且对方确认一次。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/4.png" alt="img"></p>
<h2 id="6-在浏览器中输入www-baidu-com后执行的全部过程"><a href="#6-在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="6.在浏览器中输入www.baidu.com后执行的全部过程"></a>6.在浏览器中输入<a href="http://www.baidu.com后执行的全部过程" target="_blank" rel="noopener">www.baidu.com后执行的全部过程</a></h2><p>1、客户端浏览器通过 <code>DNS</code> 解析到<a href="http://www.baidu.com的" target="_blank" rel="noopener">www.baidu.com的</a> <code>IP</code> 地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个 <code>HTTP</code> 会话到 220.161.27.48，然后通过 <code>TCP</code> 进行封装数据包，输入到网络层。</p>
<p> 2、在客户端的<strong>传输层(添加TCP头)</strong>，把 <code>HTTP</code> 会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的 5000 端口。然后使用IP层的IP地址查找目的端。</p>
<p> 3、客户端的<strong>网络层（添加IP头）</strong>不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
<p> 4、客户端的<strong>链路层（添加MAC头）</strong>包通过链路层发送到路由器，通过邻居协议查找给定 <code>IP</code> 地址的 <code>MAC</code> 地址，然后发送 <code>ARP</code> 请求查找目的地址，如果得到回应后就可以使用 <code>ARP</code> 的请求应答交换的 <code>IP</code> 数据包现在就可以传输了，然后发送 <code>IP</code> 数据包到达服务器的地址。</p>
<h2 id="7-TCP和UDP的区别"><a href="#7-TCP和UDP的区别" class="headerlink" title="7.TCP和UDP的区别"></a>7.TCP和UDP的区别</h2><p><strong>这是传输层的两个协议，先说一下传输层的两大功能：</strong></p>
<ol>
<li><strong>复用：</strong>在发送端，多个应用进程公用一个传输层；</li>
<li><strong>分用：</strong>在接收端，传输层会根据端口号将数据分给不同的应用进程。 </li>
</ol>
<p><strong>传输层和网络层的区别：</strong></p>
<ol>
<li>网络层为不同的<strong>主机</strong>提供通信服务，传输层为不同应用<strong>进程</strong>提供通信服务。</li>
<li>网络层只对报文头部进行差错检测，而传输层对整个报文进行差错检测。</li>
</ol>
<p><strong>UDP（User Data Protocol）用户数据报协议</strong></p>
<ol>
<li>无连接</li>
<li>不可靠（不能保证都送达）</li>
<li>面向报文（<code>UDP</code> 数据传输单位是报文，不会对数据进行拆分和拼接操作，只是给上层传来的数据加个 <code>UDP</code> 头或者给下层来的数据去掉 <code>UDP</code> 头）</li>
<li>没有拥塞控制，始终以恒定速率发送数据</li>
<li>支持一对一、一对多、多对多、多对一</li>
<li>首部开销小，只有8字节</li>
</ol>
<p><strong>TCP（Transmission Control Protocol）传输控制协议</strong></p>
<ol>
<li>有连接</li>
<li>可靠的</li>
<li>面向字节流</li>
<li>全双工通信，<code>TCP</code> 两端既可以作为发送端也可以作为接收端</li>
<li>连接的两端只能是两个端点，即一对一，不能一对多</li>
<li>至少20个字节，比 <code>UDP</code> 大的多</li>
</ol>
<p><strong>什么是TCP连接</strong></p>
<p><code>TCP</code> 连接是一种抽象的概念，表示一条可以通信的链路。<br>每个 <code>TCP</code> 连接有且仅有两个端点，表示通信的双方，且双方在任意时刻都可以作为发送者和接受者。</p>
<p><strong>什么是套接字</strong></p>
<p>一条 <code>TCP</code> 连接的两端就是两个套接字。<br>套接字 = <code>IP</code> 地址:端口号<br>因此，<code>TCP</code> 连接 = （套接字1，套接字2）= （<code>IP1</code>：端口号1，<code>IP2</code>：端口号2）</p>
<h2 id="8-TCP对应的协议和UDP对应的协议"><a href="#8-TCP对应的协议和UDP对应的协议" class="headerlink" title="8.TCP对应的协议和UDP对应的协议"></a>8.TCP对应的协议和UDP对应的协议</h2><p><strong>TCP对应的协议：</strong></p>
<p>（1） <strong>FTP</strong>：定义了文件传输协议，使用<strong>21</strong>端口。</p>
<p>（2） <strong>Telnet</strong>：一种用于远程登陆的端口，使用<strong>23</strong>端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。</p>
<p>（3） <strong>SMTP</strong>：邮件传送协议，用于发送邮件。服务器开放的是<strong>25</strong>号端口。</p>
<p>（4） <strong>POP3</strong>：它是和 <code>SMTP</code> 对应，<code>POP3</code> 用于接收邮件。<code>POP3</code> 协议所用的是<strong>110</strong>端口。</p>
<p>（5）<strong>HTTP</strong>：是从 <code>Web</code> 服务器传输超文本到本地浏览器的传送协议。</p>
<p><strong>UDP对应的协议：</strong></p>
<p>（1） <strong>DNS</strong>：用于域名解析服务，将域名地址转换为IP地址。DNS用的是<strong>53</strong>号端口。</p>
<p>（2） <strong>SNMP</strong>：简单网络管理协议，使用<strong>161</strong>号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>
<p>（3） <strong>TFTP</strong>(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口<strong>69</strong>上使用UDP服务。</p>
<h2 id="9-DNS域名系统，简单描述其工作原理。"><a href="#9-DNS域名系统，简单描述其工作原理。" class="headerlink" title="9.DNS域名系统，简单描述其工作原理。"></a>9.DNS域名系统，简单描述其工作原理。</h2><p>　　当 <code>DNS</code> 客户机需要在程序中使用名称时，它会查询 <code>DNS</code> 服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的 <code>DNS</code> 域名，指定的查询类型，<code>DNS</code> 域名的指定类别。基于 <code>UDP</code> 服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如 <code>HTTP</code>，<code>SMTP</code>等在其中需要完成主机名到IP地址的转换。</p>
<h2 id="10-面向连接和非面向连接的服务的特点是什么？"><a href="#10-面向连接和非面向连接的服务的特点是什么？" class="headerlink" title="10.面向连接和非面向连接的服务的特点是什么？"></a>10.面向连接和非面向连接的服务的特点是什么？</h2><ul>
<li><p>面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。</p>
</li>
<li><p>非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。</p>
</li>
</ul>
<h2 id="11-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"><a href="#11-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？" class="headerlink" title="11.TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"></a>11.TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</h2><p>答：建立连接的过程是利用客户服务器模式，假设主机 <code>A</code> 为客户端，主机 <code>B</code> 为服务器端。</p>
<p>（1）<code>TCP</code> 的三次握手过程：主机 <code>A</code> 向 <code>B</code> 发送连接请求；主机 <code>B</code> 对收到的主机 <code>A</code> 的报文段进行确认；主机 <code>A</code> 再次对主机 <code>B</code> 的确认进行确认。</p>
<p>（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机 <code>B</code>，因而产生错误。失效的连接请求报文段是指：<strong>主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。</strong>考虑这样一种特殊情况，主机 <code>A</code> 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 <code>B</code>，<strong>主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会</strong>，主机 <code>B</code> 就一直在等待主机 <code>A</code> 发送数据，导致主机 <code>B</code> 的资源浪费。（这就是缺少第三次握手( <code>A</code> 再给 <code>B</code> 确认））</p>
<p>（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。</p>
<h2 id="12-了解交换机、路由器、网关的概念，并知道各自的用途"><a href="#12-了解交换机、路由器、网关的概念，并知道各自的用途" class="headerlink" title="12.了解交换机、路由器、网关的概念，并知道各自的用途"></a>12.了解交换机、路由器、网关的概念，并知道各自的用途</h2><p><strong>1）交换机</strong></p>
<p>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，当控制电路收到数据包以后，<strong>处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上</strong>，通过内部 交换矩阵迅速将数据包传送到目的端口。目的 <code>MAC</code> 若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。</p>
<p><strong>交换机工作于OSI参考模型的第二层，即数据链路层</strong>。交换机内部的 <code>CPU</code> 会在每个端口成功连接时，通过 <code>ARP</code> 协议学习它的 <code>MAC</code> 地址，保存成一张 <code>ARP</code>表。在今后的通讯中，发往该 <code>MAC</code> 地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。</p>
<p>交换机被广泛应用于二层网络交换，俗称“二层交换机”。</p>
<p>交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在 <code>OSI</code> 七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。</p>
<p><strong>2）路由器</strong></p>
<p><strong>路由器</strong>（<strong>Router</strong>）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（ <code>host</code> 到 <code>host</code> 之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转送。路由工作在<strong>OSI模型的第三层——即网络层</strong>，例如网际协议。</p>
<p><strong>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。</strong> 路由器与交换器的差别，路由器是属于 <code>OSI</code> 第三层的产品，交换器是 <code>OSI</code> 第二层的产品(这里特指二层交换机)。</p>
<p><strong>3）网关</strong></p>
<p><strong>网关</strong>（<code>Gateway</code>），<strong>网关</strong>顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关<code>TCP/IP</code> 的文献曾经把网络层使用的路由器（<code>Router</code>）称为网关，<strong>在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP</strong>），经常在家庭中或者小型企业网络中使用，用于连接局域网和 <code>Internet</code>。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。</p>
<blockquote>
<p>文章来源于网络</p>
<p>原文链接：<a href="https://www.cnblogs.com/xdyixia/p/9275246.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdyixia/p/9275246.html</a></p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch的一些小知识点</title>
    <url>/2020/01/31/elasticsearch%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>这个假期有多少人新添了一份职业「云监工」，又有多少人干起了小区保安的工作（统计着进出小区的车辆），还有一些人无聊到数火龙果的「黑芝麻」…… 实不相瞒，我也一样，只不过无聊之际，偶尔看看书。之前对于 elasticsearch 介绍过一些常用的 API ，今天再做一些额外的补充。</p>
<blockquote>
<p>「云监工」：网络流行词，来源于央视频直播武汉开建的防治传染病医院火神山医院的建设工地，网友们虽然不能到现场出把力，但也给自己加了一个身份：云监工，通过直播镜头去“监督”医院的建设进度。</p>
<p>小区保安工作：很多人在家无聊，自觉统计着出入小区人员车辆数量，以帮助监督是否有人在疫情期间四处乱逛。</p>
<p>数火龙果的籽：这个起源于网友晒出的图片，为一个火龙果所有的籽标上了序号。</p>
</blockquote>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-短语搜索"><a href="#1-短语搜索" class="headerlink" title="1.短语搜索"></a>1.短语搜索</h2><p>之前向大家介绍了模糊搜索 <code>match</code> ，现在又有了很多复杂的需求：确切的匹配若干个单词（同一字段的值中包含多个词）或者短语。这就用到了一个新的方法 <code>match_phrase</code>，官方示例如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match_phrase"</span> : &#123;</span><br><span class="line">            <span class="attr">"about"</span> : <span class="string">"rock climbing"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述语句查询 <code>about</code> 字段中同时包含 <code>rock</code> 和 <code>climbing</code>（并且是相邻的）的员工记录。<code>match_phrase</code> 方法也可以用于匹配<strong>短语(phrases)</strong></p>
<p>有一些新来的小伙伴，可能对于上面的表达不是十分清楚，下面详细介绍一下。<code>GET</code> 表示请求方式，<code>/megacorp/employee/_search</code> 表示访问路径 <code>PATH</code>，大括号中的内容即 <code>DSL</code> 语句。</p>
<h3 id="1-1-API-访问方式"><a href="#1-1-API-访问方式" class="headerlink" title="1.1 API 访问方式"></a>1.1 API 访问方式</h3><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p>与 <code>elasticsearch</code> 进行交互时，可以通过 <code>crul</code> 方式，与其他普通的 <code>HTTP</code> 请求相同：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X&lt;VERB&gt; '&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;' -d '&lt;BODY&gt;'</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>VERB</strong> 表示请求方式：<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>HEAD</code>, <code>DELETE</code></p>
<p><strong>PROTOCOL</strong> 表示访问协议，如 <code>HTTP</code> / <code>HTTPS</code> （只有在 <code>Elasticsearch</code> 前面有 <code>https</code> 代理的时候可用）</p>
<p><strong>HOST</strong> 表示 <code>Elasticsearch</code> 集群中的任何一个节点的主机名，如果是在本地的节点，那么就叫 <code>localhost</code></p>
<p><strong>PORT</strong> 表示 <code>Elasticsearch HTTP</code> 服务所在的端口，默认为 9200</p>
<p><strong>PATH</strong> 表示 <code>API</code> 路径，也就是示例中的 <code>/megacorp/employee/_search</code></p>
<p><strong>QUERY_STRING</strong> 表示一些可选的查询请求参数，例如 <code>?pretty</code> 参数使得返回 <code>JSON</code> 数据更加美观易读。</p>
<p><strong>BODY</strong> 一个 <code>JSON</code> 格式的请求主体（如果请求需要的话）</p>
</blockquote>
<h4 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h4><p>大家经常使用到的工具，通过输入请求 <code>url</code> 以及根据需要填写 <code>DSL</code> 语句做为请求体，进行访问。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>任何其他发送 <code>HTTP</code> 请求的方式</p>
<h2 id="2-搜索结果高亮"><a href="#2-搜索结果高亮" class="headerlink" title="2.搜索结果高亮"></a>2.搜索结果高亮</h2><p>故名思义，我们可以将搜索到的文档中匹配到的关键词进行高亮显示。它最大的作用就是醒目，让你一眼发现这个文档被匹配的原因。语句也很简单，只需要在之前的查询语句上增加 <code>highlight</code>参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"match_phrase"</span> : &#123;</span><br><span class="line">            <span class="string">"about"</span> : <span class="string">"rock climbing"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"highlight"</span>: &#123;</span><br><span class="line">        <span class="string">"fields"</span> : &#123;</span><br><span class="line">            <span class="string">"about"</span> : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们运行这个语句时，会命中与之前相同的结果，但是在返回结果中会有一个新的部分叫做 <code>highlight</code>，这里包含了来自<code>about</code>字段中的文本，并且用 <code>&lt;em&gt;&lt;/em&gt;</code>来标识匹配到的单词。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="string">"hits"</span>: &#123;</span><br><span class="line">      <span class="string">"total"</span>:      <span class="number">1</span>,</span><br><span class="line">      <span class="string">"max_score"</span>:  <span class="number">0.23013961</span>,</span><br><span class="line">      <span class="string">"hits"</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="string">"_score"</span>:         <span class="number">0.23013961</span>,</span><br><span class="line">            <span class="string">"_source"</span>: &#123;</span><br><span class="line">               <span class="string">"first_name"</span>:  <span class="string">"John"</span>,</span><br><span class="line">               <span class="string">"last_name"</span>:   <span class="string">"Smith"</span>,</span><br><span class="line">               <span class="string">"age"</span>:         <span class="number">25</span>,</span><br><span class="line">               <span class="string">"about"</span>:       <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">               <span class="string">"interests"</span>: [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"highlight"</span>: &#123;</span><br><span class="line">               <span class="string">"about"</span>: [</span><br><span class="line">                  <span class="string">"I love to go &lt;em&gt;rock&lt;/em&gt; &lt;em&gt;climbing&lt;/em&gt;"</span> &lt;<span class="number">1</span>&gt;</span><br><span class="line">               ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&lt;1&gt; 原有文本中高亮的片段</p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>还在拧螺丝？是时候学习造航母了！</title>
    <url>/2020/01/30/%E8%BF%98%E5%9C%A8%E6%8B%A7%E8%9E%BA%E4%B8%9D%EF%BC%9F%E6%98%AF%E6%97%B6%E5%80%99%E5%AD%A6%E4%B9%A0%E9%80%A0%E8%88%AA%E6%AF%8D%E4%BA%86%EF%BC%81/</url>
    <content><![CDATA[<center>Author：闫玉良</center>
面试造航母，实际拧螺丝。这是大部分互联网人面对的实际情境，如何跳出舒适的圈子，撤离局部，俯览大局？

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>限制自己的不是外界，而是内心。你之所以没听过这句话，是因为它出自小闫同学（鹅鹅鹅～笑出了鹅叫声）为了避免三年螺丝工，还是提升一下自己，为造航母做准备吧。一些架构知识，既可以培养全局观，又可以助你深层次认识『螺丝』。</p>
<h2 id="一、架构演变"><a href="#一、架构演变" class="headerlink" title="一、架构演变"></a>一、架构演变</h2><p>一般来说，任何一个项目至少有三层内容来组成：<strong>web访问层、数据库层、存储层</strong></p>
<h3 id="1-1-初级阶段"><a href="#1-1-初级阶段" class="headerlink" title="1.1 初级阶段"></a>1.1 初级阶段</h3><p>在初级阶段又会人为细分为如下几个阶段：</p>
<h4 id="1-1-1-单体阶段"><a href="#1-1-1-单体阶段" class="headerlink" title="1.1.1 单体阶段"></a>1.1.1 单体阶段</h4><p><strong>常见场景：</strong>项目初期 </p>
<p><strong>部署特点：</strong>所有应用服务都在一台主机 </p>
<p><strong>应用特点：</strong>开发简单</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%841.png" alt="单体阶段"></p>
<h4 id="1-1-2-应用-数据分离阶段"><a href="#1-1-2-应用-数据分离阶段" class="headerlink" title="1.1.2 应用/数据分离阶段"></a>1.1.2 应用/数据分离阶段</h4><p><strong>常见场景：</strong>项目初期，用户访问数据库有压力 </p>
<p><strong>部署特点：</strong>应用和数据库单独部署 </p>
<p><strong>应用特点：</strong>开发简单</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%842.png" alt="应用/数据分离阶段"></p>
<h4 id="1-1-3-页面动静分离阶段"><a href="#1-1-3-页面动静分离阶段" class="headerlink" title="1.1.3 页面动静分离阶段"></a>1.1.3 页面动静分离阶段</h4><p><strong>常见场景：</strong>项目初期，用户访问页面有压力</p>
<p><strong>部署特点：</strong>剥离用户读请求和写请求操作</p>
<p><strong>应用特点：</strong>开发简单</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%843.png" alt="页面动静分离阶段"></p>
<h4 id="1-1-4-页面-数据缓存阶段"><a href="#1-1-4-页面-数据缓存阶段" class="headerlink" title="1.1.4 页面/数据缓存阶段"></a>1.1.4 页面/数据缓存阶段</h4><p><strong>常见场景：</strong>项目初期，用户访问有压力 </p>
<p><strong>部署特点：</strong>代理和数据库前面增加缓存组件 </p>
<p><strong>应用特点：</strong>开发简单</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%844.png" alt="页面/数据缓存阶段"></p>
<h3 id="1-2-中期阶段"><a href="#1-2-中期阶段" class="headerlink" title="1.2 中期阶段"></a>1.2 中期阶段</h3><h4 id="1-2-1-应用服务集群阶段"><a href="#1-2-1-应用服务集群阶段" class="headerlink" title="1.2.1 应用服务集群阶段"></a>1.2.1 应用服务集群阶段</h4><p><strong>常见场景：</strong>项目初期，用户访问有压力</p>
<p><strong>部署特点：</strong>应用服务所在主机做集群负载均衡 </p>
<p><strong>应用特点：</strong>业务中等</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%845.png" alt="应用服务集群阶段"></p>
<h4 id="1-2-2-数据库读写分离化"><a href="#1-2-2-数据库读写分离化" class="headerlink" title="1.2.2 数据库读写分离化"></a>1.2.2 数据库读写分离化</h4><p><strong>常见场景：</strong>项目初期，用户访问数据有压力</p>
<p><strong>部署特点：</strong>对数据库集群做读写分离，静态文件做共享存储</p>
<p><strong>应用特点：</strong>业务中等</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%846.png" alt="数据库读写分离化"></p>
<h4 id="1-2-3-存储分布式"><a href="#1-2-3-存储分布式" class="headerlink" title="1.2.3 存储分布式"></a>1.2.3 存储分布式</h4><p><strong>常见场景：</strong>项目中期，数据存储有压力</p>
<p><strong>部署特点：</strong>对数据库分库/分表扩展，数据文件使用分布式存储</p>
<p><strong>应用特点：</strong>业务中等</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%847.png" alt="存储分布式"></p>
<h4 id="1-2-4-业务应用拆分"><a href="#1-2-4-业务应用拆分" class="headerlink" title="1.2.4 业务应用拆分"></a>1.2.4 业务应用拆分</h4><p><strong>常见场景：</strong>项目中期，业务访问/团队管理有压力</p>
<p><strong>部署特点：</strong>项目应用进行拆分</p>
<p><strong>应用特点：</strong>业务复杂</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%848.png" alt="业务应用拆分"></p>
<h3 id="1-3-中后期阶段"><a href="#1-3-中后期阶段" class="headerlink" title="1.3 中后期阶段"></a>1.3 中后期阶段</h3><h4 id="1-3-1-业务拆分"><a href="#1-3-1-业务拆分" class="headerlink" title="1.3.1 业务拆分"></a>1.3.1 业务拆分</h4><p><strong>常见场景：</strong>项目中后期，业务处理有压力</p>
<p><strong>部署特点：</strong>所有功能以服务形式单独部署，引入配置管理管理中心、消息中间件，搜索引擎等功能</p>
<p><strong>应用特点：</strong>业务复杂</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%849.png" alt="业务拆分"></p>
<h3 id="1-4-后期阶段"><a href="#1-4-后期阶段" class="headerlink" title="1.4 后期阶段"></a>1.4 后期阶段</h3><h4 id="1-4-1-微服务阶段"><a href="#1-4-1-微服务阶段" class="headerlink" title="1.4.1 微服务阶段"></a>1.4.1 微服务阶段</h4><p><strong>常见场景：</strong>项目后期，精益求精</p>
<p><strong>部署特点：</strong>所有业务都可以自由部署</p>
<p><strong>应用特点：</strong>业务复杂</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%8410.png" alt="微服务阶段"></p>
<h2 id="二、架构部署"><a href="#二、架构部署" class="headerlink" title="二、架构部署"></a>二、架构部署</h2><h3 id="2-1通用架构"><a href="#2-1通用架构" class="headerlink" title="2.1通用架构"></a>2.1通用架构</h3><p><strong>一级定位：</strong>核心组成部分 （web 、数据库、存储层 ）</p>
<p><strong>二级定位：</strong>功能增强部分 （web缓存、代理、数据库缓存）</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%8411.png" alt="通用架构"></p>
<h3 id="2-2部署项目"><a href="#2-2部署项目" class="headerlink" title="2.2部署项目"></a>2.2部署项目</h3><p>部署项目的时候，要遵循主次原则：</p>
<p>1.对于架构层中的一级角色，我们的<strong>部署原则</strong>是：站在用户访问资源角度，从后向前依次部署。 </p>
<p>2.对于架构层中的二级角色，我们的<strong>部署原则</strong>是：站在用户访问资源压力角度，需要部署哪里，就部署哪里，注意前后的信息交流。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>docker的一些小知识</title>
    <url>/2020/01/29/docker%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>今天玩游戏的时候，突然想到了以前面试被问的一个小问题，特此记录，仅供参考</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-关于docker故障排除"><a href="#1-关于docker故障排除" class="headerlink" title="1.关于docker故障排除"></a>1.关于docker故障排除</h2><p>很久之前在 <code>XX航空</code> 的面试中，面试官曾问过一个问题，大体情况如下（具体描述因为时间关系已经记不清了）：</p>
<p><strong>面试官：当一个容器发生故障导致无法连接</strong>，你会如何操作？</p>
<h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><p><strong>傻小闫：</strong>重启 <code>docker服务</code> 或 <code>容器</code> ？？？</p>
<p><strong>面试官：</strong>说一下重启命令</p>
<p><strong>傻小闫：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启 docker</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启某容器</span></span><br><span class="line">docker restart 容器id或者容器name</span><br></pre></td></tr></table></figure>

<p><strong>面试官：</strong>如果 <code>docker</code> 命令不是通过 <code>systemctl</code> 管理的，怎么办？如果执行重启命令之后仍然无法重启呢？</p>
<p><strong>傻小闫：</strong>无论 <code>docker</code> 怎样进行安装，都会有相关重启命令吧？要是重启一次不管用，那就多重启两次！常言道：没有什么是重启解决不了的问题，如果有，就重启两次～</p>
<p><strong>面试官：</strong>傻小闫，<code>out</code>！</p>
<h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><p><strong>傻小闫：</strong>我会先查看 <code>docker</code> 的 <code>启停状态</code>，然后再排查该容器的相关信息，比如查看该容器的启停状态，查看该容器的 <code>日志</code> 以及 <code>进程</code> 相关信息，最后根据具体情况进行具体分析作出对应相关操作。</p>
<p><strong>面试官：</strong>那么写一下查看 <code>docker</code> 的 <code>启停状态</code> 相关命令，还有查看容器的 <code>日志</code> 以及 <code>进程</code> 的相关命令吧。</p>
<p><strong>傻小闫：</strong>好的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<p>上述命令会显示服务的运行状态以及一些简单的运行信息。接下来是查看所有容器的启停状态命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p>然后是查看容器在 <code>stdout/stderr</code> 的日志相关命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs 容器id或者容器名称</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定容器最后100行日志</span></span><br><span class="line">docker logs --tail=100 容器id或者容器名称</span><br></pre></td></tr></table></figure>

<p>如果容器运行正常，可以查看指定容器中运行的进程信息，进一步判断原因：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker top 容器id或者容器名称</span><br></pre></td></tr></table></figure>

<p>另外还有一个查看容器性能监控的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stats 容器id或者容器名称</span><br></pre></td></tr></table></figure>

<p>对了，最后再说一个查看容器配置信息和运行时状态的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id或者容器名称</span><br></pre></td></tr></table></figure>

<p><strong>面试官微微点头，进行下一轮的问题轰炸…</strong></p>
<h2 id="2-关于docker网络"><a href="#2-关于docker网络" class="headerlink" title="2.关于docker网络"></a>2.关于docker网络</h2><p>docker 中容器如何与外界进行通讯？当然是配置网络了，下面是最常用的一行命令，指定映射：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p [宿主机ip]:[宿主机端口]:[容器端口] --name [容器名字] [镜像名称]</span><br></pre></td></tr></table></figure>

<p>该命令会根据指定镜像创建一个容器，并指定容器的名称、宿主机映射到容器的地址和端口、容器对外绑定的端口。创建完成之后，宿主机就可以通过刚才宿主机指定的地址和端口访问容器指定的服务了（比如容器是一个 <code>nginx</code> ，我们将宿主机的 <code>192.168.0.33:1314</code> 映射到容器的 80 端口，宿主机访问 <code>192.168.0.33:1314</code> 即可访问 <code>nginx</code> 服务）。</p>
<blockquote>
<p>端口的范围：0 ～ 65535</p>
</blockquote>
<h3 id="2-1-网桥"><a href="#2-1-网桥" class="headerlink" title="2.1 网桥"></a>2.1 网桥</h3><p>宿主机与 <code>docker</code> 某容器之间可以进行通讯之后，那么容器之间该如何通讯呢？</p>
<p>1.仍然可以通过上面提到的方式，使用宿主机的地址和端口进行访问。但是这样做有一个弊端，那就是只能访问容器暴露出的端口所提供的服务，十分有限。（<strong>推荐指数：2颗星</strong>）</p>
<p>2.可以使用容器的 <code>ip</code> 进行访问，但是每次重启容器之后，地址的变化该如何是好？（<strong>推荐指数：1颗星</strong>）</p>
<p>3.通过 <code>link</code> 建立连接。首先这种方式官方不推荐，所以也没有选择的必要，大家简单了解即可。我们需要有一个容器A（其他容器想要访问该容器），有一个容器B（该容器要去访问容器A），容器B在创建（启动）时需要使用参数 <code>--link</code> 进行设置。然后进入容器B，直接通过参数 <code>link</code> 指定的名字去访问容器A即可。<strong>注意一点：不可反向操作！</strong>即容器A无法 <code>ping</code> 通容器B。（<strong>推荐指数：1颗星</strong>）</p>
<blockquote>
<p>而且此操作如果希望容器A重启后，容器B的链接仍然生效，还需要额外操作，修改配置文件，十分繁琐，不推荐。</p>
</blockquote>
<p>上述的手段都不推荐，那么直接引出今日主角登场『<strong>桥接网络</strong>』（<strong>推荐指数：5颗星</strong>）</p>
<p>首先需要创建一个网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create 网络名称</span><br></pre></td></tr></table></figure>

<p>然后在启动容器时，使其加入网络中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --network 创建的网络名称 其他参数设置 镜像名称 ...</span><br></pre></td></tr></table></figure>

<p>我们简单来看一下官方提供了其他的什么参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --help</span><br><span class="line">      ...</span><br><span class="line">      --network network                Connect a container to a network</span><br><span class="line">      --network-alias list             Add network-scoped alias for the container</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<p>可以看到有两个参数，按照官方描述，一个参数负责将容器链接到给定的网桥上，一个参数是为该容器添加一个网络访问的别名。</p>
<p><strong>将需要通讯的容器在创建（启动容器）时，通过参数设置都添加到同一网络桥接上即可完成容器之间的通讯。</strong></p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2020/01/27/%E5%9B%BE/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
此图非彼图，今天来学习一种十分重要，在生活中也经常使用的数据结构「图」

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="一、图"><a href="#一、图" class="headerlink" title="一、图"></a>一、图</h2><p>图就是由一些点与边组成，点之间是边，边两头有点，类似于我们所画的思维导图。根据点之间连接的边是否有具体指向区分为『有向图』和『无向图』。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9C%89%E5%90%91%E5%9B%BE.png" alt="图"></p>
<p>图可以做什么呢？它可以解决最经典的问题『寻找最短路径』。类似于地图，如想知道从别墅到公司走哪条路最短，可以通过图来建立模型，将十字路口（三叉路口等连接几条路的路口）看作是点，每条路就是边，别墅是起点，公司是终点。</p>
<p>上面只完成了第一步，有了图之后，该如何寻找最短路径呢？下面就需要再介绍一种图算法『广度优先搜索』</p>
<h2 id="二、广度优先搜索算法"><a href="#二、广度优先搜索算法" class="headerlink" title="二、广度优先搜索算法"></a>二、广度优先搜索算法</h2><p><strong>广度优先搜索算法</strong>可以通过一个例子进行描述：小明想通过走动，帮助儿子进入县一中（当地最好的学校）。于是他开始回忆自己的朋友是否有县一中的领导或者认识其领导，思考之后发现并没有，然后让朋友询问朋友的朋友是否有关系。像这样，为了在社交网络中寻找到关系，先看自己（自己肯定不是，要不然直接安排了），然后将所有朋友加入到搜索名单中，看朋友中是否有关系，如果没有，再将朋友的朋友纳入范围继续寻找 …… 直到找到需要的人，这就是广度优先搜索算法。</p>
<blockquote>
<p>因为同朋友的亲密度比同朋友的朋友之间的亲密度要高，所以先从朋友之间寻找。如果将朋友比做是第一层关系，朋友的朋友为第二层，这样一层一层下去的就是广度优先搜索。如果找到一个朋友，就寻找他的朋友中是否有这样的人，如此以深度挖掘的方式搜索下去，就是深度优先搜索。</p>
</blockquote>
<p>它常用于寻找两地点或者两样物体之间的最短距离。总结为下面两种问题：</p>
<ul>
<li>从一点可以到另一点吗？</li>
<li>从一点到另一点哪条路径最短？</li>
</ul>
<p>现实生活中的例子有：</p>
<ul>
<li>各种智能机器，比如跳棋最少走几步可以获胜</li>
<li>到目的地的最短路线</li>
</ul>
<p>在搜索的过程中，大家可能注意到，先检查朋友，后检查朋友的朋友，是有顺序的，那么如何保持顺序呢？那就需要使用到另外一种数据结构『队列』</p>
<h2 id="三、队列"><a href="#三、队列" class="headerlink" title="三、队列"></a>三、队列</h2><p>队列很简单，和生活中的排队一样，比如购票，结账时，先排队的人先买到票或者结账完成。就是有顺序，先进先出（<code>First In First Out</code>）的一种数据结构，它只有两种行为，入队和出队。类比生活中排队，有素质的人不能出现插队吧？</p>
<blockquote>
<p>队列常常与栈进行对比，栈是一种先进后出的数据结构，或描述为后进先出（<code>Last In First Out</code>）</p>
<p>深度优先搜索就常使用栈。</p>
</blockquote>
<h2 id="四、实现图"><a href="#四、实现图" class="headerlink" title="四、实现图"></a>四、实现图</h2><p>代码如何实现图呢？首先图由多个节点构成，每个节点与邻近节点相连，要表示这种关系，可以联想到『散列表』，其映射关系可以将键映射到一个值或多个值。在 <code>Python</code> 中则使用字典表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">"小明"</span>] = [<span class="string">"小花"</span>, <span class="string">"小玉"</span>, ...]</span><br><span class="line">graph[<span class="string">"小玉"</span>] = [<span class="string">"小帆"</span>, ...]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>散列表是无序的</p>
</blockquote>
<h2 id="五、实现图算法"><a href="#五、实现图算法" class="headerlink" title="五、实现图算法"></a>五、实现图算法</h2><p>还是沿用小明为儿子学校找关系的示例，实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该字典表示图，其中将小明与朋友，小明朋友与朋友的朋友之间的关系</span></span><br><span class="line">graph = &#123;......&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person_is_seller</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># 具体判断过程省略，该函数返回 true 或 false，即是或者不是</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个队列</span></span><br><span class="line">    search_queue = deque() </span><br><span class="line">    <span class="comment"># 为队列中不断添加朋友或者朋友的朋友，即要搜索的人</span></span><br><span class="line">    search_queue += graph[name] </span><br><span class="line">    <span class="comment"># 这个列表用于记录检查过的人</span></span><br><span class="line">    searched = []</span><br><span class="line">    <span class="comment"># 只要队列不为空就一直搜索下去</span></span><br><span class="line">    <span class="keyword">while</span> search_queue:</span><br><span class="line">        <span class="comment"># 取出队列中左面第一个人</span></span><br><span class="line">        person = search_queue.popleft() </span><br><span class="line">        <span class="comment"># 仅当这个人没检查过时才检查</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> person <span class="keyword">in</span> searched:</span><br><span class="line">            <span class="comment"># 看这个人是否是小明需要找的关系</span></span><br><span class="line">            <span class="keyword">if</span> person_is_seller(person):</span><br><span class="line">              	<span class="comment"># 是的话输出是要找的关系</span></span><br><span class="line">                print(person + <span class="string">" is the one you are looking for!"</span>)</span><br><span class="line">                <span class="comment"># 结束循环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              	<span class="comment"># 把这个人的朋友添加到队列中</span></span><br><span class="line">              	search_queue += graph[person] </span><br><span class="line">                <span class="comment"># 将这个人标记为检查过</span></span><br><span class="line">                searched.append(person)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">search(<span class="string">"小明"</span>)</span><br></pre></td></tr></table></figure>



<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习工程师必知的十大算法</title>
    <url>/2020/01/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E7%9F%A5%E7%9A%84%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>It is no doubt that the sub-field of machine learning / artificial intelligence has increasingly gained more popularity in the past couple of years. As Big Data is the hottest trend in the tech industry at the moment, machine learning is incredibly powerful to make predictions or calculated suggestions based on large amounts of data. Some of the most common examples of machine learning are Netflix’s algorithms to make movie suggestions based on movies you have watched in the past or Amazon’s algorithms that recommend books based on books you have bought before.</p>
<p>毫无疑问，机器学习 / 人工智能的子领域在过去几年越来越受欢迎。目前大数据在科技行业已经炙手可热，而基于大量数据来进行预测或者得出建议的机器学习无疑是非常强大的。一些最常见的机器学习例子，比如 Netflix 的算法可以根据你以前看过的电影来进行电影推荐，而 Amazon 的算法则可以根据你以前买过的书来推荐书籍。</p>
<p>So if you want to learn more about machine learning, how do you start?</p>
<p>所以如果你想了解更多有关机器学习的内容，那么你该如何入门？</p>
<a id="more"></a>

<blockquote>
<p>本文由 James Le 所写的英文文章 The 10 Algorithms Machine Learning Engineers Need to Know 翻译而来</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
</blockquote>
<p>For me, my first introduction is when I took an Artificial Intelligence class when I was studying abroad in Copenhagen. My lecturer is a full-time Applied Math and CS professor at the Technical University of Denmark, in which his research areas are logic and artificial, focusing primarily on the use of logic to model human-like planning, reasoning and problem solving. The class was a mix of discussion of theory/core concepts and hands-on problem solving. The textbook that we used is one of the AI classics: <a href="https://www.amazon.com/Artificial-Intelligence-Modern-Approach-3rd/dp/0136042597" target="_blank" rel="noopener">Peter Norvig’s <em>Artificial Intelligence — A Modern Approach</em></a>, in which we covered major topics including intelligent agents, problem-solving by searching, adversarial search, probability theory, multi-agent systems, social AI, philosophy/ethics/future of AI. At the end of the class, in a team of 3, we implemented simple search-based agents solving transportation tasks in a virtual environment as a programming project.</p>
<p>对于我来说，我的入门课程是我在哥本哈根出国留学时参加的人工智能课。当时我的讲师是丹麦技术大学（Technical University of Denmark）的应用数学和计算机科学的全职教授，他的研究方向是逻辑与人工智能，侧重于使用逻辑学来对人性化的规划、推理和解决问题进行建模。这个课程包括对理论 / 核心概念的讨论和自己动手解决问题。我们使用的教材是 AI 经典之一：Peter Norvig 的 Artificial Intelligence—A Modern Approach（中文译本：<a href="https://book.douban.com/subject/6730363/" target="_blank" rel="noopener">《人工智能：一种现代的方法》</a>），这本书主要讲了智能体、搜索解决问题、对抗搜索、概率论、多智能体系统、社会AI 和AI 的哲学/ 伦理/ 未来等等。在课程结束时，我们三个人的团队实现了一个简单的编程项目，也就是基于搜索的智能体解决虚拟环境中的运输任务问题。</p>
<p>I have learned a tremendous amount of knowledge thanks to that class, and decided to keep learning about this specialized topic. In the last few weeks, I have been multiple tech talks in San Francisco on deep learning, neural networks, data architecture — and a Machine Learning conference with a lot of well-known professionals in the field. Most importantly, I enrolled in Udacity’s <a href="https://www.udacity.com/course/intro-to-machine-learning--ud120" target="_blank" rel="noopener"><em>Intro to Machine Learning</em></a> online course in the beginning of June and has just finished it a few days ago. In this post, I want to share some of the most common machine learning algorithms that I learned from the course.</p>
<p>在那门课程上我已经学到了很多知识，并决定继续学习相关的课题。在过去的几个星期里，我在旧金山参加了多次相关的技术讲座，涉及到深度学习、神经网络和数据结构，并且参加了一个有很多该领域的知名专家学者参加的机器学习会议。最重要的是，我在 6 月初参加了 Udacity 上的<a href="https://cn.udacity.com/course/intro-to-machine-learning--ud120" target="_blank" rel="noopener"> Intro to Machine Learning（机器学习入门）</a>在线课程，前几天才完成。在这篇文章中，我想分享一下我从课程中学到的一些最常用的机器学习算法。</p>
<p>Machine learning algorithms can be divided into 3 broad categories — supervised learning, unsupervised learning, and reinforcement learning.Supervised learning is useful in cases where a property (<em>label</em>) is available for a certain dataset (<em>training set</em>), but is missing and needs to be predicted for other instances. Unsupervised learning is useful in cases where the challenge is to discover implicit relationships in a given <em>unlabeled</em> dataset (items are not pre-assigned). Reinforcement learning falls between these 2 extremes — there is some form of feedback available for each predictive step or action, but no precise label or error message. Since this is an intro class, I didn’t learn about reinforcement learning, but I hope that 10 algorithms on supervised and unsupervised learning will be enough to keep you interested.</p>
<p>机器学习算法可以分为三大类：监督学习、无监督学习和强化学习。监督学习可用于一个特定的数据集（训练集）具有某一属性（标签），但是其他数据没有标签或者需要预测标签的情况。无监督学习可用于给定的没有标签的数据集（数据不是预分配好的），目的就是要找出数据间的潜在关系。强化学习位于这两者之间，每次预测都有一定形式的反馈，但是没有精确的标签或者错误信息。因为这是一个介绍课程，我没有学习过强化学习的相关内容，但是我希望以下 10 个关于监督学习和无监督学习的算法足以让你感兴趣。</p>
<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><h3 id="1-决策树（Decision-Trees）"><a href="#1-决策树（Decision-Trees）" class="headerlink" title="1. 决策树（Decision Trees）"></a>1. 决策树（Decision Trees）</h3><p>A decision tree is a decision support tool that uses a tree-like graph or model of decisions and their possible consequences, including chance-event outcomes, resource costs, and utility. Take a look at the image to get a sense of how it looks like.</p>
<p>决策树是一个决策支持工具，它使用树形图或者决策模型以及可能性序列，包括偶然事件的结果、资源成本和效用。下图是其基本原理：</p>
<p><img src="https://static001.infoq.cn/resource/image/03/2f/03196b63116045238bd90168de7fa02f.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>From a business decision point of view, a decision tree is the minimum number of yes/no questions that one has to ask, to assess the probability of making a correct decision, most of the time. As a method, it allows you to approach the problem in a structured and systematic way to arrive at a logical conclusion.</p>
<p>从业务决策的角度来看，决策树是人们必须了解的最少的是 / 否问题，这样才能评估大多数时候做出正确决策的概率。作为一种方法，它允许你以结构化和系统化的方式来解决问题，从而得出合乎逻辑的结论。</p>
<h3 id="2-朴素贝叶斯分类-Naive-Bayesian-classification"><a href="#2-朴素贝叶斯分类-Naive-Bayesian-classification" class="headerlink" title="2. 朴素贝叶斯分类 (Naive Bayesian classification)"></a>2. 朴素贝叶斯分类 (Naive Bayesian classification)</h3><p>Naive Bayes classifiers are a family of simple probabilistic classifiers based on applying Bayes’ theorem with strong (naive) independence assumptions between the features. The featured image is the equation — with P(A|B) is posterior probability, P(B|A) is likelihood, P(A) is class prior probability, and P(B) is predictor prior probability.</p>
<p>朴素贝叶斯分类器是一类简单的概率分类器，它基于贝叶斯定理和特征间的强大的（朴素的）独立假设。图中是贝叶斯公式，其中 P（A|B）是后验概率，P（B|A）是似然，P（A）是类先验概率，P（B）是预测先验概率。</p>
<p><img src="https://static001.infoq.cn/resource/image/02/82/02afc9957795347a9529a71b0df68082.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>Some of real world examples are:</p>
<ul>
<li>To mark an email as spam or not spam</li>
<li>Classify a news article about technology, politics, or sports</li>
<li>Check a piece of text expressing positive emotions, or negative emotions?</li>
<li>Used for face recognition software.</li>
</ul>
<p>一些应用例子:</p>
<ul>
<li>判断垃圾邮件</li>
<li>对新闻的类别进行分类，比如科技、政治、运动</li>
<li>判断文本表达的感情是积极的还是消极的</li>
<li>人脸识别</li>
</ul>
<h3 id="3-最小二乘法（Ordinary-Least-Squares-Regression）"><a href="#3-最小二乘法（Ordinary-Least-Squares-Regression）" class="headerlink" title="3. 最小二乘法（Ordinary Least Squares Regression）"></a>3. 最小二乘法（Ordinary Least Squares Regression）</h3><p>If you know statistics, you probably have heard of linear regression before. Least squares is a method for performing linear regression. You can think of linear regression as the task of fitting a straight line through a set of points. There are multiple possible strategies to do this, and “ordinary least squares” strategy go like this — You can draw a line, and then for each of the data points, measure the vertical distance between the point and the line, and add these up; the fitted line would be the one where this sum of distances is as small as possible.</p>
<p>如果你懂统计学的话，你可能以前听说过线性回归。最小二乘法是一种计算线性回归的方法。你可以将线性回归看做通过一组点来拟合一条直线。实现这个有很多种方法，“最小二乘法”就像这样：你可以画一条直线，然后对于每一个数据点，计算每个点到直线的垂直距离，然后把它们加起来，那么最后得到的拟合直线就是距离和尽可能小的直线。</p>
<p><img src="https://static001.infoq.cn/resource/image/52/dc/528f69da2ec5c98287f968aa8c1d31dc.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>Linear refers the kind of model you are using to fit the data, while least squares refers to the kind of error metric you are minimizing over.</p>
<p>线性指的是你用来拟合数据的模型，而最小二乘法指的是你最小化的误差度量。</p>
<h3 id="4-逻辑回归-Logistic-Regression"><a href="#4-逻辑回归-Logistic-Regression" class="headerlink" title="4. 逻辑回归 (Logistic Regression)"></a>4. 逻辑回归 (Logistic Regression)</h3><p>Logistic regression is a powerful statistical way of modeling a binomial outcome with one or more explanatory variables. It measures the relationship between the categorical dependent variable and one or more independent variables by estimating probabilities using a logistic function, which is the cumulative logistic distribution.</p>
<p>逻辑回归是一个强大的统计学方法，它可以用一个或多个解释变量来表示一个二项式结果。它通过使用逻辑函数来估计概率，从而衡量类别依赖变量和一个或多个独立变量之间的关系，后者服从累计逻辑分布。</p>
<p><img src="https://static001.infoq.cn/resource/image/f5/6c/f559c1b4f5a61b579b0c9e906a439f6c.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>In general, regressions can be used in real-world applications such as:</p>
<ul>
<li>Credit Scoring</li>
<li>Measuring the success rates of marketing campaigns</li>
<li>Predicting the revenues of a certain product</li>
<li>Is there going to be an earthquake on a particular day?</li>
</ul>
<p>总的来说，逻辑回归可以用于以下几个真实应用场景：</p>
<ul>
<li>信用评分</li>
<li>计算营销活动的成功率</li>
<li>预测某个产品的收入</li>
<li>特定的某一天是否会发生地震</li>
</ul>
<h3 id="5-支持向量机（Support-Vector-Machine，SVM）"><a href="#5-支持向量机（Support-Vector-Machine，SVM）" class="headerlink" title="5. 支持向量机（Support Vector Machine，SVM）"></a>5. 支持向量机（Support Vector Machine，SVM）</h3><p>SVM is binary classification algorithm. Given a set of points of 2 types in N dimensional place, SVM generates a (N — 1) dimensional hyperplane to separate those points into 2 groups. Say you have some points of 2 types in a paper which are linearly separable. SVM will find a straight line which separates those points into 2 types and situated as far as possible from all those points.</p>
<p>SVM 是二进制分类算法。给定 N 维坐标下两种类型的点，SVM 生成（N-1）维的超平面来将这些点分成两组。假设你在平面上有两种类型的可以线性分离的点，SVM 将找到一条直线，将这些点分成两种类型，并且这条直线尽可能远离所有这些点。</p>
<p><img src="https://static001.infoq.cn/resource/image/b8/7d/b82961e4171788ac7433c4b4e219327d.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>In terms of scale, some of the biggest problems that have been solved using SVMs (with suitably modified implementations) are display advertising, human splice site recognition, image-based gender detection, large-scale image classification…</p>
<p>从规模上看，使用 SVM（经过适当的修改）解决的一些最大的问题包括显示广告、人类剪切位点识别（human splice site recognition）、基于图像的性别检测，大规模图像分类……</p>
<h3 id="6-集成方法（Ensemble-methods）"><a href="#6-集成方法（Ensemble-methods）" class="headerlink" title="6. 集成方法（Ensemble methods）"></a>6. 集成方法（Ensemble methods）</h3><p>Ensemble methods are learning algorithms that construct a set of classifiers and then classify new data points by taking a weighted vote of their predictions. The original ensemble method is Bayesian averaging, but more recent algorithms include error-correcting output coding, bagging, and boosting.</p>
<p>集成方法是学习算法，它通过构建一组分类器，然后通过它们的预测结果进行加权投票来对新的数据点进行分类。原始的集成方法是贝叶斯平均，但是最近的算法包括纠错输出编码、Bagging 和 Boosting。</p>
<p><img src="https://static001.infoq.cn/resource/image/3f/30/3f398562a900001e21e141085b286530.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>So how do ensemble methods work and why are they superior to individual models?</p>
<ul>
<li>They average out biases: If you average a bunch of democratic-leaning polls and republican-leaning polls together, you will get an average something that isn’t leaning either way.</li>
<li>They reduce the variance: The aggregate opinion of a bunch of models is less noisy than the single opinion of one of the models. In finance, this is called diversification — a mixed portfolio of many stocks will be much less variable than just one of the stocks alone. This is why your models will be better with more data points rather than fewer.</li>
<li>They are unlikely to over-fit: If you have individual models that didn’t over-fit, and you are combining the predictions from each model in a simple way (average, weighted average, logistic regression), then there’s no room for over-fitting.</li>
</ul>
<p>那么集成方法如何工作？并且为什么它们要优于单个模型？</p>
<ul>
<li>它们平均了单个模型的偏差：如果你将民主党的民意调查和共和党的民意调查在一起平均化，那么你将得到一个均衡的结果，不偏向任何一方。</li>
<li>它们减少了方差：一组模型的总体意见比其中任何一个模型的单一意见更加统一。在金融领域，这就是所谓的多元化，有许多股票的组合比一个单独的股票的不确定性更少，这也为什么你的模型在数据多的情况下会更好的原因。</li>
<li>它们不太可能过拟合：如果你有单个的模型没有过拟合，那么把这些模型的预测简单结合起来（平均、加权平均、逻辑回归），那么最后得到的模型也不会过拟合。</li>
</ul>
<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><h3 id="7-聚类算法（Clustering-Algorithms）"><a href="#7-聚类算法（Clustering-Algorithms）" class="headerlink" title="7. 聚类算法（Clustering Algorithms）"></a>7. 聚类算法（Clustering Algorithms）</h3><p>Clustering is the task of grouping a set of objects such that objects in the same group (<em>cluster</em>) are more similar to each other than to those in other groups.</p>
<p>聚类是将一系列对象分组的任务，目标是使相同组（集群）中的对象之间比其他组的对象更相似。</p>
<p><img src="https://static001.infoq.cn/resource/image/f9/0a/f9262a91a2fdb75ef398a082dc71c00a.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>Every clustering algorithm is different, and here are a couple of them:</p>
<ul>
<li>Centroid-based algorithms</li>
<li>Connectivity-based algorithms</li>
<li>Density-based algorithms</li>
<li>Probabilistic</li>
<li>Dimensionality Reduction</li>
<li>Neural networks / Deep Learning</li>
</ul>
<p>每一种聚类算法都不相同，下面是一些例子：</p>
<ul>
<li>基于质心的算法</li>
<li>基于连接的算法</li>
<li>基于密度的算法</li>
<li>概率</li>
<li>降维</li>
<li>神经网络 / 深度学习</li>
</ul>
<h3 id="8-主成分分析（Principal-Component-Analysis，PCA）"><a href="#8-主成分分析（Principal-Component-Analysis，PCA）" class="headerlink" title="8. 主成分分析（Principal Component Analysis，PCA）"></a>8. 主成分分析（Principal Component Analysis，PCA）</h3><p>PCA is a statistical procedure that uses an orthogonal transformation to convert a set of observations of possibly correlated variables into a set of values of linearly uncorrelated variables called principal components.</p>
<p>PCA 是一个统计学过程，它通过使用正交变换将一组可能存在相关性的变量的观测值转换为一组线性不相关的变量的值，转换后的变量就是所谓的主分量。</p>
<p><img src="https://static001.infoq.cn/resource/image/9e/92/9ec810f0a300d725e7226750e8d09e92.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>Some of the applications of PCA include compression, simplifying data for easier learning, visualization. Notice that domain knowledge is very important while choosing whether to go forward with PCA or not. It is not suitable in cases where data is noisy (all the components of PCA have quite a high variance).</p>
<p>PCA 的一些应用包括压缩、简化数据便于学习、可视化等。请注意，领域知识在选择是否继续使用 PCA 时非常重要。 数据嘈杂的情况（PCA 的所有成分具有很高的方差）并不适用。</p>
<h3 id="9-奇异值分解（Singular-Value-Decomposition，SVD）"><a href="#9-奇异值分解（Singular-Value-Decomposition，SVD）" class="headerlink" title="9. 奇异值分解（Singular Value Decomposition，SVD）"></a>9. 奇异值分解（Singular Value Decomposition，SVD）</h3><p>In linear algebra, SVD is a factorization of a real complex matrix. For a given <em>m \</em> n* matrix M, there exists a decomposition such that M = UΣV, where U and V are unitary matrices and Σ is a diagonal matrix.</p>
<p>在线性代数中，SVD 是复杂矩阵的因式分解。对于给定的 m * n 矩阵 M，存在分解使得 M=UΣV，其中 U 和 V 是酉矩阵，Σ是对角矩阵。</p>
<p><img src="https://static001.infoq.cn/resource/image/a2/f8/a254a50da32558e12f4c170a32ecdcf8.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>PCA is actually a simple application of SVD. In computer vision, the 1st face recognition algorithms used PCA and SVD in order to represent faces as a linear combination of “eigenfaces”, do dimensionality reduction, and then match faces to identities via simple methods; although modern methods are much more sophisticated, many still depend on similar techniques.</p>
<p>实际上，PCA 是 SVD 的一个简单应用。在计算机视觉中，第一个人脸识别算法使用 PCA 和 SVD 来将面部表示为“特征面”的线性组合，进行降维，然后通过简单的方法将面部匹配到身份，虽然现代方法更复杂，但很多方面仍然依赖于类似的技术。</p>
<h3 id="10-独立成分分析（Independent-Component-Analysis，ICA）"><a href="#10-独立成分分析（Independent-Component-Analysis，ICA）" class="headerlink" title="10. 独立成分分析（Independent Component Analysis，ICA）"></a>10. 独立成分分析（Independent Component Analysis，ICA）</h3><p>ICA is a statistical technique for revealing hidden factors that underlie sets of random variables, measurements, or signals. ICA defines a generative model for the observed multivariate data, which is typically given as a large database of samples. In the model, the data variables are assumed to be linear mixtures of some unknown latent variables, and the mixing system is also unknown. The latent variables are assumed non-gaussian and mutually independent, and they are called independent components of the observed data.</p>
<p>ICA 是一种统计技术，主要用于揭示随机变量、测量值或信号集中的隐藏因素。ICA 对观测到的多变量数据定义了一个生成模型，这通常是作为样本的一个大的数据库。在模型中，假设数据变量由一些未知的潜在变量线性混合，混合方式也是未知的。潜在变量被假定为非高斯分布并且相互独立，它们被称为观测数据的独立分量。</p>
<p><img src="https://static001.infoq.cn/resource/image/00/a1/007e627062309d6f80e25e1f935d11a1.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>ICA is related to PCA, but it is a much more powerful technique that is capable of finding the underlying factors of sources when these classic methods fail completely. Its applications include digital images, document databases, economic indicators and psychometric measurements.</p>
<p>ICA 与 PCA 有关，但是当这些经典方法完全失效时，它是一种更强大的技术，能够找出源的潜在因素。 其应用包括数字图像、文档数据库、经济指标和心理测量。</p>
<p>Now go forth and wield your understanding of algorithms to create machine learning applications that make better experiences for people everywhere.</p>
<p>现在运用你对这些算法的理解去创造机器学习应用，为世界各地的人们带来更好的体验吧。</p>
<blockquote>
<p>本文译者：尚剑</p>
<p>本文编辑：闫玉良</p>
<p>中文地址：<a href="https://www.infoq.cn/article/10-algorithms-machine-learning-engineers-need-to-know/" target="_blank" rel="noopener">https://www.infoq.cn/article/10-algorithms-machine-learning-engineers-need-to-know/</a></p>
<p><strong>查看英文原文：<a href="http://www.kdnuggets.com/2016/08/10-algorithms-machine-learning-engineers.html/2" target="_blank" rel="noopener"> The 10 Algorithms Machine Learning Engineers Need to Know</a></strong></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>如果你是mac用户，这个问题不信你没遇到！</title>
    <url>/2020/01/07/%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%98%AFmac%E7%94%A8%E6%88%B7%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E4%B8%8D%E4%BF%A1%E4%BD%A0%E6%B2%A1%E9%81%87%E5%88%B0%EF%BC%81/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 

<p>Mac 用户在使用 python 的虚拟环境时，你现在或者将来一定会遇到此问题，早发现早治疗 ～</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>在虚拟环境中执行 <code>python</code> 等相关命令时，报如下所示错误：</p>
<img src="https://github.com/EthanYan6/pic/raw/master/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%8A%A5%E9%94%99-2.png" alt="报错2" style="zoom:50%;">

<p>使用 <code>pip</code> 命令报错依旧：</p>
<img src="https://github.com/EthanYan6/pic/raw/master/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%8A%A5%E9%94%99-1.png" alt="报错1" style="zoom:50%;">

<p>是不是很诡异？</p>
<h3 id="2-原因分析"><a href="#2-原因分析" class="headerlink" title="2.原因分析"></a>2.原因分析</h3><p>出现上述问题，在查询过 <code>Google</code> 和 <code>stackoverflow</code> 等之后，发现了共性：都是使用 <code>MAC</code> 的用户，而且使用了  <code>brew</code> 包管理工具。</p>
<p>在执行 <code>brew update</code> 命令之后会升级所有管理的模块，比如 <code>Python</code> 。因此遇到 <code>Python</code> 有版本更新时，嘻嘻，恭喜你中奖了。</p>
<p><code>Mac</code> 在创建虚拟环境后，会发现文件夹下有一些链接文件，各种软链接其实指向了系统的 <code>Python</code> （节省空间所致），所以当你更新了 <code>Python</code> 之后，它所在的路径中包含的版本号也会更新，路径立即失效（软链接其实就保存的就是绝对路径），你的虚拟环境也就无法正常启动了。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h3 id="3-解决办法"><a href="#3-解决办法" class="headerlink" title="3.解决办法"></a>3.解决办法</h3><p>网上有一些解决办法，如下：</p>
<p>1.既然知道原因，那么重新修复这些软链接不就好了？于是，开始了 <code>删除创建</code> 之旅。</p>
<blockquote>
<p>我滴个乖乖！你知道哪个犄角旮旯里还藏着一个不怀好意的软链接嘛？然后网友提供了各种命令：</p>
<p><code>find ~/.virtualenvs/my-virtual-env/ -type l</code> 别闹了好吗？几十个文件，我怎么弄？放弃放弃，如果你愿意，那么请查看这篇帖子仔细研究即可：<a href="https://stackoverflow.com/questions/23233252/broken-references-in-virtualenvs" target="_blank" rel="noopener">https://stackoverflow.com/questions/23233252/broken-references-in-virtualenvs</a></p>
</blockquote>
<p>2.重新装系统</p>
<blockquote>
<p>这个。。。不至于吧，杀鸡焉用宰牛刀？既然知道问题，解决就好了嘛</p>
</blockquote>
<p>3.删除虚拟环境</p>
<blockquote>
<p>这个听起来不错，这也正是我想讲的方法。前提是你有 <code>requirements.txt</code> 文件，要不然还是麻烦点使用办法 1 吧。</p>
</blockquote>
<h3 id="4-实操"><a href="#4-实操" class="headerlink" title="4.实操"></a>4.实操</h3><p>删除重建虚拟环境即可，但如果这么简单，还用往下讲解吗？笑话！以后再出现，难不成还在删除吗？且听我的骚操作。</p>
<p>删除虚拟环境后，再创建时，请使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtualenv --no-site-packages --always-copy 虚拟环境名称 -p python3</span><br></pre></td></tr></table></figure>

<p>1.<code>--no-site-packages</code> ：创建虚拟环境时，不会安装系统环境中的任何模块（也就是创建一个全新的环境）</p>
<p>2.<code>-p python3</code> 指定创建的虚拟环境为 <code>python3.x</code> 版本</p>
<p>3.<code>--always-copy</code> 可以跟踪系统 <code>python</code> 信息，即使你升级了系统的 <code>python</code> ，虚拟环境仍然可以使用。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>python</tag>
        <tag>virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS这些情况你也遇到过</title>
    <url>/2019/12/22/CentOS%E8%BF%99%E4%BA%9B%E6%83%85%E5%86%B5%E4%BD%A0%E4%B9%9F%E9%81%87%E5%88%B0%E8%BF%87/</url>
    <content><![CDATA[<center>Author: 闫玉良</center>
CentOS 虚拟机许久未用，忘记密码如何是好？删掉再来又岂能甘心？想安装某个命令，直接 yum install 就可以了吗？远程连接服务器报错该怎样操作？

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-CentOS-无法登陆情况下修改密码"><a href="#1-CentOS-无法登陆情况下修改密码" class="headerlink" title="1.CentOS 无法登陆情况下修改密码"></a>1.CentOS 无法登陆情况下修改密码</h2><p><strong>背景：</strong>虚拟机忘记 <code>root</code> 密码，不知如何登陆</p>
<p><strong>环境：</strong><code>CentOS</code>，<code>root</code> 账户</p>
<p><strong>操作：</strong></p>
<p>1.开启虚拟机，在进入系统前选择项页面，按 <code>e</code> 键进入系统配置文件</p>
<p>2.向下移动光标，找到 <code>Linux16</code> 开头，大概意思如下的一句话：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Linux16 /vmlinuz-3.10.0xxxxxx.x86_64 root=UUID=xxxxxxxx ro  crashkernel=auto rhgb quiet LANG=zh_CN.UTF-8</span><br></pre></td></tr></table></figure>

<p>3.在该行的最后加空格，输入 <code>init=/bin/sh</code></p>
<p>4.接下来按 <code>Ctrl + x</code> 组合键进入单用户模式</p>
<blockquote>
<p>等待一会，会发现已经进入系统，只不过，命令行前缀变为类似 <code>sh-4.2#</code> 的效果</p>
</blockquote>
<p>5.输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -o remount,rw /</span><br></pre></td></tr></table></figure>

<p>6.之后输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>

<p>7.接下来就是修改 <code>root</code> 账号密码了</p>
<blockquote>
<p>重复输入一个不少于8位的密码（密码在输入时是不显示的，只需要正确输入并回车即可）</p>
</blockquote>
<p>8.出现 <code>successfully</code> 字样表示修改成功，但要生效还需继续操作</p>
<p>9.输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch /.autorelabel</span><br></pre></td></tr></table></figure>

<p>10.操作完毕，还有一步：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exec /sbin/init</span><br></pre></td></tr></table></figure>

<p>接下来就是等待系统重启（可能需要几分钟，需耐心等待，勿中途关机）</p>
<h2 id="2-安装命令小技巧"><a href="#2-安装命令小技巧" class="headerlink" title="2.安装命令小技巧"></a>2.安装命令小技巧</h2><p>安装命令，大家一定会想到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install xxx</span><br></pre></td></tr></table></figure>

<p>但并非所有命令都是如此。有些则处于某工具包中，需要下载其基础环境，那该如何操作？</p>
<p>只需执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum search xxx</span><br></pre></td></tr></table></figure>

<p>耐心等待几分钟，直到执行完毕。然后安装最后提示模块即可。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum search killall</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Loaded plugins: fastestmirror, security</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"></span><br><span class="line">base: mirrors.163.com</span><br><span class="line">extras: mirrors.aliyun.com</span><br><span class="line">*&gt; updates: mirrors.aliyun.com</span><br><span class="line">-----------------------------------Matched:killall-----------------------------------/</span><br><span class="line">psmisc.x86_64 : Utilities for managing processes on your system</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可看到 <code>killall</code> 命令处于 <code>psmisc.x86_64</code> 中</p>
</blockquote>
<p>然后输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install psmisc.x86_64</span><br></pre></td></tr></table></figure>

<h2 id="3-远程连接服务器"><a href="#3-远程连接服务器" class="headerlink" title="3.远程连接服务器"></a>3.远程连接服务器</h2><p><strong>背景：</strong>使用 <code>ssh</code> 连接服务器进行相关操作，报错</p>
<p><strong>环境：</strong>本地 <code>MacOS</code>，服务器 <code>CentOS</code></p>
<p><strong>操作：</strong></p>
<p>1.使用命令进行远程连接，然后报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❱ ssh root@192.168.xx.xx</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint for the ECDSA key sent by the remote host is</span><br><span class="line">SHA256:ZBm9L5432tibaN5+weK4h9NJzqrc76lvxOUkVvSLGac.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /Users/ethanyan/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending ECDSA key in /Users/ethanyan/.ssh/known_hosts:6</span><br><span class="line">ECDSA host key for 192.168.xx.xx has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure>

<p>2.使用如下命令进行解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -R 你要访问的IP地址</span><br></pre></td></tr></table></figure>

<p>3.最后再次使用命令进行连接发现连接成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh 用户@你要访问的ip地址</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue脚手架搭建项目中的坑</title>
    <url>/2019/12/15/Vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<center>Author:闫玉良</center>
Vue 框架如同 Python 中的 Django 框架一样，让一切操作变得超级简单，只需在规定的目录下书写规定的代码即可，至于如何运作，框架自己搞定。此篇文章仅用于记录 Vue 项目中的一些小坑。

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>我发现 <code>Vue</code> 这个框架真的超级严格，不按规定书写代码，就报错给你看！这与 <code>Python</code> 不同，在 <code>Python</code> 中大多数人都会遵循 <code>PEP8</code> ，但毕竟只是规范，除了一些中大型企业会去 <code>review</code> 代码，小型企业都是随缘，全凭编程人员习惯。</p>
<p>虽然动不动就报错，但是好在报错信息超级丰富，可快速定位，除了逻辑问题，其他问题均可快速定位解决。</p>
<h4 id="1-空行坑"><a href="#1-空行坑" class="headerlink" title="1.空行坑"></a>1.空行坑</h4><p>在 <code>Vue</code> 中，每个文件代码都<strong>必须</strong>以空行结尾！否则提醒你：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Newline required at end of file but not found</span><br><span class="line"><span class="meta">#</span><span class="bash"> 结尾未看到规定的空行</span></span><br></pre></td></tr></table></figure>

<p>注意，还只能是一行，要不然会提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Too many blank lines at the end of file. Max of 0 allowed</span><br><span class="line"><span class="meta">#</span><span class="bash"> 结尾的空行太多了，超出最大限制</span></span><br></pre></td></tr></table></figure>

<h4 id="2-字符串的坑"><a href="#2-字符串的坑" class="headerlink" title="2.字符串的坑"></a>2.字符串的坑</h4><p>在 <code>Python</code> 中字符串，可以是单引号、双引号，还可以是三引号。但如果在你的 <code>js</code> 文件中向这样写道：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"CopClass"</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'今晚吃什么'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它会提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">✘  http://eslint.org/docs/rules/quotes  Strings must use singlequote</span><br><span class="line">src/components/EnterPage.vue:13:9</span><br><span class="line">  name: "CopClass",</span><br></pre></td></tr></table></figure>

<p>瞧，告诉你字符串必须使用单引号，还指出了具体的位置。</p>
<h4 id="3-空格坑"><a href="#3-空格坑" class="headerlink" title="3.空格坑"></a>3.空格坑</h4><p>在 <code>data</code> 传递参数 <code>msg</code> 时，可要注意了，像下面的几种情况都会报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// first</span></span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'今晚吃什么'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// second</span></span><br><span class="line">  data ()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'今晚吃什么'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// third</span></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      msg: <span class="string">'今晚吃什么'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>都会及时告诉你某某处缺少空格，请核查。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>扶我起来,我还可以学～</title>
    <url>/2019/12/12/%E6%89%B6%E6%88%91%E8%B5%B7%E6%9D%A5-%E6%88%91%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%AD%A6%EF%BD%9E/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
长路漫漫，唯夜作伴。虽然一天的工作头昏脑胀，但是仍然放不下我心心念念的前端啊，扶我起来，我还可以学～

<p>学习喜欢的事情，也是一种放松，come on！</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>上篇文章讲了 Vue 的一些基础概念，语法。今天上些难度。</p>
<h2 id="1-实例生命周期"><a href="#1-实例生命周期" class="headerlink" title="1.实例生命周期"></a>1.实例生命周期</h2><p>如同人的生老病死，实力对象也有其本身的生命周期。当我们深入了解每一个阶段之后，才会在合适的阶段添加合适的功能。那么如何在合适的阶段完成所需需求呢？那就用到了<strong>生命周期钩子</strong>。类比 Flask 中的请求钩子，Django 中的中间件，不知这样说你是否更好理解。下面我们就来看看有哪些钩子：</p>
<h3 id="1-1-beforeCreate"><a href="#1-1-beforeCreate" class="headerlink" title="1.1 beforeCreate"></a>1.1 beforeCreate</h3><p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p>
<h3 id="1-2-created"><a href="#1-2-created" class="headerlink" title="1.2 created"></a>1.2 created</h3><p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始</p>
<h3 id="1-3-beforeMount"><a href="#1-3-beforeMount" class="headerlink" title="1.3 beforeMount"></a>1.3 beforeMount</h3><p>在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<h3 id="1-4-mounted"><a href="#1-4-mounted" class="headerlink" title="1.4 mounted"></a>1.4 mounted</h3><p>实例挂载到 dom 之后被调用，可以当成是 vue 对象的 ready 方法来使用，一般用它来做 dom 的初始化操作。</p>
<h3 id="1-5-beforeUpdate"><a href="#1-5-beforeUpdate" class="headerlink" title="1.5 beforeUpdate"></a>1.5 beforeUpdate</h3><p>数据发生变化前调用</p>
<h3 id="1-6-updated"><a href="#1-6-updated" class="headerlink" title="1.6 updated"></a>1.6 updated</h3><p>数据发生变化后调用</p>
<h3 id="1-7-beforeDestroy"><a href="#1-7-beforeDestroy" class="headerlink" title="1.7 beforeDestroy"></a>1.7 beforeDestroy</h3><p>挂载完毕，数据更新完成之后；解除绑定，销毁子组件以及事件监听器之前调用。</p>
<h3 id="1-8-destroyed"><a href="#1-8-destroyed" class="headerlink" title="1.8 destroyed"></a>1.8 destroyed</h3><p>销毁完毕之后调用。</p>
<h2 id="2-表单输入绑定"><a href="#2-表单输入绑定" class="headerlink" title="2.表单输入绑定"></a>2.表单输入绑定</h2><p>可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code> 及 <code>&lt;textarea&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素</p>
<h3 id="2-1单行文本框"><a href="#2-1单行文本框" class="headerlink" title="2.1单行文本框"></a>2.1单行文本框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-多行文本框"><a href="#2-2-多行文本框" class="headerlink" title="2.2 多行文本框"></a>2.2 多行文本框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Multiline message is:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"add multiple lines"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-复选框"><a href="#2-3-复选框" class="headerlink" title="2.3 复选框"></a>2.3 复选框</h3><p>单个复选框，绑定到布尔值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checked"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"checkbox"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>多个复选框，绑定到同一个数组：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'example-3'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"jack"</span> <span class="attr">value</span>=<span class="string">"Jack"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"jack"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"john"</span> <span class="attr">value</span>=<span class="string">"John"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"john"</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"mike"</span> <span class="attr">value</span>=<span class="string">"Mike"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"mike"</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#example-3',</span><br><span class="line">  data: &#123;</span><br><span class="line">    checkedNames: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-4-单选框"><a href="#2-4-单选框" class="headerlink" title="2.4 单选框"></a>2.4 单选框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"One"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"Two"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#example-4',</span><br><span class="line">  data: &#123;</span><br><span class="line">    picked: ''</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-5-下拉框"><a href="#2-5-下拉框" class="headerlink" title="2.5 下拉框"></a>2.5 下拉框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '...',</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected:''</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-计算属性-amp-监听属性"><a href="#3-计算属性-amp-监听属性" class="headerlink" title="3.计算属性&amp;监听属性"></a>3.计算属性&amp;监听属性</h2><h3 id="3-1-计算属性"><a href="#3-1-计算属性" class="headerlink" title="3.1 计算属性"></a>3.1 计算属性</h3><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个表达式的功能是将message字符串进行反转，这种带有复杂逻辑的表达式，我们可以使用计算属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "&#123;&#123; message &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: '#example',</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: 'Hello'</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      return this.message.split('').reverse().join('')</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-侦听属性"><a href="#3-2-侦听属性" class="headerlink" title="3.2 侦听属性"></a>3.2 侦听属性</h3><p>侦听属性的作用是侦听某属性值的变化，从而做相应的操作，侦听属性是一个对象，它的键是要监听的对象或者变量，值一般是函数,当你侦听的元素发生变化时，需要执行的函数，这个函数有两个形参，第一个是当前值，第二个是变化后的值。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">'#app'</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            iNum:<span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        watch:&#123;</span><br><span class="line">            iNum:<span class="function"><span class="keyword">function</span>(<span class="params">newval,oldval</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(newval + <span class="string">' | '</span> + oldval) </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            fnAdd:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.iNum += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-过滤器"><a href="#4-过滤器" class="headerlink" title="4.过滤器"></a>4.过滤器</h2><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></span><br><span class="line">&#123;&#123; prize | RMB &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在v-bind中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"rawId | formatId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>过滤器实际上是一个函数，可以在一个组件的选项中定义组件内部过滤器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filters:&#123;</span><br><span class="line">  RMB:<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value==<span class="string">''</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'¥ '</span>+value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者在创建 Vue 实例之前全局定义过滤器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.filter(<span class="string">'Yuan'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(value==<span class="string">''</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value+<span class="string">'元'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此时过滤器’RMB’只能在定义它的对象接管标签内使用，而 ‘Yuan’ 可以全局使用</p>
<h2 id="5-数据交互"><a href="#5-数据交互" class="headerlink" title="5. 数据交互"></a>5. 数据交互</h2><p>vue.js没有集成ajax功能，要使用ajax功能，可以使用vue官方推荐的axios.js库来做ajax的交互。 axios库的下载地址：<a href="https://github.com/axios/axios/releases" target="_blank" rel="noopener">https://github.com/axios/axios/releases</a></p>
<h3 id="5-1-axios完整写法："><a href="#5-1-axios完整写法：" class="headerlink" title="5.1 axios完整写法："></a>5.1 axios完整写法：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>axios请求的写法也写成get方式后post方式。</p>
<h3 id="5-2-执行get请求"><a href="#5-2-执行get请求" class="headerlink" title="5.2 执行get请求"></a>5.2 执行get请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为给定 ID 的 user 创建请求</span></span><br><span class="line"><span class="comment">// then是请求成功时的响应，catch是请求失败时的响应</span></span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选地，上面的请求可以这样做</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="5-3-执行post请求"><a href="#5-3-执行post请求" class="headerlink" title="5.3 执行post请求"></a>5.3 执行post请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">  firstName: <span class="string">'Fred'</span>,</span><br><span class="line">  lastName: <span class="string">'Flintstone'</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="6-ES6-语法"><a href="#6-ES6-语法" class="headerlink" title="6.ES6 语法"></a>6.ES6 语法</h2><h3 id="6-1-变量声明let和const"><a href="#6-1-变量声明let和const" class="headerlink" title="6.1 变量声明let和const"></a>6.1 变量声明let和const</h3><p>let 和 const 是新增的声明变量的开头的关键字，在这之前，变量声明是用 var 关键字，这两个关键字和 var 的区别是，它们声明的变量没有预解析，let 和 const 的区别是，let 声明的是一般变量，const 申明的常量，不可修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(iNum01) <span class="comment">// 弹出undefined</span></span><br><span class="line"><span class="comment">// alert(iNum02); 报错，let关键字定义变量没有变量预解析</span></span><br><span class="line"><span class="comment">// alert(iNum03); 报错，const关键字定义变量没有变量预解析</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iNum01 = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 使用let关键字定义变量</span></span><br><span class="line"><span class="keyword">let</span> iNum02 = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// 使用const关键字定义变量</span></span><br><span class="line"><span class="keyword">const</span> iNum03 = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">alert(iNum01); <span class="comment">// 弹出6</span></span><br><span class="line">alert(iNum02); <span class="comment">// 弹出12</span></span><br><span class="line">alert(iNum03); <span class="comment">// 弹出24</span></span><br><span class="line"></span><br><span class="line">iNum01 = <span class="number">7</span>;</span><br><span class="line">iNum02 = <span class="number">13</span>;</span><br><span class="line"><span class="comment">//iNum03 = 25; // 报错,const定义的变量不可修改,const定义的变量是常量</span></span><br><span class="line"></span><br><span class="line">alert(iNum01)</span><br><span class="line">alert(iNum02); </span><br><span class="line">alert(iNum03);</span><br></pre></td></tr></table></figure>

<h3 id="6-2-箭头函数"><a href="#6-2-箭头函数" class="headerlink" title="6.2 箭头函数"></a>6.2 箭头函数</h3><p>可以把箭头函数理解成匿名函数的第二种写法，箭头函数的作用是可以在对象中绑定 this，解决了 JavaScript 中 this 指定混乱的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义函数的一般方式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">function fnRs(a,b)&#123;</span></span><br><span class="line"><span class="comment">    var rs = a + b;</span></span><br><span class="line"><span class="comment">    alert(rs);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">fnRs(1,2);        </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过匿名函数赋值来定义函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">var fnRs = function(a,b)&#123;</span></span><br><span class="line"><span class="comment">    var rs = a + b;</span></span><br><span class="line"><span class="comment">    alert(rs);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">fnRs(1,2);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过箭头函数的写法定义</span></span><br><span class="line"><span class="keyword">var</span> fnRs = <span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rs = a + b;</span><br><span class="line">    alert(rs);</span><br><span class="line">&#125;        </span><br><span class="line"><span class="comment">// fnRs(1,2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个参数可以省略小括号</span></span><br><span class="line"><span class="keyword">var</span> fnRs2 = <span class="function"><span class="params">a</span> =&gt;</span>&#123;</span><br><span class="line">    alert(a);</span><br><span class="line">&#125;</span><br><span class="line">fnRs2(<span class="string">'haha!'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数的作用，可以绑定对象中的this</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">'tom'</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    showName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;,<span class="number">1000</span>)            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.showName();</span><br></pre></td></tr></table></figure>

<h3 id="6-3-模块导入import和导出export"><a href="#6-3-模块导入import和导出export" class="headerlink" title="6.3 模块导入import和导出export"></a>6.3 模块导入import和导出export</h3><p>javascript 之前是没有模块的功能的，之前做 js 模块化开发，是用的一些 js 库来模拟实现的，在 ES6 中加入了模块的功能，和 python 语言一样，python 中一个文件就是一个模块，ES6 中，一个 js 文件就是一个模块，不同的是，js 文件中需要先导出 (export) 后，才能被其他 js 文件导入(import)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// model.js文件中导出</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>:<span class="string">'tom'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;person&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js文件夹中导入</span></span><br><span class="line"><span class="keyword">import</span> person <span class="keyword">from</span> <span class="string">'js/model.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js中使用模块</span></span><br><span class="line">person.name</span><br><span class="line">person.age</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面导出时使用了default关键字，如果不使用这个关键字，导入时需要加大括号：</span></span><br><span class="line"><span class="comment">import &#123;person&#125; from 'js/model.js'</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>目前ES6的模块功能需要在服务器环境下才可以运行。</p>
<h3 id="6-4-对象的简写"><a href="#6-4-对象的简写" class="headerlink" title="6.4 对象的简写"></a>6.4 对象的简写</h3><p>javascript 对象在 ES6 中可以做一些简写形式，了解这些简写形式，才能方便我们读懂一些在 javascript 代码中简写的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'李思'</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">var person = &#123;</span></span><br><span class="line"><span class="comment">    name:name,</span></span><br><span class="line"><span class="comment">    age:age,</span></span><br><span class="line"><span class="comment">    showname:function()&#123;</span></span><br><span class="line"><span class="comment">        alert(this.name);</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    showage:function()&#123;</span></span><br><span class="line"><span class="comment">        alert(this.age);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写成下面的形式</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    showname()&#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    showage()&#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.showname();</span><br><span class="line">person.showage();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端攻坚战</title>
    <url>/2019/12/09/%E5%89%8D%E7%AB%AF%E6%94%BB%E5%9D%9A%E6%88%98/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
前端三大新框架：Angular.js、React.js、Vue.js。今天我们来磕这个最常用，影响极广的框架：Vue.js。

<p>Vue.js可以作为一个js库来使用，也可以用它全套的工具来构建系统界面，这些可以根据项目的需要灵活选择，所以说，Vue.js是一套构建用户界面的渐进式框架。</p>
<blockquote>
<p>Vue的核心库只关注视图层，Vue的目标是通过尽可能简单的 API 实现响应的数据绑定，在这一点上Vue.js类似于后台的模板语言。</p>
<p>Vue也可以将界面拆分成一个个的组件，通过组件来构建界面，然后用自动化工具来生成单页面(SPA - single page application)系统。</p>
</blockquote>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-快速上手"><a href="#1-快速上手" class="headerlink" title="1.快速上手"></a>1.快速上手</h2><p>还是从最基本的使用开始回顾。</p>
<p>第一步，需要实例化一个 Vue 对象，像下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;<span class="attr">message</span>:<span class="string">'hello world!'</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>html 页面中 id 为 app 的标签就可以通过模版语法接收到此消息：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>是不是很眼熟？没错，和我们 python 后端的模版语法一样，所以就不要抵触，开开心心使用吧。</p>
<p>当然，我们还可以在 Vue 实例化过程中定义方法，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;<span class="attr">message</span>: <span class="string">'hello world!'</span>&#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    fnChangeMsg:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.message = <span class="string">'hello Vue.js!'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们可以使用下面的页面感受它的 <code>响应式</code> ：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fnChangeMsg"</span>&gt;</span></span><br><span class="line">    点击即可改变数据</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面我们分析一下这个阶段发生了什么：</p>
<p>首先，当创建一个 Vue 实例时，它会把 data 对象中所有属性添加到 Vue 的响应式系统中。当这些属性的值发生变化，视图将会匹配到更新之后的值。上面的例子，通过一个方法，改变 data 对象中的属性，使视图中的值随之变化，演示了响应式。</p>
<h2 id="2-模版语法"><a href="#2-模版语法" class="headerlink" title="2.模版语法"></a>2.模版语法</h2><p>模版语法的作用就是获取数据，并在 HTML 页面中进行展示。</p>
<blockquote>
<p>所有 Vue.js的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。</p>
</blockquote>
<h3 id="2-1-插入值"><a href="#2-1-插入值" class="headerlink" title="2.1 插入值"></a>2.1 插入值</h3><p>1.最最常见的一种是胡子语法，即双大括号，也就是上面示例中的样式。除了可以获取值，大括号中还支持写表达式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? 'YES' : 'No' &#125;&#125;</span><br><span class="line">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>2.还有一种情况，标签的属性需要获取值，这时就不能再次使用胡子语法了，可以改写为 <code>v-bind</code> 指令：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span> <span class="attr">vbind:title</span>=<span class="string">"tip"</span>&gt;</span>小闫劝你多喝热水<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-指令"><a href="#2-2-指令" class="headerlink" title="2.2 指令"></a>2.2 指令</h3><p>Vue 中指令就是带有前缀 <code>v-</code> 前缀的特殊属性。</p>
<blockquote>
<p>指令属性的值预期是单个JavaScript表达式，指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM。</p>
</blockquote>
<p>常见的指令有 <code>v-bind</code>、<code>v-if</code>、<code>v-on</code> 和 <code>v-for</code>。下面举两个例子进行演示即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据 ok 的布尔值来插入/移除 &lt;p&gt; 元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line">  是否显示这一段</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 监听按钮的 click 事件来执行 fnChangeMsg 方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"fnChangeMsg"</span>&gt;</span></span><br><span class="line">  按钮</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-缩写"><a href="#2-3-缩写" class="headerlink" title="2.3 缩写"></a>2.3 缩写</h3><p>v-bind 和 v-on 事件这两个指令因为经常的使用，所以提供了简写的方式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整的语法形式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 完整的语法形式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"fnChangeMsg"</span>&gt;</span></span><br><span class="line">  按钮</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fnChangeMsg"</span>&gt;</span></span><br><span class="line">  按钮</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-Class-属性设置"><a href="#2-4-Class-属性设置" class="headerlink" title="2.4 Class 属性设置"></a>2.4 Class 属性设置</h3><p>设置元素的 class 属性可以使用 v-bind 指令。因为它们的属性值可以是表达式，vue.js在这一块做了增强。表达式结果除了是字符串之外，还可以是对象或者数组。</p>
<h4 id="2-4-1-对象的情况"><a href="#2-4-1-对象的情况" class="headerlink" title="2.4.1 对象的情况"></a>2.4.1 对象的情况</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static"</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123;active:isActive,'text-danger':hasError &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>data 的属性值是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  hasError: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终渲染的效果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static active"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以给 v-bind:class 传一个对象引用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>data 属性值可以写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: true,</span><br><span class="line">    &apos;text-danger&apos;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-数组的情况"><a href="#2-4-2-数组的情况" class="headerlink" title="2.4.2 数组的情况"></a>2.4.2 数组的情况</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[activeClass, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: 'active',</span><br><span class="line">  errorClass: 'text-danger'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终渲染为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"active text-danger"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你也想根据条件切换列表中的 class，可以用三元表达式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>即当 isActive 值为 ture 时，属性为 activeClass，否则属性值为 <code>&#39;&#39;</code></p>
<blockquote>
<p>Js 的三元表达式：<code>条件 ? 为真时的结果 : 为假时的结果</code></p>
</blockquote>
<h3 id="2-5-条件"><a href="#2-5-条件" class="headerlink" title="2.5 条件"></a>2.5 条件</h3><p>一般通过条件指令来控制元素是显示还是隐藏，是创建还是销毁。</p>
<p>虽然语法有些许陌生，但是永远逃不了 if 、else if 、else 这三个东西，所有语言都是如此。那么我们来分情况看一下这三种情况如何书写：</p>
<h4 id="2-5-1-v-if"><a href="#2-5-1-v-if" class="headerlink" title="2.5.1 v-if"></a>2.5.1 v-if</h4><p>v-if 可以控制元素的创建或者销毁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-v-else"><a href="#2-5-2-v-else" class="headerlink" title="2.5.2 v-else"></a>2.5.2 v-else</h4><p>v-else 指令来表示 v-if 的 <code>else 块</code>，v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;</span><br><span class="line">  Now you see me</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Now you don&apos;t</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-v-else-if"><a href="#2-5-3-v-else-if" class="headerlink" title="2.5.3 v-else-if"></a>2.5.3 v-else-if</h4><p>v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;</span><br><span class="line">  B</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Not A/B/C</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-4-v-show"><a href="#2-5-4-v-show" class="headerlink" title="2.5.4 v-show"></a>2.5.4 v-show</h4><p>另一个用于根据条件展示元素的选项是 v-show 指令。用法和 v-if 大致一样，但是它不支持 v-else ,它和 v-if 的区别是，它制作元素样式的显示和隐藏，元素一直是存在的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-列表循环"><a href="#2-6-列表循环" class="headerlink" title="2.6 列表循环"></a>2.6 列表循环</h3><p>数一数，常用的指令还有俩，那快解决吧。</p>
<p>一种常用的情况–列表渲染，即通过遍历数组或者对象，渲染到页面中。这时就需要用到一个指令 v-for。同样我们通过数组和对象两种情况进行演示：</p>
<h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">    &#123;&#123; item &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>vue对象创建如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [<span class="string">'foo'</span>,<span class="string">'bar'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果想加上索引值，可以加上第二个参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span>&gt;</span></span><br><span class="line">    &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h4><p>也可以用 v-for 通过一个对象的属性来迭代</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"v-for-object"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"value in object"</span>&gt;</span></span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果想加上对象属性名，可以加上第二个参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"v-for-object"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(value,key) in object"</span>&gt;</span></span><br><span class="line">    &#123;&#123; key &#125;&#125;-&#123;&#123; value &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-7-事件相关"><a href="#2-7-事件相关" class="headerlink" title="2.7 事件相关"></a>2.7 事件相关</h3><h4 id="2-7-1-事件绑定方法"><a href="#2-7-1-事件绑定方法" class="headerlink" title="2.7.1 事件绑定方法"></a>2.7.1 事件绑定方法</h4><p>可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。</p>
<p>事件的处理，简单的逻辑可以写在指令中，复杂的就需要在 vue 对象的 methods 属性中指定处理函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;example-1&quot;&gt;</span><br><span class="line">  &lt;!-- 在指令中写处理逻辑 --&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;</span><br><span class="line">  &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">......</span><br><span class="line">var example1 = new Vue(&#123;</span><br><span class="line">  el: &apos;#example-1&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>methods 属性中指定处理函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;example-2&quot;&gt;</span><br><span class="line">  &lt;!-- greet 是在下面定义的方法名 --&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">var example2 = new Vue(&#123;</span><br><span class="line">  el: &apos;#example-2&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: &apos;Vue.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 在 `methods` 对象中定义方法</span><br><span class="line">  methods: &#123;</span><br><span class="line">    greet: function () &#123;</span><br><span class="line">      // `this` 在方法里指向当前 Vue 实例</span><br><span class="line">      alert(&apos;Hello &apos; + this.name + &apos;!&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-7-2-事件修饰符"><a href="#2-7-2-事件修饰符" class="headerlink" title="2.7.2 事件修饰符"></a>2.7.2 事件修饰符</h4><p>实际开发中，事件绑定有时候牵涉到阻止事件冒泡以及阻止默认行为，在 vue.js 可以加上事件修饰符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>继续死磕前端</title>
    <url>/2019/12/08/%E7%BB%A7%E7%BB%AD%E6%AD%BB%E7%A3%95%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
昨天将所有的基础知识进行了回顾，今天继续磕，不死不休～

<p>今天要说的便是 jquery 这个函数库，毕竟它影响范围之广，不会都不好意说自己会前端？</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h2><p>long long ago ～ 人们发现了一个好用的工具，它涵盖了常用的所有功能，还提供了很多相当方便的设计（如 Ajax）。因此，它的面世，如星星之火燎原之势迅猛发展，以至于微软公司把它作为官方库。</p>
<p>这个小小的 js 文件，你可以说他是插件，也可以称其为框架，随你喜欢，只要知道一点，它很好用就可以了。肯定有人会问如何下载之类的问题，其实我很不愿意回答，毕竟这些随意百度到的东西很浪费时间和文字，但是秉承着服务的宗旨，贴出以下链接：</p>
<p>1、<a href="http://jquery.com/" target="_blank" rel="noopener">http://jquery.com/</a> 官方网站</p>
<p>2、<a href="https://code.jquery.com/" target="_blank" rel="noopener">https://code.jquery.com/</a> 版本下载</p>
<h3 id="1-简单入门"><a href="#1-简单入门" class="headerlink" title="1.简单入门"></a>1.简单入门</h3><p>还记得上篇文章反复强调的一个问题嘛？就是 js 代码放在何处执行的问题。要么老老实实放置在所需应用样式的标签后面，要么将其丢到 window.onload 方法内部。</p>
<p>jquery 提供了一种速度更快，使用更便捷的方式，那便是 ready 方法。它长成了下面美丽的样子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>嫌弃它的臃肿，可以简写为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  xxx</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在是否顺眼了许多？</p>
<h4 id="1-1-jquery-选择器"><a href="#1-1-jquery-选择器" class="headerlink" title="1.1 jquery 选择器"></a>1.1 jquery 选择器</h4><p>还记到大明湖畔（CSS）的夏雨荷（选择器）吗？选择器可以快速定位到元素并为其应用样式效果。jquery 选择器的选择规则与 CSS 相同，只是目的是为其添加操作。</p>
<p>不要有任何心理负担，它相当简单，如下：</p>
<p>1.选择 id 为 Ethan 的元素（类比 id 选择器）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#Ethan'</span>)</span><br></pre></td></tr></table></figure>

<p>2.选择 class 为  Yan 的元素（类比类选择器）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.Yan'</span>)</span><br></pre></td></tr></table></figure>

<p>3.选择所有的 p 标签（类比标签选择器）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'p'</span>)</span><br></pre></td></tr></table></figure>

<p>4.选择 id 为 mylist 的元素下所有 li 标签下的 span 元素（类比层级选择器）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#mylist li span'</span>)</span><br></pre></td></tr></table></figure>

<p>5.选择 name 属性为 yan 的 input 元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'input[name=yan]'</span>)</span><br></pre></td></tr></table></figure>

<p>如果一类元素范围太广，需要更精确一些呢？可以使用如下的过滤条件：</p>
<p>1.has 包含条件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).has(<span class="string">'p'</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>包含 p 元素的 div 元素</p>
</blockquote>
<p>2.判等条件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).eq(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第 5 个 div 元素</p>
</blockquote>
<p>3.寻找条件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#box'</span>).find(<span class="string">'.myClass'</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>选择 id 是 box 元素中 class 为 myClass 的元素</p>
</blockquote>
<p>4.前一个元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#box'</span>).prev();</span><br></pre></td></tr></table></figure>

<p>5.后一个元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#box'</span>).next();</span><br></pre></td></tr></table></figure>

<p>已经知道了如何定位某个元素，那么如何定位一个精确的集合呢？这个也不难：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择id是box的元素之前所有的同辈元素</span></span><br><span class="line">$(<span class="string">'#box'</span>).prevAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择id是box的元素后面所有的同辈元素</span></span><br><span class="line">$(<span class="string">'#box'</span>).nextAll(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//选择id是box的元素的父元素</span></span><br><span class="line">$(<span class="string">'#box'</span>).parent(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//选择id是box的元素的所有子元素</span></span><br><span class="line">$(<span class="string">'#box'</span>).children(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//选择id是box的元素的同级元素</span></span><br><span class="line">$(<span class="string">'#box'</span>).siblings();</span><br></pre></td></tr></table></figure>

<p>有人会想，如果我写错了，没找到报错怎么办？大可放心，jquery 有容错机制，即使没有找到元素，也不会出错。还为你提供了验证是否找到的方法，那便是 length 属性。length 值为 0 时代表没选择到想要元素；为 1 则代表选择到了相应的元素。</p>
<p>除了选择元素，还可以选择样式呢！啥都能找到，强不强？既然都能找到了，重新赋值也必须到位！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取div的样式</span></span><br><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"width"</span>);</span><br><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"color"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"width"</span>,<span class="string">"20px"</span>);</span><br><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"color"</span>,<span class="string">"red"</span>);</span><br></pre></td></tr></table></figure>

<p>如果你足够的细心，你也许会问，选择器一般都选择多个元素，那么你获取到的是哪一个元素的值呢？</p>
<p>答：第一个。</p>
<p>再看看其他操作样式的类名吧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为id为div1的对象追加样式divClass2</span></span><br><span class="line">$(<span class="string">"#div1"</span>).addClass(<span class="string">"divClass2"</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除id为div1的对象的class名为divClass的样式</span></span><br><span class="line">$(<span class="string">"#div1"</span>).removeClass(<span class="string">"divClass"</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除多个样式</span></span><br><span class="line">$(<span class="string">"#div1"</span>).removeClass(<span class="string">"divClass divClass2"</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 重复切换anotherClass样式</span></span><br><span class="line">$(<span class="string">"#div1"</span>).toggleClass(<span class="string">"anotherClass"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-绑定点击事件"><a href="#1-2-绑定点击事件" class="headerlink" title="1.2 绑定点击事件"></a>1.2 绑定点击事件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#btn'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 内部的 this 指的是原生对象</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 使用 jquery 对象用 $(this)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>js 对象与 jquery 对象有些许不同，jquery 对象是对 js 对象的封装，然后让其拥有了 jquery 的操作方法。他俩之间可以相互转换。</p>
<p>DOM 对象转 jquery 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(js对象)</span><br></pre></td></tr></table></figure>

<p>jquery 对象转 DOM 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery对象[index];    <span class="comment">//方式1 （推荐使用）</span></span><br><span class="line"></span><br><span class="line">jQuery对象.get(index); <span class="comment">//方式2</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>获取元素的索引值可以使用 index() 方法</p>
<h4 id="1-3-jquery-动画"><a href="#1-3-jquery-动画" class="headerlink" title="1.3 jquery 动画"></a>1.3 jquery 动画</h4><p>通过 animate 方法可以设置元素某属性值上的动画，动画执行完后会执行一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#div1'</span>).animate(&#123;</span><br><span class="line">    width:<span class="number">300</span>,</span><br><span class="line">    height:<span class="number">300</span></span><br><span class="line">&#125;,<span class="number">1000</span>,<span class="string">'swing'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'done!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>animate 参数详解</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    animate参数：</span></span><br><span class="line"><span class="comment">    参数一：要改变的样式属性值，写成字典的形式</span></span><br><span class="line"><span class="comment">    参数二：动画持续的时间，单位为毫秒，一般不写单位</span></span><br><span class="line"><span class="comment">    参数三：动画曲线，默认为‘swing’，缓冲运动，还可以设置为‘linear’，匀速运动</span></span><br><span class="line"><span class="comment">    参数四：动画回调函数，动画完成后执行的匿名函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-进阶"><a href="#2-进阶" class="headerlink" title="2.进阶"></a>2.进阶</h3><h4 id="2-1-特殊效果"><a href="#2-1-特殊效果" class="headerlink" title="2.1 特殊效果"></a>2.1 特殊效果</h4><p>1.<code>fadeIn()</code> 淡入</p>
<p>2.<code>fadeOut()</code> 淡出</p>
<p>3.<code>hide()</code> 隐藏</p>
<p>4.<code>show()</code> 显示</p>
<p>5.<code>toggle()</code> 切换元素的可见状态</p>
<p>6.<code>slideDown()</code> 向下展开</p>
<p>7.<code>slideUp()</code> 向上卷起</p>
<p>8.<code>slideToggle()</code> 依次展开或卷起某个元素</p>
<p><strong>Example</strong>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$btn.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">'#div1'</span>).fadeIn(<span class="number">1000</span>,</span><br><span class="line">                   <span class="string">'swing'</span>,</span><br><span class="line">                   <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    									alert(<span class="string">'done'</span>);</span><br><span class="line">  								&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在看过很多属性时，不知道大家是否发现了一个规律：凡是成对出现的属性，一般都有一个组合属性，名字带有 <code>toggle</code></p>
</blockquote>
<h4 id="2-2-链式调用"><a href="#2-2-链式调用" class="headerlink" title="2.2 链式调用"></a>2.2 链式调用</h4><p>链式调用，其实就是将多个方法一直拼接在对象后面，像链条一样调用。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#div1'</span>) <span class="comment">// id为div1的元素</span></span><br><span class="line">.children(<span class="string">'ul'</span>) <span class="comment">//该元素下面的ul子元素</span></span><br><span class="line">.slideDown(<span class="string">'fast'</span>) <span class="comment">//高度从零变到实际高度来显示ul元素</span></span><br><span class="line">.parent()  <span class="comment">//跳到ul的父元素，也就是id为div1的元素</span></span><br><span class="line">.siblings()  <span class="comment">//跳到div1元素平级的所有兄弟元素</span></span><br><span class="line">.children(<span class="string">'ul'</span>) <span class="comment">//这些兄弟元素中的ul子元素</span></span><br><span class="line">.slideUp(<span class="string">'fast'</span>);  <span class="comment">//高度实际高度变换到零来隐藏ul元素</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>换行是为了加注释解释每一个方法，其实它为一行。</p>
</blockquote>
<h4 id="2-3-属性操作"><a href="#2-3-属性操作" class="headerlink" title="2.3 属性操作"></a>2.3 属性操作</h4><p>还记得昨天总结中 js 对象如何获取元素内容嘛？没错，是 <code>innerHTML</code>。jquery 中则是使用 html() 方法获取和设置 html 内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line"><span class="keyword">var</span> $htm = $(<span class="string">'#div1'</span>).html();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 html 内容</span></span><br><span class="line">$(<span class="string">'#div1'</span>).html(<span class="string">'&lt;span&gt;xxx&lt;/span&gt;'</span>);</span><br></pre></td></tr></table></figure>

<p>jquery 中获取或者设置某个属性值时可以使用如下方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取出图片的地址</span></span><br><span class="line"><span class="keyword">var</span> $src = $(<span class="string">'#img1'</span>).prop(<span class="string">'src'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置图片的地址和alt属性</span></span><br><span class="line">$(<span class="string">'#img1'</span>).prop(&#123;<span class="attr">src</span>: <span class="string">"test.jpg"</span>, <span class="attr">alt</span>: <span class="string">"Test Image"</span> &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-4-事件"><a href="#2-4-事件" class="headerlink" title="2.4 事件"></a>2.4 事件</h4><p><strong>常用的一些事件函数</strong>：</p>
<p>1.<code>blur()</code> 元素失去焦点</p>
<p>2.<code>focus()</code> 元素获得焦点</p>
<p>3.<code>click()</code> 鼠标单击</p>
<p>4.<code>mouseover()</code> 鼠标进入（进入子元素也触发）</p>
<p>5.<code>mouseout()</code> 鼠标离开（离开子元素也触发）</p>
<p>6.<code>mouseenter()</code> 鼠标进入（进入子元素不触发）</p>
<p>7.<code>mouseleave()</code> 鼠标离开（离开子元素不触发）</p>
<p>8.<code>hover()</code> 同时为mouseenter和mouseleave事件指定处理函数</p>
<p>9.<code>ready()</code> DOM加载完成</p>
<p>10.<code>submit()</code> 用户递交表单</p>
<h4 id="2-5-正则表达式-表单验证"><a href="#2-5-正则表达式-表单验证" class="headerlink" title="2.5 正则表达式-表单验证"></a>2.5 正则表达式-表单验证</h4><p>正则表达式无比强大，处处可以看见其身影。当我们验证邮箱格式、手机号、身份证号时必不可少，那么 jquery 中如何使用呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'规则'</span>, <span class="string">'可选参数'</span>);</span><br><span class="line"><span class="keyword">var</span> re=<span class="regexp">/规则/</span>参数;</span><br></pre></td></tr></table></figure>

<p>大家可以看到，其由规则与参数两部分组成。其中规则老生常谈，我们再复习一遍：</p>
<p><code>\d</code> 匹配一个数字，即0-9</p>
<p><code>\D</code> 匹配一个非数字，即除了0-9</p>
<p><code>\w</code> 匹配一个单词字符（字母、数字、下划线）</p>
<p><code>\W</code> 匹配任何非单词字符。等价于<code>[^A-Za-z0-9_]</code></p>
<p><code>\s</code> 匹配一个空白符</p>
<p><code>\S</code> 匹配一个非空白符</p>
<p><code>\b</code> 匹配单词边界</p>
<p><code>\B</code> 匹配非单词边界</p>
<p><code>.</code> 匹配一个任意字符</p>
<p><strong>量词</strong>：</p>
<p><code>?</code> 出现零次或一次（最多出现一次）</p>
<p><code>+</code> 出现一次或多次（至少出现一次）</p>
<p><code>*</code> 出现零次或多次（任意次）</p>
<p><code>{n}</code> 出现n次</p>
<p><code>{n,m}</code> 出现n到m次</p>
<p><code>{n,}</code> 至少出现n次</p>
<p><strong>范围</strong>：使用中括号将可选内容列出，代表内容中任意一个</p>
<p><code>[abc123]</code> : 匹配‘abc123’中的任意一个字符</p>
<p><code>[a-z0-9]</code> : 匹配a到z或者0到9中的任意一个字符</p>
<p><strong>限制开头与结尾</strong>：</p>
<p><code>^</code> 以紧挨的元素开头</p>
<p><code>$</code> 以紧挨的元素结尾</p>
<p>那么<strong>参数</strong>部分，常用的有：</p>
<p><code>g</code>： global，全文搜索，默认搜索到第一个结果接停止</p>
<p><code>i</code>： ingore case，忽略大小写，默认大小写敏感</p>
<p>还有常用的<strong>函数</strong></p>
<p><code>test</code></p>
<p>用法：<code>正则.test(字符串)</code> 匹配成功，就返回真，否则就返回假</p>
<p><strong>正则默认规则</strong> </p>
<p>匹配成功就结束，不会继续匹配，区分大小写</p>
<p>下面给大家个福利，总结了常用的正则表达式，直接复制粘贴即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户名验证：(数字字母或下划线6到20位)</span></span><br><span class="line"><span class="keyword">var</span> reUser = <span class="regexp">/^\w&#123;6,20&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邮箱验证：        </span></span><br><span class="line"><span class="keyword">var</span> reMail = <span class="regexp">/^[a-z0-9][\w\.\-]*@[a-z0-9\-]+(\.[a-z]&#123;2,5&#125;)&#123;1,2&#125;$/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//密码验证：</span></span><br><span class="line"><span class="keyword">var</span> rePass = <span class="regexp">/^[\w!@#$%^&amp;*]&#123;6,20&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手机号码验证：</span></span><br><span class="line"><span class="keyword">var</span> rePhone = <span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>;</span><br></pre></td></tr></table></figure>


<h3 id="3-高级"><a href="#3-高级" class="headerlink" title="3.高级"></a>3.高级</h3><h4 id="3-1-事件冒泡"><a href="#3-1-事件冒泡" class="headerlink" title="3.1 事件冒泡"></a>3.1 事件冒泡</h4><p>先来看看什么是事件冒泡：</p>
<blockquote>
<p>在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。</p>
</blockquote>
<p>就这样一层一层往上冒的效果，我们形象的称为冒泡。那么它有什么作用呢？</p>
<p>答：事件冒泡允许多个操作被集中处理（把事件处理器添加到一个父级元素上，避免把事件处理器添加到多个子级元素上），它还可以让你在对象层的不同级别捕获事件。</p>
<p>这只是一种机制，但是我们并不是任何情况下都需要，那么可以将其关掉。通过：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.stopPropagation();</span><br></pre></td></tr></table></figure>

<p>既然说起阻止事件冒泡了，那么我们也提一下如何阻止表单提交吧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure>

<p>实际开发中其实常常将其混合使用，也就是两句话写在一起使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// event.stopPropagation();</span></span><br><span class="line"><span class="comment">// event.preventDefault();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并写法：</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-事件委托"><a href="#3-2-事件委托" class="headerlink" title="3.2 事件委托"></a>3.2 事件委托</h4><p>同样，先来看定义：</p>
<blockquote>
<p>事件委托就是利用冒泡的原理，把事件加到父级上，通过判断事件来源的子集，执行相应的操作，事件委托首先可以极大减少事件绑定次数，提高性能；其次可以让新加入的子元素也可以拥有相同的操作。</p>
</blockquote>
<p><strong>一般绑定事件的写法</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">    $ali = $(&apos;#list li&apos;);</span><br><span class="line">    $ali.click(function() &#123;</span><br><span class="line">        $(this).css(&#123;background:&apos;red&apos;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p><strong>事件委托的写法</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">    $list = $(&apos;#list&apos;);</span><br><span class="line">    $list.delegate(&apos;li&apos;, &apos;click&apos;, function() &#123;</span><br><span class="line">        $(this).css(&#123;background:&apos;red&apos;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-Dom-操作"><a href="#3-3-Dom-操作" class="headerlink" title="3.3 Dom 操作"></a>3.3 Dom 操作</h4><p>Dom 操作也叫做元素节点操作，它指的是改变html的标签结构，它有两种情况：</p>
<p>1、移动现有标签的位置</p>
<p>2、将新创建的标签插入到现有的标签中 </p>
<p><strong>创建新标签</strong> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $div = $(<span class="string">'&lt;div&gt;'</span>); <span class="comment">//创建一个空的div</span></span><br><span class="line"><span class="keyword">var</span> $div2 = $(<span class="string">'&lt;div&gt;这是一个div元素&lt;/div&gt;'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>移动或者插入标签的方法</strong> </p>
<p>1、<code>append()</code> 和 <code>appendTo()</code>：在现存元素的内部，从后面放入元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $span = $(<span class="string">'&lt;span&gt;这是一个span元素&lt;/span&gt;'</span>);</span><br><span class="line">$(<span class="string">'#div1'</span>).append($span);</span><br><span class="line">......</span><br><span class="line">&lt;div id=<span class="string">"div1"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>2、<code>prepend()</code> 和 <code>prependTo()</code>：在现存元素的内部，从前面放入元素</p>
<p>3、<code>after()</code> 和 <code>insertAfter()</code>：在现存元素的外部，从后面放入元素</p>
<p>4、<code>before()</code> 和 <code>insertBefore()</code>：在现存元素的外部，从前面放入元素</p>
<p><strong>删除标签</strong> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#div1'</span>).remove();</span><br></pre></td></tr></table></figure>

<h4 id="3-4-对象"><a href="#3-4-对象" class="headerlink" title="3.4 对象"></a>3.4 对象</h4><p>JavaScript 的对象，可以简单的理解为一个键值对的集合，也就是 python 中的字典，键就是调用每个值的名称，值就是变量、函数、对象这些。</p>
<p>面向对象编程深入人心，有着 python 、java 的基础，大家应该不难理解。接下来说一下 js 中如何创建一个对象，并对其进行操作。</p>
<p>1.创建一个对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Ethan'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello'</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.添加属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.name = <span class="string">'tom'</span>;</span><br><span class="line">person.age = <span class="string">'99'</span>;</span><br></pre></td></tr></table></figure>

<p>3.添加方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name + <span class="string">'你好'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.调用方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.sayHello();</span><br><span class="line">person.age;</span><br></pre></td></tr></table></figure>

<h3 id="4-Ajax"><a href="#4-Ajax" class="headerlink" title="4.Ajax"></a>4.Ajax</h3><p>ajax一个前后台配合的技术，它可以让 javascript 发送 http 请求，与后台通信，获取数据和信息。ajax 技术的原理是实例化 xmlhttp 对象，使用此对象与后台通信。jquery 将它封装成了一个函数 <code>$.ajax()</code>，我们可以直接用这个函数来执行ajax请求。</p>
<p>此部分<strong>超级重要！超级重要！超级重要！</strong></p>
<blockquote>
<p>ajax需要在服务器环境下运行。</p>
</blockquote>
<p>先来看一个示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/change_data'</span>,</span><br><span class="line">    type: <span class="string">'GET'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    data:&#123;<span class="string">'code'</span>:<span class="number">300268</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.done(<span class="function"><span class="keyword">function</span>(<span class="params">dat</span>) </span>&#123;</span><br><span class="line">    alert(dat.name);</span><br><span class="line">&#125;)</span><br><span class="line">.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'服务器超时，请重试！'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后看一下其中的参数：</p>
<p>1、<code>url</code> 请求地址</p>
<p>2、<code>type</code> 请求方式，默认是 <code>GET</code>，常用的还有 <code>POST</code></p>
<p>3、<code>dataType</code> 设置返回的数据格式，常用的是 <code>json</code> 格式，也可以设置为<code>html</code></p>
<p>4、<code>data</code> 设置发送给服务器的数据</p>
<p>5、<code>success</code> 设置请求成功后的回调函数</p>
<p>6、<code>error</code> 设置请求失败后的回调函数</p>
<p>7、<code>async</code> 设置是否异步，默认值是 <code>true</code>，表示异步</p>
<p>简写方式：</p>
<p><code>$.ajax</code> 按照请求方式可以简写成 <code>$.get</code> 或者 <code>$.post</code> 方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="keyword">get</span>("/change_data", &#123;<span class="string">'code'</span>:<span class="number">300268</span>&#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">dat,status</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(status==<span class="string">'success'</span>)&#123;</span><br><span class="line">    	alert(dat.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">'json'</span>);</span><br><span class="line"></span><br><span class="line">$.post(<span class="string">"/change_data"</span>, &#123;<span class="string">'code'</span>:<span class="number">300268</span>&#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">dat</span>)</span>&#123;</span><br><span class="line">    alert(dat.name);</span><br><span class="line">&#125;,<span class="string">'json'</span>);</span><br></pre></td></tr></table></figure>

<p>我们经常会听到两个词：局部刷新 和 无刷新。这是什么意思呢？</p>
<p>答：ajax可以实现局部刷新，也叫做无刷新，无刷新指的是整个页面不刷新，只是局部刷新，ajax可以自己发送http请求，不用通过浏览器的地址栏，所以页面整体不会刷新，ajax获取到后台数据，更新页面显示数据的部分，就做到了页面局部刷新。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕前端ing～</title>
    <url>/2019/12/07/%E6%AD%BB%E7%A3%95%E5%89%8D%E7%AB%AFing%EF%BD%9E/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
这么久没有发文，很多人关心我是否离开了这个美丽的世界 ... 这些同学，是如何居心？出来，我保证不打死你们。不过很久没有更新文章，确实抱歉，我的错，我有罪 ～（小声逼逼：我又不是签约作家，还被逼出了连载的味道，也是没谁了。）

<p>今天咱们唠唠前端那点事儿，和前端死磕到底。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<blockquote>
<p>当然并不是和可爱的前端们发生争执，而是和那些标签、js、框架死磕到底。</p>
</blockquote>
<p>说起来惭愧，许久没有碰过代码（除了偶尔的脚本），<code>python</code> 生疏已久，前端的 <code>html</code> 、<code>css</code> 和 <code>javascript</code> 更是遗忘在了奈何桥的另一头。作为一个热爱学习的三好青年，怎会允许此事发生？今天咱们就先来回顾一下这些基础知识。以下内容根据 HTML 、CSS 、JS 的顺序进行回顾，文章篇幅较长，可以跳读。</p>
<h2 id="1-HTML"><a href="#1-HTML" class="headerlink" title="1.HTML"></a>1.HTML</h2><p>大家好，我是 html ，学名为超文本标记语言。在浏览器上处处可以看到我的身影。当然，我自己不会如此伟大，身后支撑有一个团队，他们是<strong>化妆师</strong> CSS 和<strong>动作指导</strong> Javascript。</p>
<p>我身上有很多的标签，经过化妆师 CSS 的修饰，才得以展现如此靓丽的一面（让一些开了美颜、瘦脸、拉长身高的小姐姐自愧不如）。那么，简单的数数我身上有哪些标签。</p>
<h3 id="1-1-标签"><a href="#1-1-标签" class="headerlink" title="1.1 标签"></a>1.1 标签</h3><p>1.<code>head</code> 标签，里面会包含一些个 <code>meta</code> 标签、<code>title</code> 标签（网页的标题就是这个小东东）。你以为这些就够了？它里面能嵌入 <code>style</code> （样式标签，内容为 CSS 代码），还可以嵌入 <code>script</code> （内容为 JavaScript 代码），内容极为丰富。</p>
<p>2.<code>body</code> 标签作为身体，大部分的页面内容就自此处啦。</p>
<p>3.<code>h</code> 是标题标签</p>
<p>4.<code>div</code> 是块状标签</p>
<p>5.<code>p</code> 是段落标签</p>
<p>6.<code>br</code> 是换行标签，它是单个出现的标签</p>
<p>7.<code>img</code> 是图片标签，他也是单个出现的标签</p>
<p>8.<code>a</code> 是超链接标签，点击可跳转其他链接</p>
<p>9.<code>ul</code> 和 <code>li</code> 组成了无序标签；而 <code>ol</code> 则是有序标签</p>
<p>10.<code>form</code> 是表单（其中 action 属性定义提交地址；method 属性则是确定表单提交的方式）</p>
<p>11.<code>label</code> 是标注标签。比如一个输入框前面标注为姓名，意思就是让用户输入姓名。</p>
<p>12.<code>input</code> 是输入框。type 属性确定其内容：text 是单行文本，password 是密码框，radio 是单选框，checkbox 是复选框，file 是上传文件，submit 是提交按钮，reset 是重置按钮，button 是普通按钮。</p>
<p>13.<code>textarea</code> 则是多行文本输入框</p>
<p>14.<code>select</code> 是下拉表单</p>
<p>15.<code>option</code> 与 <code>select</code> 配合使用，意思即下拉表单中的选项</p>
<p>16.<code>span</code> 标签则是一些特殊格式文本的标签</p>
<p>17.<code>table</code> 是表格标签，与其配合的有 <code>tr</code> 行标签， <code>th</code> 表头单元格， <code>td</code> 普通单元格</p>
<h3 id="1-2-实体符号以及注释"><a href="#1-2-实体符号以及注释" class="headerlink" title="1.2 实体符号以及注释"></a>1.2 实体符号以及注释</h3><p>大家都知道国人写文章的习惯为段首缩进两字符，如果在 <code>p</code> 标签起始位置手敲俩空格后，页面展示会发现怎么只有一个空格？？？那是因为被浏览器吃了，想要显示多个空格，就需要空格的实体符号了。那便是 <code>&amp;nbsp;</code>。</p>
<p>另外，为了防止歧义的产生，还有俩实体符合值得一提，那便是大于号和小于号。毕竟它们长得太像标签的尖括号了。小于号表示为<code>&amp;lt;</code>；大于号表示为 <code>&amp;gt;</code></p>
<p>注释为 <code>&lt;!-- xxx --&gt;</code></p>
<h3 id="1-3-行元素与行内元素"><a href="#1-3-行元素与行内元素" class="headerlink" title="1.3 行元素与行内元素"></a>1.3 行元素与行内元素</h3><p><strong>行元素</strong>就是单独占一行的标签，也就是后面再有标签去要到下一行去！咱们看看都有谁这么霸道，不要脸：标题标签 <code>h</code>（标题嘛，情有可原）；段落标签 <code>p</code> （凑合着也说的过去）；<code>div</code> 标签（这个东西就把它理解成容器吧，毕竟它没有语义，中性的很～）</p>
<p><strong>行内元素</strong>就是老实人，只占自己的位置。元素之间可以排开（设置宽高是无效的，它的宽和高是由内容撑开的）。这些老实人都有谁呢？图片标签 <code>img</code>  和通用内联容器标签 <code>span</code> 以及超链接标签  <code>a</code></p>
<h3 id="1-4-布局"><a href="#1-4-布局" class="headerlink" title="1.4 布局"></a>1.4 布局</h3><p>不想做将军的士兵，不是好士兵。论谋略、论布局，咱也有一手。</p>
<p><strong>口诀</strong>是：先行后列、先整体再局部、先大后小</p>
<p>即先按照行的方式，将页面整体分开，再给每一行进行内容填充。</p>
<h2 id="2-CSS"><a href="#2-CSS" class="headerlink" title="2.CSS"></a>2.CSS</h2><p>化妆师 CSS 就是美容整形专家了，它控制着 html 的美与丑。</p>
<blockquote>
<p>它有个名字叫做 层叠样式表</p>
</blockquote>
<h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">  属性: 值;</span><br><span class="line">  ...</span><br><span class="line">  属性: 值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择器下面会大幅介绍，所以不要担心。属性和值嘛就很简单，比如字体颜色是红色，字体是仿宋，想起了被论文支配的恐惧 …</p>
<h3 id="2-2-选择器"><a href="#2-2-选择器" class="headerlink" title="2.2 选择器"></a>2.2 选择器</h3><p>选择器其实并不复杂，它就是选择内容，然后为其添加样式，如何准确的选择要加样式的内容呢？就依靠下列选择器啦。</p>
<h4 id="2-2-1-标签选择器"><a href="#2-2-1-标签选择器" class="headerlink" title="2.2.1 标签选择器"></a>2.2.1 标签选择器</h4><p>这是最简单的选择器，直接选择标签，其影响范围之广可想而之，所以大型项目里面可是很少使用的，慎用！</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">color</span>: red&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-类选择器"><a href="#2-2-2-类选择器" class="headerlink" title="2.2.2 类选择器"></a>2.2.2 类选择器</h4><p>类这个字从何而来呢？它其实是根据标签的一个 <code>class</code> 属性命名的。多个标签想要渲染同样的效果，可设置相同的类。然后根据类名来选择元素即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.newbox</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-层级选择器"><a href="#2-2-3-层级选择器" class="headerlink" title="2.2.3 层级选择器"></a>2.2.3 层级选择器</h4><p>层级选择器则是依据标签的层级结果，即嵌套格式进行选择。它可以结合标签选择器与类选择器来一同使用。</p>
<p>比如有个 html 结构如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"new"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为 <code>span</code> 标签加个颜色：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.con</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-id-选择器"><a href="#2-2-4-id-选择器" class="headerlink" title="2.2.4 id 选择器"></a>2.2.4 id 选择器</h4><p>id 为标签的名字。在数据库中 id 一般为唯一键，此处同理。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#box</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5-组选择器"><a href="#2-2-5-组选择器" class="headerlink" title="2.2.5 组选择器"></a>2.2.5 组选择器</h4><p>组选择器便是选择一组内容，为其统一添加样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>,<span class="selector-class">.box8</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-6-伪类选择器"><a href="#2-2-6-伪类选择器" class="headerlink" title="2.2.6 伪类选择器"></a>2.2.6 伪类选择器</h4><p>有一个常用的伪类选择器，它就是 hover ，表示鼠标悬浮于元素上时的状态。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-盒子模型"><a href="#2-3-盒子模型" class="headerlink" title="2.3 盒子模型"></a>2.3 盒子模型</h3><p>提到前端，不得不提到一个东西，那便是盒子模型。也就是浏览器中常看到的下列图片：</p>
<img src="https://github.com/EthanYan6/pic/raw/master/%E6%AD%BB%E7%A3%95%E5%89%8D%E7%AB%AFing%EF%BD%9E/Snipaste_2019-12-07_15-33-11.png" alt="哟，老弟？什么年代了，网速还加载不出我的图片啊？换光纤吧！此处为盒子模型图片" style="zoom:50%;">

<p>盒子模型主要还是为了理解如下几个概念而形象化的东西。</p>
<p>前一段时间在淘宝买了个毛绒玩具（蓝胖子），收到快递，在拆解过程中：</p>
<p>1.width 装玩具的盒子的宽度</p>
<p>2.height 装玩具的盒子的宽度</p>
<p>3.border 装玩具的盒子的厚度</p>
<p>4.padding 玩具和盒子之间的距离（蓝胖子不能压瘪，要不然差评，所以它被保护的很好）</p>
<p>5.margin 我快递盒子和放快递的大盒子之间的距离</p>
<p>有个现象是，当盒子的长和宽固定后， border 和 padding 增加，都会改变整体的尺寸，为什么呢？</p>
<p>因为 padding 增加后（即玩具和盒子之间的填充泡沫太多了）盒子被撑大了；border 增加后（商家比较有良心，换了个特厚实的盒子），所以快递变大了。</p>
<h3 id="2-4-常用属性"><a href="#2-4-常用属性" class="headerlink" title="2.4 常用属性"></a>2.4 常用属性</h3><p>1.width 设置标签的宽</p>
<p>2.height 设置标签的高</p>
<p>3.background 设置标签的背景色</p>
<p>4.border 设置边框线：border-top 即上边框；同理其他为 border-left、border-right 和 border-bottom</p>
<p>5.padding 设置元素内容与边框间的距离（即蓝胖子和快递盒之间的距离）</p>
<p>6.margin 设置元素和外界的距离</p>
<p>7.float 设置元素浮动</p>
<p>8.color 设置文字颜色</p>
<p>9.font-size 设置文字大小</p>
<p>10.font-family 设置文字字体</p>
<p>11.font-weight 设置是否加粗</p>
<p>12.line-height 设置行高</p>
<p>13.text-decoration 设置文字下划线</p>
<p>14.text-align 设置文字水平对齐方式</p>
<p>15.text-indent 设置文字首行缩进</p>
<blockquote>
<p>css 中的注释为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* xxx */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>16.display 设置元素的类型与隐藏。（none 为隐藏；inline 为行内元素；block 为块元素）</p>
<p>17.overflow 设置元素溢出时的动作。（visible 为内容会难看的被显示在元素框外，溢出；hidden 去掉超出的内容，只显示元素框内内容；scroll 则是现实滚动条，可以上下滚动显示全部内容；auto 则是如果内容超出去才会显示滚动条）</p>
<h3 id="2-5-定位"><a href="#2-5-定位" class="headerlink" title="2.5 定位"></a>2.5 定位</h3><h4 id="2-5-1-绝对定位"><a href="#2-5-1-绝对定位" class="headerlink" title="2.5.1 绝对定位"></a>2.5.1 绝对定位</h4><p>找一个参照物来固定元素本身，优先去查找上一个设置了定位的元素，没有的话就是 body 了。然后根据它固定位置，脱离文档流</p>
<h4 id="2-5-2-相对定位"><a href="#2-5-2-相对定位" class="headerlink" title="2.5.2 相对定位"></a>2.5.2 相对定位</h4><p>设置相对定位的元素，一般设置父级相对定位，而子集绝对定位。</p>
<h4 id="2-5-3-固定定位"><a href="#2-5-3-固定定位" class="headerlink" title="2.5.3 固定定位"></a>2.5.3 固定定位</h4><p>以浏览器窗口为参照物，脱离文档流，以不变应万变。</p>
<blockquote>
<p>文档流就是那些标签，它们按照顺序从上往下，从左到右的排列着，当然符合块元素与行内元素的特性。脱离文档流就是飘起来了，它们怎么排列，不受文档流的影响。</p>
</blockquote>
<h3 id="2-6-权重"><a href="#2-6-权重" class="headerlink" title="2.6 权重"></a>2.6 权重</h3><p>CSS 的权重是衡量显示样式的优先级。权重值大的优先显示，如果权重值相同，后写的样式会覆盖掉前面的样式。</p>
<p>1.内联样式权重值最高，毕竟是标签的一部分，亲人嘛。权重值为 1000</p>
<p>2.ID 选择器仅次于内联样式，权重值为 100</p>
<p>3.类和伪类选择器权重值为 10</p>
<p>4.标签选择器权重值为 1</p>
<h2 id="3-Javascript"><a href="#3-Javascript" class="headerlink" title="3.Javascript"></a>3.Javascript</h2><p>希望看到这里，你还有耐心读下去。如果看不下去了，就先收藏一下，去喝杯水，休息一会。</p>
<p>Javascript 也是一种弱类型的语言，它的变量类型不像 Java、C 等需要提前声明，而是由赋的值类型决定，你给我个整数，我就是数字类型。</p>
<p>它定义变量的<strong>语法</strong>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">666</span></span><br><span class="line"><span class="keyword">var</span> sTr = <span class="string">'Ethan Yan'</span></span><br></pre></td></tr></table></figure>

<p>当然你也可以偷懒，多个变量定义，只用一个 <code>var</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">666</span>,sTr=<span class="string">'Ethan Yan'</span></span><br></pre></td></tr></table></figure>

<p>同时它有 <strong>5 种基本数据类型</strong>：</p>
<p>1.number</p>
<p>2.string</p>
<p>3.boolean</p>
<p>4.undefined</p>
<p>5.null</p>
<p>还有一种<strong>复合类型</strong>：object</p>
<p>它不严格缩进，全凭自己喜好，因为它的<strong>语句都以封号结尾</strong>，不像 python 一样，缩进错误疯狂报错。</p>
<p>它的注释如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	xxx</span></span><br><span class="line"><span class="comment">	多行注释</span></span><br><span class="line"><span class="comment">	xxx</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>然后就是<strong>命名规范</strong>，毕竟你定义 xxx 没人能够理解。</p>
<p><strong>变量、函数、属性、函数参数命名规范</strong>：</p>
<p>1.区分大小写</p>
<p>2.第一个字符必须是字母，下划线或者美元符号。（千万别以数字开头命名了，我真的很奇怪，总是有人以数字开头命名）</p>
<p>3.其他字符可以是字母、下划线、美元符号和数字</p>
<p>还有一种比较美观的命名方式，大家可以借鉴一下，那就是<strong>匈牙利命名风格</strong>：</p>
<p>1.如果是对象（Object）就写为：oDiv</p>
<p>2.如果是数组（Array）就写为：aItems</p>
<p>3.如果是浮点数（Float）就写为：fPrice</p>
<p>规律即：变量类型小写首字母加上变量名</p>
<h3 id="3-1-函数"><a href="#3-1-函数" class="headerlink" title="3.1 函数"></a>3.1 函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnAlert</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数执行</span></span><br><span class="line">fnAlert()</span><br></pre></td></tr></table></figure>

<p>上面的函数就是弹出一句话 <code>hello!</code></p>
<p>如果想给函数传参数，则可以使用如下方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnAlert</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  alert(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">alert(<span class="number">222222</span>)</span><br></pre></td></tr></table></figure>

<p>具有返回值的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnAdd</span>(<span class="params">iNum01,iNum02</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> iRs = iNum01 + iNum02;</span><br><span class="line">  <span class="keyword">return</span> iRs;</span><br><span class="line">  alert(<span class="string">'complete!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iCount = fnAdd(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">alert(iCount); <span class="comment">// 弹出7</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-1-变量和函数的预解析"><a href="#3-1-1-变量和函数的预解析" class="headerlink" title="3.1.1 变量和函数的预解析"></a>3.1.1 变量和函数的预解析</h4><p>1.js <strong>底层解析过程</strong>分为两个阶段，那就是编译阶段和执行阶段。所以会发生一件有意思的事情，那就是你在定义一个函数之前，调用这个函数，同样执行正确。为什么？因为编译阶段已经将函数定义过了。（是不是很不可思议）</p>
<p>2.变量如果先调用再定义，为什么不回出现相同的现象？因为变量在编译阶段，会先将其赋值为 undefined 类型，所以先使用变量，再声明变量也不会报错，但是会得到一个 undefined 类型的变量。</p>
<h3 id="3-2-条件语句"><a href="#3-2-条件语句" class="headerlink" title="3.2 条件语句"></a>3.2 条件语句</h3><h4 id="3-2-1-if-else"><a href="#3-2-1-if-else" class="headerlink" title="3.2.1 if-else"></a>3.2.1 if-else</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> iNum2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> sTr;</span><br><span class="line"><span class="keyword">if</span>(iNum1&gt;iNum2)&#123;</span><br><span class="line">  sTr = <span class="string">'大于'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  sTr = <span class="string">'小于'</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(sTr);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-if-elseif-else"><a href="#3-2-2-if-elseif-else" class="headerlink" title="3.2.2 if-elseif-else"></a>3.2.2 if-elseif-else</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">  xxx;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">  xxx;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-获取元素方式"><a href="#3-3-获取元素方式" class="headerlink" title="3.3 获取元素方式"></a>3.3 获取元素方式</h3><p>如果一个元素定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"div1"</span>&gt;这是一个div元素&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>想要获取该元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意获取到的变量是一个对象，并不是值。想要取值，使用<code>oDiv.innerHTML</code> 即可做到</p>
</blockquote>
<p>对了，写 js 时，有一个问题需要注意：</p>
<p>如果 script 标签内容（要获取某一个元素的值）在元素之前，那么获取不到，因为未被声明（代码从上往下执行，而且得到的结果不是 undefined 而是 null）。如果你非要这么变态的写，当然也有办法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">'div2'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>window.onload</code> 函数会在页面加载完之后执行，所以你将你的变态代码扔进去，js 写在哪里都正确。</p>
<h3 id="3-4-操作元素的属性"><a href="#3-4-操作元素的属性" class="headerlink" title="3.4 操作元素的属性"></a>3.4 操作元素的属性</h3><p>语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 = 元素.属性名  <span class="comment">// 读取属性</span></span><br><span class="line">元素.属性名 = 新属性值   <span class="comment">// 改写属性</span></span><br></pre></td></tr></table></figure>

<p>读取属性名时的属性名写法可有些讲究了：</p>
<p>1.普通属性，即 html 中的属性，直接写就完事了</p>
<p>2.class 类属性需要改写。如：className</p>
<p>3.style 属性有横杠的也需要改写。如 font-size 改写为 .fontSize</p>
<h3 id="3-5-事件属性以及匿名函数"><a href="#3-5-事件属性以及匿名函数" class="headerlink" title="3.5 事件属性以及匿名函数"></a>3.5 事件属性以及匿名函数</h3><h4 id="3-5-1-事件属性"><a href="#3-5-1-事件属性" class="headerlink" title="3.5.1 事件属性"></a>3.5.1 事件属性</h4><p>大家经常进行的鼠标点击、鼠标移入、鼠标移出都就是事件属性。我们可以通过将函数名赋值给元素事件属性的方式将事件和函数关联起来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oBtn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"></span><br><span class="line">oBtn.onclick = myalert;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myalert</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'ok!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-2-匿名函数"><a href="#3-5-2-匿名函数" class="headerlink" title="3.5.2 匿名函数"></a>3.5.2 匿名函数</h4><p>js 中匿名函数很好写，我们改写上一段代码为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oBtn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意下面写法</span></span><br><span class="line">oBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'ok!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-数组及操作方法"><a href="#3-6-数组及操作方法" class="headerlink" title="3.6 数组及操作方法"></a>3.6 数组及操作方法</h3><p>如同 python 中的列表，定义数组可以有下面两种方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aList = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> aList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组的长度</span></span><br><span class="line">alert(aList.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用下标取出数组的0号数据</span></span><br><span class="line">alert(aList[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组成员通过一个分隔符合并成字符串</span></span><br><span class="line"><span class="comment">// 弹出 1-2-3</span></span><br><span class="line">alert(aList.join(<span class="string">'-'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组最后增加成员3</span></span><br><span class="line">aList.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组最后删除成员</span></span><br><span class="line">aList.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组反转</span></span><br><span class="line">aList.reverse();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组中元素第一次出现的1的索引值</span></span><br><span class="line">aList.indexOf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第2个元素开始，删除1个元素，然后在此位置增加'7,8,9'三个元素</span></span><br><span class="line">aList.aplice(<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-7-循环语句"><a href="#3-7-循环语句" class="headerlink" title="3.7 循环语句"></a>3.7 循环语句</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 0 开始，只要 i 小于 len 就会一直执行，没执行一次代码，i 进行加 1 操作。</p>
<h3 id="3-8-字符串相关方法"><a href="#3-8-字符串相关方法" class="headerlink" title="3.8 字符串相关方法"></a>3.8 字符串相关方法</h3><p>1.直接用 <code>+</code> 进行拼接操作</p>
<p>2.parseInt() 将数字字符串转化为整数</p>
<p>3.parseFloat() 将数字字符串转化为小数</p>
<p>4.split() 把一个字符串分隔成字符串组成的数组</p>
<p>5.indexOf() 查找字符串是否含有某字符</p>
<p>6.substring() 截取字符串 </p>
<blockquote>
<p>用法： substring(start,end)（不包括end）</p>
</blockquote>
<p><strong>字符串反转</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str = &apos;asdfj12jlsdkf098&apos;;</span><br><span class="line">var str2 = str.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line"></span><br><span class="line">alert(str2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先转化成数组，再利用数组的反转方法即可实现</p>
</blockquote>
<h3 id="3-9-定时器"><a href="#3-9-定时器" class="headerlink" title="3.9 定时器"></a>3.9 定时器</h3><p>setTimeout  只执行一次的定时器 </p>
<p>clearTimeout 关闭只执行一次的定时器</p>
<p>setInterval  反复执行的定时器</p>
<p>clearInterval 关闭反复执行的定时器</p>
<h3 id="3-10-封闭函数"><a href="#3-10-封闭函数" class="headerlink" title="3.10 封闭函数"></a>3.10 封闭函数</h3><p>封闭函数的三种写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>其实也属于匿名函数，即创建完函数立即调用，省略了函数名。</p>
<p>当然它并不是没事干，定义这么个东西好玩儿，它是为了防止命名冲突。</p>
<blockquote>
<p>封闭函数可以创造一个独立的空间，在封闭函数内定义的变量和函数不会影响外部同名的函数和变量，可以避免命名冲突，在页面上引入多个js文件时，用这种方式添加js文件比较安全.</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>MacBook Pro你真的会使用吗？</title>
    <url>/2019/11/17/MacBookPro%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
那些不使用鼠标的人是否是打肿脸充胖子？因囊中羞涩而安装的xx软件装不上怎么办？MacBook Pro真的那么好用吗？下面为您解答

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>经过不懈的努力，小闫同学终于使用上了 MacBook Pro，先小小的炫耀一番。（不要打我哈~）</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/MacBookPro%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F/IMG_0212.jpg" alt="小闫同学的 MacBook Pro"></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/MacBookPro%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F/IMG_0211.jpg" alt="小闫同学的 MacBook Pro"></p>
<p>激动的心，颤抖的手，打开了笔记本才发现我是个弟弟，怎么用？经过了一番研究，将电脑弄死好几次的探索，终于入了门。分享给大家吧。</p>
<p>首先 macOS 是类 Linux 系统，因此会命令的童鞋超级好上手。其次，都说Mac 可以提高生产力，可以解放鼠标，怎么做到的呢？那就是超级丰富的快捷键以及非常大块且灵敏的触摸板的功劳了。</p>
<p>一拿到手，第一件事请将触摸板设置成 <strong>tap to click（单击）</strong>。设置方式为依次点击如下按钮：左上角的苹果logo -&gt; System Preferences -&gt; trackpad -&gt; 勾选 tap to click。（这样就不需要点按触摸板了）</p>
<p>第二件事请打开 <strong>three finger drag （三指拖拽）</strong>功能。设置方式如下：左上角的苹果logo -&gt; System Preferences -&gt; Accessibility -&gt; Pointer control -&gt; 点击右方左下角的 trackpad options -&gt; 勾选 enable dragging -&gt; 选择 three finger drag。</p>
<p>第三件事请设置 <strong>Hot corners （触摸角功能）</strong>。设置方式如下：在桌面任意位置鼠标右键（或者触摸板双指触碰一下）-&gt; change desktop background -&gt; screen saver -&gt; Hot corners。我将右下角设置为了 Lock Screen ，只要鼠标往右下角一划或者在触摸板上往右下角一划即可锁屏走人。</p>
<p>这都是一些简单但是非常提高效率设置，那么 Mac 上是如何提高生产力的呢？光这些可不够，下面再介绍一些常用操作。</p>
<p>在 Mac 上面，command 键等同于 Windows 上的 control 键，所以复制粘贴你懂得 ~ 下面快来学习一些 Mac 的小知识吧！</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>1.快速将当前窗口最大化： </p>
<p><code>control + command + F</code></p>
<p>再次按上述快捷键即可恢复原样 </p>
<p>2.快速将当前窗口最小化： </p>
<p><code>command + M</code></p>
<blockquote>
<p>如果当前窗口处于最大化状态，那么此命令无效 </p>
</blockquote>
<p>3.快速将最小化的窗口调出来： </p>
<p>​    3.1 先使用如下快捷键，打开所有的应用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command + tab</span><br></pre></td></tr></table></figure>

<p>​    3.2 按住 command 键不松开，按 tab 键向后选择，按 shift + tab 键向前选择</p>
<p>​    3.3 选中图标之后按住 option 键，松开 command 键即可打开应用</p>
<p>4.类似 home 键和 end 键的快捷操作：</p>
<p>​    4.1 快速移动到行首：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">control + A</span><br></pre></td></tr></table></figure>

<p>​    4.2 快速移动到行尾：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">control + E</span><br></pre></td></tr></table></figure>

<p>​    4.3 到下一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">control + N</span><br></pre></td></tr></table></figure>

<p>​    4.4 到上一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">control + P</span><br></pre></td></tr></table></figure>

<p>​    4.5 从光标处开始删除，知道行尾：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">control + K</span><br></pre></td></tr></table></figure>



<h2 id="安装软件出现文件已损坏"><a href="#安装软件出现文件已损坏" class="headerlink" title="安装软件出现文件已损坏"></a>安装软件出现文件已损坏</h2><p>1.关闭软件，点击取消，先别着急移到废纸篓 </p>
<p>2.输入如下命令，开启安装任何应用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure>

<p>3.如果是10.15的新系统，有可能还是失败，那么输入如下命令即可解决： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xattr -cr /Applications/MindNode.app</span><br></pre></td></tr></table></figure>

<p>​    3.1 上方的命令是先输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xattr -cr</span><br></pre></td></tr></table></figure>

<p>​    3.2 然后将损坏的应用图标拖到终端命令后，按回车即可 </p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>快捷键</tag>
        <tag>MacBook Pro</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab 执行python脚本不生效？（续）</title>
    <url>/2019/11/17/%E6%89%A7%E8%A1%8Cpython%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
Linux 设置定时任务，crontab 执行 python 脚本不生效的问题：
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>尝试方法：</p>
<p>1.给 python 脚本第一行添加如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然 python 解释器的路径要按照自己情况进行填写。</p>
</blockquote>
<p>2.如果 python 脚本报错，模块未找到等等，尝试如下方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">'xxx&lt;第三方模块的路径&gt;'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是虚拟环境，有可能此路径不同，可以通过下列命令查看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> elasticsearch</span><br><span class="line">&gt;elasticsearch.__file__</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后将路径复制到 <code>sys.path.append(&#39;&#39;)</code> 中的引号即可，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D:\\E\\python_virtual\\fbl5n\\lib\\site-packages</span><br></pre></td></tr></table></figure>
<p>3.python 脚本中不涉及复杂的逻辑，简单的函数即函数调用即可，如果出现下列代码，请去掉：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br></pre></td></tr></table></figure>
<p>它会将 crontab 在调用的时候搞晕。</p>
<p>4.可以写一个 shell 脚本去调用 python 脚本，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/bash</span></span><br><span class="line">cd /opt</span><br><span class="line">/usr/bin/python3 mail_reminder.py &gt;&gt; log.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>0 表示stdin标准输入<br>1 表示stdout标准输出<br>2 表示stderr标准错误<br>&amp; 表示等同于的意思<br>2&gt;&amp;1 表示2的输出重定向等同于1</p>
</blockquote>
<p>5.当报错编码问题时可以尝试使用如下方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/bash </span></span><br><span class="line">cd /opt </span><br><span class="line">PYTHONIOENCODING=utf-8 /usr/bin/python3 mail_reminder.py &gt;&gt; log.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
        <tag>crontab</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>bat脚本常用命令</title>
    <url>/2019/11/14/bat%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<center>Author：闫玉良</center>
bat 脚本？如果不是从事微软开发相关工作的人员，是不是感觉很耳熟但是又好像不熟悉？还等什么，一睹为快

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>bat 脚本是 windows 上所用的脚本，我们经常使用的 cmd 一些命令就可以使用。也许你会说为什么不使用 powershell 脚本？因为古老的一些服务器上面没有安装 powershell 你信不信？比如 windows server 2003。</p>
<p>很荣幸，我遇到了，没有什么办法，只能查阅相关资料迎难而上了！脚本其实很简单，下面做一个记录，供大家有需要时获取：</p>
<h4 id="1-设置变量"><a href="#1-设置变量" class="headerlink" title="1.设置变量"></a>1.设置变量</h4><p>设置变量使用 <code>SET</code> 关键字，语法如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">SET 变量名=变量值</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.<strong>变量名与变量值一定要紧挨等于号！！！</strong>否则报错到怀疑人生。</p>
<p>2.变量值如果是个字符串，直接写内容，不需要加双引号。（是不是很方便）</p>
</blockquote>
<h4 id="2-使用变量"><a href="#2-使用变量" class="headerlink" title="2.使用变量"></a>2.使用变量</h4><p>使用变量时语法如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">%变量名%</span><br></pre></td></tr></table></figure>

<h4 id="3-判断语句"><a href="#3-判断语句" class="headerlink" title="3.判断语句"></a>3.判断语句</h4><p>判断语句必不可少，if … else… 语法如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件 (</span><br><span class="line">	条件成立执行内容</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">	条件不成立执行内容</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="4-回显"><a href="#4-回显" class="headerlink" title="4.回显"></a>4.回显</h4><p>类似于 python 中的 print 函数，即将后方的内容打印输出：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">echo 我就是要回显的内容</span><br></pre></td></tr></table></figure>

<h4 id="5-创建文件夹"><a href="#5-创建文件夹" class="headerlink" title="5.创建文件夹"></a>5.创建文件夹</h4><p>创建目录你还在想 <code>mkdir</code> 的时候，windows 已经考虑简化了：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">md 文件夹路径</span><br></pre></td></tr></table></figure>

<blockquote>
<p>之所以写文件夹路径，是因为可以创建嵌套目录啊！不需要任何参数，简单不简单？</p>
</blockquote>
<h4 id="6-输出内容到文件"><a href="#6-输出内容到文件" class="headerlink" title="6.输出内容到文件"></a>6.输出内容到文件</h4><p>大家如果熟悉 Linux 系统，那么对于重定向命令一定很熟悉了，bat 脚本完全一样，如果是创建一个文件，或者已有文件覆盖内容的话，可以使用 <code>&gt;</code> 命令；如果是要往加过里面追加内容的话，直接使用 <code>&gt;&gt;</code> 即可。示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo test content &gt; C:\test\test.txt</span><br></pre></td></tr></table></figure>

<h4 id="7-关闭系统信息回显"><a href="#7-关闭系统信息回显" class="headerlink" title="7.关闭系统信息回显"></a>7.关闭系统信息回显</h4><p>我们在执行脚本的时候，系统会执行 N 多步可知，不可知的步骤，因此会输出大量的信息，如果只想看自己回显的信息呢？可以使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要再文件的开头书写</p>
</blockquote>
<h4 id="8-标题"><a href="#8-标题" class="headerlink" title="8.标题"></a>8.标题</h4><p>小黑窗口左上角的字该怎么改呢？看下方：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@title monitoring_log by EthanYan</span><br></pre></td></tr></table></figure>

<h4 id="9-其他"><a href="#9-其他" class="headerlink" title="9.其他"></a>9.其他</h4><p>如果你看其他人写的脚本，也许会在文件开头看到这样一句：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mode con lines=5 cols=40</span><br></pre></td></tr></table></figure>

<p>它是设置显示内容的小黑窗口大小的命令。lines 指的是高，cols 指宽度。</p>
]]></content>
      <categories>
        <category>windows</category>
        <category>script</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title>python 字符串前面的那些特殊字符</title>
    <url>/2019/11/04/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E9%9D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<center>Author：闫玉良</center>
对于 Python 的字符串大家并不陌生，引号引用即为字符串。那么字符串前面经常加的一些特殊字母就让初学者懵逼了，今天我们就来详细讲一下 ......

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-u"><a href="#1-u" class="headerlink" title="1.u"></a>1.u</h2><p>作为程序员，看到 <code>u</code> 字符，首先想到的便是 <code>Unicode</code> 这个单词。没错，它确实也代表此含义。目的是告知后面字符串采用 <code>Unicode</code> 编码格式，应用对象自然是容易出现问题的<strong>中文字符串</strong>。</p>
<p>有时我们存储完成后，再次取用发现格式不一致，或者显示乱码等问题，使用 <code>u</code> 便很好解决了。</p>
<h2 id="2-f"><a href="#2-f" class="headerlink" title="2.f"></a>2.f</h2><p>这个字符经常看到，不知你是否还注意到一个现象，那便是出现此字符的字符串，字符串中必定会有大括号。哈哈，忘记也没有关系，要不然我讲什么呢？</p>
<p>此字符代表的是在后面字符串中可以使用大括号（大括号中可以使用 <code>python</code> 表达式）。如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">f"testfile-<span class="subst">&#123;str(time.time()).replace(<span class="string">'.'</span>,<span class="string">''</span>)&#125;</span>.txt"</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">testfile<span class="number">-15728489624240513.</span>txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样我们在字符串中就可以随心所欲的使用任何表达式，不再通过 <code>+</code> 拼接各种字符串了。</p>
</blockquote>
<h2 id="3-r"><a href="#3-r" class="headerlink" title="3.r"></a>3.r</h2><p><code>r</code> 这个字符是否更眼熟了？没错，在学习正则表达式时，大家都见过。此字符含义与其相同，代表将字符串中各种特殊符号进行转义，字符串中内容 <code>所见即所得</code> 。比如 ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">r'你好：\n您的快递'</span></span><br></pre></td></tr></table></figure>

<p>其中的 <code>\n</code> 不再表示换行符，而是反斜杠加字母 <code>\n</code></p>
<h2 id="4-b"><a href="#4-b" class="headerlink" title="4.b"></a>4.b</h2><p>这个字符就更常见了，它表示 <code>bytes</code> 类型。它可以与字符串类型相互转换，使用 <code>encode</code> 与 <code>decode</code>。</p>
<h3 id="bytes-gt-string"><a href="#bytes-gt-string" class="headerlink" title="bytes -&gt; string"></a>bytes -&gt; string</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">by = <span class="string">b'test'</span></span><br><span class="line">by.decode(<span class="string">'utf8'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="string-gt-bytes"><a href="#string-gt-bytes" class="headerlink" title="string -&gt; bytes"></a>string -&gt; bytes</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">'test'</span></span><br><span class="line">str.encode(<span class="string">'utf8'</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab定时执行python脚本不成功解决方案</title>
    <url>/2019/10/31/crontab%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8Cpython%E8%84%9A%E6%9C%AC%E4%B8%8D%E6%88%90%E5%8A%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
目前有一个需求是定时执行某个 python 脚本，但是在 Linux 上设置 crontab 后，不生效？手动执行生效？于是使用下面的方法执行即可：

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>大体思路为先写一个 <code>shell</code> 脚本，脚本中执行 <code>python</code> 文件，然后定时执行 <code>shell</code> 脚本即可。具体原因不明，正在探索中 …… 目前只提供一种解决方案。</p>
<p>1.使用如下命令创建脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi start.sh</span><br></pre></td></tr></table></figure>

<p>2.然后在 <code>start.sh</code> 脚本中结合本身情况输入内容，示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/bash</span></span><br><span class="line">cd /opt</span><br><span class="line">/usr/bin/python3 /opt/test_mail.py</span><br></pre></td></tr></table></figure>

<p>3.然后使用如下命令，编辑定时任务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<p>4.假如设定每天 8 点执行脚本，设置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 8 * * * /opt/start.sh</span><br></pre></td></tr></table></figure>

<p>5.保存定时任务，几分钟后自动生效。</p>
<blockquote>
<p><strong>注意</strong>：所有的路径都使用<strong>绝对路径</strong>，否则仍然无效。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
        <tag>crontab</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>python导入导出pip环境中所有模块</title>
    <url>/2019/10/28/python%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BApip%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%89%80%E6%9C%89%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
刚入职接手项目，python 环境如何搭建？项目依赖模块如何安装？备份环境时如何将所有 pip 安装的模块导出？请看下文

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>导出所有模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip freeze &gt;requirements.txt</span><br></pre></td></tr></table></figure>

<p>导入所有模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：执行此命令时<strong>需要联网</strong>，其原理还是依次对文件中每一个模块进行 <code>pip install</code></p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python后端面试汇总</title>
    <url>/2019/10/28/Python%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
只身打入敌人内部，亲身经历，题目汇总，亲情大奉献，请点击以下链接观看：

<p><a href="http://mp.weixin.qq.com/mp/homepage?__biz=Mzg3NTA0OTM1OQ==&hid=8&sn=811ae175b0ce7f4208d0a3bea3157ac0&scene=18#wechat_redirect" target="_blank" rel="noopener">python面试题大汇总</a></p>
<a id="more"></a>









<p>点进来干什么，题目全在链接里面了 ~ </p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo命令速查小册</title>
    <url>/2019/10/27/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
最近都在搭建自己的博客，不断的调整显示效果，以及添加一些初始功能，总算大体框架完成，细枝末节尚待商榷。小闫同学的博客地址为  http://www.pythonnote.cn/  ，希望大家多多捧场 ~ 当然也希望大家多多关注公众号『全栈技术精选』

<p>先来几张效果图压场，deng ~ deng ~ dengdeng</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/blog1.png" alt></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/blog2.png" alt></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/blog3.png" alt></p>
<p>前端超牛逼的效果有没有感动到 ~ 这当然不是我自己做的，还要感谢 Jonathan Klughertz</p>
<p>如果认为这篇文章要教如何搭建个人博客，那就让你失望了，因为百度上面相关教程太多太多，我不认为自己写的比其他人更详细更好。只是给大家指引一下方向即可。</p>
<p>搭建博客的过程中使用到了框架 Node.js、HEXO 以及 GitHub 。</p>
<p>下面就经常使用到的 hexo 的命令做一个总结，方便在使用过程中快速查阅。</p>
<h4 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo n "article name"</span><br><span class="line">或者</span><br><span class="line">hexo new "article name"</span><br></pre></td></tr></table></figure>

<h4 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>其实上述为 3 个命令，为了节省时间，我经常联合使用。</p>
<blockquote>
<p>hexo clean 清除缓存</p>
<p>hexo g 生成静态页面（generate）</p>
<p>hexo d 部署（deploy）</p>
</blockquote>
<h4 id="本地效果预览"><a href="#本地效果预览" class="headerlink" title="本地效果预览"></a>本地效果预览</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<blockquote>
<p>s 为 server 的简写，因此你也可以写成 hexo server。hexo 的命令大多都是如此</p>
</blockquote>
<h4 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h4><p>首页会根据分页效果展示文章，如果不设置摘要，文章会拉长页面篇幅。</p>
<p>我们只需要在文章摘要后添加一行内容即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<p>最后效果图为：</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/blog4.png" alt></p>
<h4 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h4><p>先执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page "tags"</span><br></pre></td></tr></table></figure>

<p>再在目录 <code>source/tags/index.md</code> 中添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-05-27 13:47:40</span><br><span class="line">type: "tags"</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>最后只需要在写文章时添加 <code>tags</code> 属性即可。</p>
<p>如果只添加一个标签：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tags: test</span><br></pre></td></tr></table></figure>

<p>多标签，文章开头添加：（yaml语法）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line">- test1</span><br><span class="line">- test2</span><br><span class="line">- test3</span><br></pre></td></tr></table></figure>

<h4 id="添加文章分类目录"><a href="#添加文章分类目录" class="headerlink" title="添加文章分类目录"></a>添加文章分类目录</h4><p>添加分类如同标签一样，只需要将 <code>tags</code> 换成 <code>categories</code> 即可，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page "categories"</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>如下形式，同篇文章添加多个目录和标签：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">数据结构</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">数据结构</span></span><br></pre></td></tr></table></figure>

<p><strong>同篇文章添加多个目录和标签时，请将与其他文章共同的目录放置在前面，优先级高一些。</strong>比如，文章A归为目录算法和机器学习下，文章B归为目录算法和数据结构下。他们在划分目录时，需如下填写：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章A</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">机器学习</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章B</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">数据结构</span></span><br></pre></td></tr></table></figure>

<p>如果先写各自不同的目录，再写共同目录时，会在前端目录展示页面中出现重复目录。因为框架在创建目录时，会按如下形式创建表示目录的文件夹，以上述例子示范：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">算法</span></span><br><span class="line"><span class="string">├──</span> <span class="string">机器学习</span></span><br><span class="line"><span class="string">└──</span> <span class="string">数据结构</span></span><br><span class="line"><span class="comment"># 框架会先创建一个算法的文件夹，然后在算法文件夹下创建两个其他文件夹，这样避免目录重复</span></span><br></pre></td></tr></table></figure>

<p>如果在目录填写时按如下情况：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章A</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">机器学习</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章B</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">数据结构</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br></pre></td></tr></table></figure>

<p>框架在生成目录时：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">机器学习</span></span><br><span class="line"><span class="string">└──</span> <span class="string">算法</span></span><br><span class="line"></span><br><span class="line"><span class="string">数据结构</span></span><br><span class="line"><span class="string">└──</span> <span class="string">算法</span></span><br><span class="line"><span class="comment"># 框架会先生成每篇文章中各自不同的目录，然后在其下创建算法目录，造成重复</span></span><br></pre></td></tr></table></figure>

<p>框架在生成目录时，会优先创建写在首位的目录，再创建写在后面为止的目录，所以在展示所有的目录时，会出现重复的两个 <code>算法</code> 目录。</p>
<h4 id="文章中插入图片"><a href="#文章中插入图片" class="headerlink" title="文章中插入图片"></a>文章中插入图片</h4><p>如果在 Markdown 中直接插图，再转成静态页面时，路径会找不到，导致图片无法正常显示。解决办法有很多，我最喜欢的便是利用 GitHub 新建一个放置图片的仓库（当然很多人使用七牛云也很方便），然后在文章中使用插入连接的方式插入图片即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">![](https://github.com/EthanYan6/pic/raw/master/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/blog1.png)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>连接地址利用以下步骤获取：打开GitHub图片仓库后，看到 Download 按钮，右键复制链接</p>
</blockquote>
<h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p>大家首先需要去腾讯云或者阿里云购买一个域名，然后备案，再通过解析绑定个人博客地址。百度教程超详细，不过多阐述</p>
<p>命令暂且总结到此，预知后事如何，且听下回分解 ~</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch 中这些必备 API 你晓得嘛？</title>
    <url>/2019/10/25/Elasticsearch%20%E4%B8%AD%E8%BF%99%E4%BA%9B%E5%BF%85%E5%A4%87%20API%20%E4%BD%A0%E6%99%93%E5%BE%97%E5%98%9B%EF%BC%9F/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 


<p>众所周知，ES 中的 mapping 只能在索引建立初期进行创建，且建立之后不可更改。mapping 对应的字段会映射成指定类型，未定义字段则自动映射，一般为 text 类型。那么想更改索引名或者更改某字段的 mapping 时，是否就束手无策了呢？当然不是！！！官方提供了一个接口，供索引备份迁移操作使用，那便是 <strong>reindex</strong>。当旧索引与新索引在同一节点时，效率相当高，万条数据瞬间完成（<code>大约只需0.4s</code>）。数百万数据也只需几分钟即可完成 操作，是不是很溜呢？快来学习一下吧。</p>
 <a id="more"></a> 

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-索引备份迁移"><a href="#1-索引备份迁移" class="headerlink" title="1.索引备份迁移"></a>1.索引备份迁移</h2><p><strong>请求方式：POST</strong></p>
<p><strong>请求 API <code>_reindex</code></strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"source"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"要备份的索引名"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dest"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"新建的索引名"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果新索引中有数据，且 id 与旧索引中重复，那么会进行覆盖操作。</p>
</blockquote>
<p>但是当数据量实在太大，高达几十 G 的时候，速度就会变得很慢，那是因为它底层还是利用了 scroll 操作。该如何进行<strong>优化</strong>呢？可以提升批量操作的文档数大小，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"source"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"要备份的索引名"</span>,</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">5000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dest"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>  : <span class="string">"新建的索引名"</span>,</span><br><span class="line">    <span class="attr">"routing"</span>: <span class="string">"=cat"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>批量操作大小是如何确定的呢？是根据文档数以及文档容量进行确定的。根据查阅资料得知，一个好的起点是<strong>每批处理数据 5-15 MB</strong>，这是个什么概念？</p>
<blockquote>
<p>1000 个 1kb 的文档大约 1MB；1000 个 100kb 的文档是 100MB。</p>
</blockquote>
<p>然后<strong>逐步增加每批处理数据容量</strong>，进行调优，直到最终性能无法再次提升。还有一个方法，那便是提升硬件，比如<strong>换固态</strong>，你懂得~</p>
<p>还有一种方法提升写入效率，这是终极操作，那便是 <code>sliced</code>。<code>reindex</code> 支持 Sliced Scroll 操作。它的原理可以简单的理解为将每次的 Scroll 请求分解，分解后并行化请求，从而提升效率。方式为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _reindex?slices=5&amp;refresh</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"source"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"要备份的索引名"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dest"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"新建的索引名"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-删除索引中指定的数据"><a href="#2-删除索引中指定的数据" class="headerlink" title="2.删除索引中指定的数据"></a>2.删除索引中指定的数据</h2><p><strong>请求方式：POST</strong></p>
<p><strong>请求 API <code>_delete_by_query</code></strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"字段名"</span>: <span class="string">"字段值"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法便是先查出指定数据再删除。</p>
</blockquote>
<h2 id="3-设置副本数、分片、动态映射"><a href="#3-设置副本数、分片、动态映射" class="headerlink" title="3. 设置副本数、分片、动态映射"></a>3. 设置副本数、分片、动态映射</h2><p>设置这些指标项可在建立 mapping 时一同设置。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>:&#123;</span><br><span class="line">        <span class="attr">"index"</span>:&#123;</span><br><span class="line">            // 刷新间隔</span><br><span class="line">            "refresh_interval":"3s"</span><br><span class="line">        &#125;,</span><br><span class="line">        // 副本数</span><br><span class="line">        "number_of_replicas":"0",</span><br><span class="line">        // 切片（分布在每个节点上的切片）</span><br><span class="line">        "number_of_shards":"1"</span><br><span class="line">    &#125;,</span><br><span class="line">    "mappings":&#123;</span><br><span class="line">        "_doc":&#123;</span><br><span class="line">            // 自动映射为 keyword 类型而不是默认的text类型</span><br><span class="line">            "dynamic_templates":[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"string_fields"</span>:&#123;</span><br><span class="line">                        <span class="attr">"match"</span>:<span class="string">"*"</span>,</span><br><span class="line">                        <span class="attr">"match_mapping_type"</span>:<span class="string">"string"</span>,</span><br><span class="line">                        <span class="attr">"mapping"</span>:&#123;</span><br><span class="line">                            <span class="attr">"type"</span>:<span class="string">"keyword"</span>,</span><br><span class="line">                            <span class="attr">"norms"</span>:<span class="literal">false</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            // 建立mapping</span><br><span class="line">            "properties":&#123;</span><br><span class="line">                "mydate":&#123;</span><br><span class="line">                    "type":"date",</span><br><span class="line">                    "format":"yyyy/MM/dd HH:mm:ss||date_time||strict_date_time"</span><br><span class="line">                &#125;,</span><br><span class="line">                "字段名":&#123;</span><br><span class="line">                    "type":"字段类型"</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 上传大文件</title>
    <url>/2019/10/25/Git%20%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
我们知道 github 上面限制每次推送的文件不能超过 100M，否则报错失败，那么非要推送大文件呢？有没有什么解决办法呢？答案当然是肯定的。这就用到了 `Git LFS` 。

 <a id="more"></a> 

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>因为只试验了 windows 平台，本文以此为例。其他系统可上网搜如何下载安装对应版本的 <code>git-lfs</code>。</p>
<h2 id="1-windows-平台安装-git-lfs"><a href="#1-windows-平台安装-git-lfs" class="headerlink" title="1.windows 平台安装 git-lfs"></a>1.windows 平台安装 git-lfs</h2><p>1.先打开网址：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">https://github.com/git-lfs/git-lfs/releases</span></span><br></pre></td></tr></table></figure>

<p>2.然后点击最新版本的版本号，将页面拉取到最底部，下载安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Windows Installer</span><br></pre></td></tr></table></figure>

<p>3.运行下载的 exe 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">windows installer</span><br></pre></td></tr></table></figure>

<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><p>1.打开 <code>git bash</code>，首先输入下列命令开启 lfs 功能：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure>

<p>2.然后使用如下命令进行大文件追踪，然后会生成文件 <code>.gitattributes</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git lfs track '大文件名'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 追踪大文件test.tar.gz</span></span><br><span class="line">git lfs track 'test.tar.gz'</span><br></pre></td></tr></table></figure>

<p>3.添加文件 <code>.gittributes</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .gitattributes</span><br></pre></td></tr></table></figure>

<p>4.然后提交文件 <code>.gitattributes</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m 'submit .gitattributes file'</span><br></pre></td></tr></table></figure>

<p>5.将文件 <code>.gitattributes</code> 推送到远程仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>6.添加大文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add test.tar.gz</span><br></pre></td></tr></table></figure>

<p>7.提交大文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m 'submit big file.'</span><br></pre></td></tr></table></figure>

<p>8.直接推送大文件到远程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>然后你就会发现大文件推送到远程的 github 仓库了。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>常用 es 查询盘点</title>
    <url>/2019/10/25/%E5%B8%B8%E7%94%A8-es-%E6%9F%A5%E8%AF%A2%E7%9B%98%E7%82%B9/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
熟悉了关系型数据库的结构概念以及查询，再去使用属于非关系型数据库的 Elasticsearch 时，简直是噩梦。第一道难关便是概念上的转换。索引？类型？文档？what？

 <a id="more"></a> 

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<blockquote>
<p>下面是概念上的对应，大家可以类比了解</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns</span><br><span class="line">Elasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields</span><br></pre></td></tr></table></figure>

<p>熟悉了各种概念后，下一道难关便是增删改查，而最最常用的是<strong>查询</strong>！如同 SQL 一样，它有一套自己的查询语句，称为 DSL。所以，下面为大家总结一下常用的查询，然后你就可以像翻字典一样，用时瞄两眼了 ~ 嘿嘿，真他娘的是个天才 … </p>
<h3 id="1-基础的不能再基础查询"><a href="#1-基础的不能再基础查询" class="headerlink" title="1.基础的不能再基础查询"></a>1.基础的不能再基础查询</h3><p><strong>查询所有的索引及容量：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _cat/indices</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>GET</code> 代表请求方式；<code>_cat/indices</code> 代表查询部分。访问的 <code>url</code> 写全为：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">localhost:9200/_cat/indices</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>查询某一索引的映射结构：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET 索引名/_mapping</span><br></pre></td></tr></table></figure>

<p><strong>查询所有的相同前缀索引：（如以 yan 开头）</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET yan*/_search</span><br></pre></td></tr></table></figure>

<p><strong>查询所有索引模板：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _template</span><br></pre></td></tr></table></figure>

<p><strong>查询具体索引模板：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _template/模板名</span><br></pre></td></tr></table></figure>

<p><strong>查询集群健康状态：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _cluster/health</span><br></pre></td></tr></table></figure>

<p><strong>查询所有节点：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _cat/nodes</span><br></pre></td></tr></table></figure>

<p><strong>查询索引及分片的分布：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _cat/shards</span><br></pre></td></tr></table></figure>

<p><strong>查询所有插件:</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _cat/plugins</span><br></pre></td></tr></table></figure>

<h3 id="2-有点难度的查询"><a href="#2-有点难度的查询" class="headerlink" title="2.有点难度的查询"></a>2.有点难度的查询</h3><p><strong>查询某个索引的全部数据：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "match_all": &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然你也可以直接写 URL 查询（默认返回 10 条文档）：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">localhost:9200/索引名/_search?pretty</span></span><br></pre></td></tr></table></figure>
<p>pretty参数是为了浏览器显示的美观一些。</p>
</blockquote>
<p><strong>根据某一字段精确查询：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "term": &#123; "字段名" : "值" &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据某一字段模糊匹配：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "match": &#123; "字段名" : "值" &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据某一字段值进行范围查找：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "range": &#123;</span><br><span class="line">    	# 字段名: 条件</span><br><span class="line">        "age":&#123; "gte" : 15 , "lte" : 25 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>gte 是大于等于；lte 是小于等于</p>
</blockquote>
<p><strong>根据条件进行过滤查询：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "filter": &#123;</span><br><span class="line">        "term":&#123;"字段":"值"&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多条件”或”关系：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">	"query": &#123;</span><br><span class="line">		"bool": &#123;</span><br><span class="line">			"should": [&#123;</span><br><span class="line">				"term": &#123;</span><br><span class="line">					"字段": "值"</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, &#123;</span><br><span class="line">				"match": &#123;</span><br><span class="line">					"字段": "值"</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多条件”与”关系：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must" : [&#123;</span><br><span class="line">        "match" : &#123;</span><br><span class="line">          "name" : "Ethanyan"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        "range":&#123;</span><br><span class="line">        "age":&#123;</span><br><span class="line">          "from" : 18 , "to" : 26</span><br><span class="line">        &#125; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>严格匹配：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must" : &#123;</span><br><span class="line">        "range" : &#123;</span><br><span class="line">          "age" : &#123; "from" : 18, "to" : 26 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>严格不匹配：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must_not" : &#123;</span><br><span class="line">        "term" : &#123;</span><br><span class="line">          "name" : "Ethanyan"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复合查询：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">	"query": &#123;</span><br><span class="line">		"bool": &#123;</span><br><span class="line">			"should": [&#123;</span><br><span class="line">					"match": &#123;</span><br><span class="line">						"age": 18</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,  </span><br><span class="line">				&#123;</span><br><span class="line">					"match": &#123;</span><br><span class="line">						"age": 26</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			],</span><br><span class="line">			"filter": &#123; </span><br><span class="line">				"match": &#123;  </span><br><span class="line">					"name": "Ethanyan" </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h3><p>1.索引名、模板名之类的名称不能出现字母大写</p>
<p>2.在查询时，需要写 DSL 语句，所以需要携带请求体，那么为什么还是 get 请求？</p>
<p>答：原则上 get 请求不能携带请求体，但凡事有例外，试验后确实可以，我也不晓得为什么。下方为官方文档，全为 get 请求：</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E5%B8%B8%E7%94%A8-es-%E6%9F%A5%E8%AF%A2%E7%9B%98%E7%82%B9/esquery.png" alt="esquery"></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 彻底删除某个commit的方法</title>
    <url>/2019/10/25/Git-%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AAcommit%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
如果因为一些原因，需要删除某个错误的  commit ，而且需要干净的操作，彻底让其消失，不留痕迹，该如何操作？

 <a id="more"></a> 

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<blockquote>
<p>我向仓库提交了一个大文件，大约 300M，push 失败（因为 git 最大能提交 100M 文件），删除本地文件不行，尝试过修改配置文件，解除 git 只能提交小于 100M 文件的限制，但是未起作用。只能通过删除包含提交此文件的 commit 解决。</p>
</blockquote>
<p>废话少说，直奔主题。</p>
<p>1.首先输入如下命令查看历史提交的 commit：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重要的是<strong>记下</strong>要删除的 commit 的<strong>上一条</strong> commit 的 <strong>commit号</strong>。如下图，如果要删除箭头所指的 commit，需要记录红框中的 commit号：</p>
</blockquote>
<p><img src="https://github.com/EthanYan6/pic/raw/master/Git-%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AAcommit%E7%9A%84%E6%96%B9%E6%B3%95/gitlog.png" alt="gitlog"></p>
<p>2.然后执行如下的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase -i commit号</span><br></pre></td></tr></table></figure>

<p>会出现如下界面：</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/Git-%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AAcommit%E7%9A%84%E6%96%B9%E6%B3%95/gitrebase.png" alt="gitrebase"></p>
<p>3.然后将要删除的 commit号 的前缀 <code>pick</code> 改为 <code>drop</code>。</p>
<p>4.然后可以通过如下命令再次查看是否已经删除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p>5.最后通过如下命令将现在的状态推送到远程仓库即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin HEAD -force</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
