<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CentOS这些情况你也遇到过</title>
    <url>/CentOS%E8%BF%99%E4%BA%9B%E6%83%85%E5%86%B5%E4%BD%A0%E4%B9%9F%E9%81%87%E5%88%B0%E8%BF%87/</url>
    <content><![CDATA[<center>Author: 闫玉良</center>
CentOS 虚拟机许久未用，忘记密码如何是好？删掉再来又岂能甘心？想安装某个命令，直接 yum install 就可以了吗？远程连接服务器报错该怎样操作？

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-CentOS-无法登陆情况下修改密码"><a href="#1-CentOS-无法登陆情况下修改密码" class="headerlink" title="1.CentOS 无法登陆情况下修改密码"></a>1.CentOS 无法登陆情况下修改密码</h2><p><strong>背景：</strong>虚拟机忘记 <code>root</code> 密码，不知如何登陆</p>
<p><strong>环境：</strong><code>CentOS</code>，<code>root</code> 账户</p>
<p><strong>操作：</strong></p>
<p>1.开启虚拟机，在进入系统前选择项页面，按 <code>e</code> 键进入系统配置文件</p>
<p>2.向下移动光标，找到 <code>Linux16</code> 开头，大概意思如下的一句话：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Linux16 /vmlinuz-3.10.0xxxxxx.x86_64 root=UUID=xxxxxxxx ro  crashkernel=auto rhgb quiet LANG=zh_CN.UTF-8</span><br></pre></td></tr></table></figure>

<p>3.在该行的最后加空格，输入 <code>init=/bin/sh</code></p>
<p>4.接下来按 <code>Ctrl + x</code> 组合键进入单用户模式</p>
<blockquote>
<p>等待一会，会发现已经进入系统，只不过，命令行前缀变为类似 <code>sh-4.2#</code> 的效果</p>
</blockquote>
<p>5.输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -o remount,rw /</span><br></pre></td></tr></table></figure>

<p>6.之后输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>

<p>7.接下来就是修改 <code>root</code> 账号密码了</p>
<blockquote>
<p>重复输入一个不少于8位的密码（密码在输入时是不显示的，只需要正确输入并回车即可）</p>
</blockquote>
<p>8.出现 <code>successfully</code> 字样表示修改成功，但要生效还需继续操作</p>
<p>9.输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch /.autorelabel</span><br></pre></td></tr></table></figure>

<p>10.操作完毕，还有一步：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exec /sbin/init</span><br></pre></td></tr></table></figure>

<p>接下来就是等待系统重启（可能需要几分钟，需耐心等待，勿中途关机）</p>
<h2 id="2-安装命令小技巧"><a href="#2-安装命令小技巧" class="headerlink" title="2.安装命令小技巧"></a>2.安装命令小技巧</h2><p>安装命令，大家一定会想到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install xxx</span><br></pre></td></tr></table></figure>

<p>但并非所有命令都是如此。有些则处于某工具包中，需要下载其基础环境，那该如何操作？</p>
<p>只需执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum search xxx</span><br></pre></td></tr></table></figure>

<p>耐心等待几分钟，直到执行完毕。然后安装最后提示模块即可。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum search killall</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Loaded plugins: fastestmirror, security</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"></span><br><span class="line">base: mirrors.163.com</span><br><span class="line">extras: mirrors.aliyun.com</span><br><span class="line">*&gt; updates: mirrors.aliyun.com</span><br><span class="line">-----------------------------------Matched:killall-----------------------------------/</span><br><span class="line">psmisc.x86_64 : Utilities for managing processes on your system</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可看到 <code>killall</code> 命令处于 <code>psmisc.x86_64</code> 中</p>
</blockquote>
<p>然后输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install psmisc.x86_64</span><br></pre></td></tr></table></figure>

<h2 id="3-远程连接服务器"><a href="#3-远程连接服务器" class="headerlink" title="3.远程连接服务器"></a>3.远程连接服务器</h2><p><strong>背景：</strong>使用 <code>ssh</code> 连接服务器进行相关操作，报错</p>
<p><strong>环境：</strong>本地 <code>MacOS</code>，服务器 <code>CentOS</code></p>
<p><strong>操作：</strong></p>
<p>1.使用命令进行远程连接，然后报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❱ ssh root@192.168.xx.xx</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint for the ECDSA key sent by the remote host is</span><br><span class="line">SHA256:ZBm9L5432tibaN5+weK4h9NJzqrc76lvxOUkVvSLGac.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /Users/ethanyan/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending ECDSA key in /Users/ethanyan/.ssh/known_hosts:6</span><br><span class="line">ECDSA host key for 192.168.xx.xx has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure>

<p>2.使用如下命令进行解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -R 你要访问的IP地址</span><br></pre></td></tr></table></figure>

<p>3.最后再次使用命令进行连接发现连接成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh 用户@你要访问的ip地址</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Django迁移数据库报错解决</title>
    <url>/Django%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p><code>Django</code> 最新版本创建应用后，迁移数据库报错怎么办？</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><p><code>Django3.0.2</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(django_dev) &gt; python -m django --version</span><br><span class="line">3.0.2</span><br></pre></td></tr></table></figure>

<p><code>MySQl8.0.19</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Server version: 8.0.19 MySQL Community Server - GPL</span><br></pre></td></tr></table></figure>

<p><code>Python3.7.6</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(django_dev) &gt; python --version</span><br><span class="line">Python 3.7.6</span><br></pre></td></tr></table></figure>



<h2 id="2-报错"><a href="#2-报错" class="headerlink" title="2.报错"></a>2.报错</h2><p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(django_dev) &gt; python manage.py makemigrations polls</span><br></pre></td></tr></table></figure>

<p>报错信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">django.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.13 or newer is required; you have 0.9.3.</span><br></pre></td></tr></table></figure>

<p>根据提示，是数据库 <code>MySQL</code> 与 <code>Django</code> 版本不匹配，建议我们升级 <code>mysqlclient</code>。</p>
<p>首先要说明的是，数据库 <code>MySQL</code> 与 <code>Django</code> 都是最新版本，不存在需要升级的问题。那么问题就应该出现在连接数据库的模块  <code>PyMySQL</code> 上了，但它也是安装的最新版：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(django_dev) &gt; pip install --upgrade PyMySQL</span><br><span class="line">Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">Requirement already up-to-date: PyMySQL in /Users/ethanyan/pyenv/django_dev/lib/python3.7/site-packages (0.9.3)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据提示，该模块并无任何更新可用。</p>
</blockquote>
<h2 id="3-解决"><a href="#3-解决" class="headerlink" title="3.解决"></a>3.解决</h2><p>既然外部组件并无问题，接下来核查代码层面。可以根据报错提示，进入底层代码逐个文件查找原因，最终定位到如下文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">django_dev/lib/python3.7/site-packages/django/db/backends/mysql/base.py</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>django_dev</code> 为项目的虚拟环境。</p>
</blockquote>
<p>此文件从第 35 行开始，有如下代码在作怪：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version = Database.version_info</span><br><span class="line">if version &lt; (1, 3, 13):</span><br><span class="line">    raise ImproperlyConfigured('mysqlclient 1.3.13 or newer is required; you have %s.' % Database.__version__)</span><br></pre></td></tr></table></figure>

<p>原来是底层有版本校验！查看其他文件，发现此校验并无关联内容，即可以注释掉，我们进行尝试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> version = Database.version_info</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> version &lt; (1, 3, 13):</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     raise ImproperlyConfigured(<span class="string">'mysqlclient 1.3.13 or newer is required; you have %s.'</span> % Database.__version__)</span></span><br></pre></td></tr></table></figure>

<p>然后再次执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(django_dev) &gt; python manage.py makemigrations polls</span><br><span class="line">Migrations for 'polls':</span><br><span class="line">  polls/migrations/0001_initial.py</span><br><span class="line">    - Create model Question</span><br><span class="line">    - Create model Choice</span><br></pre></td></tr></table></figure>

<p>执行成功。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Extjs-lesson1</title>
    <url>/Extjs-lesson1/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p><code>Ext.js</code> 系列课程笔记</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>1) 熟悉 <code>HTML</code></p>
<p>2) 熟悉 <code>CSS</code></p>
<p>3) 熟练 <code>javaScript</code></p>
<p>4) 熟练  <code>JS</code> 的面向对象（<code>oo</code>）编程</p>
<p>5) 熟练 <code>Ajax</code></p>
<blockquote>
<p>书籍推荐：《JavaScript 设计模式》《征服Ajax Web 2.0 开发技术详解》</p>
</blockquote>
<h2 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2.Hello World"></a>2.Hello World</h2><p>创建一个 <code>html</code> 页面，将 <code>ext</code> 的一些必要文件进行引入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入 css 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"./ext-2.3.0/resources/css/ext-all.css"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入 js 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./ext-2.3.0/adapter/ext/ext-base.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./ext-2.3.0/ext-all-debug.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入自己的 js 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./lesson01.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建对应的 <code>js</code> 文件 <code>lesson01.js</code> ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Ext.onReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Ext.MessageBox.alert(<span class="string">"提示"</span>, <span class="string">"hello world"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>它的入口函数为 <code>onReady</code> ，即在加载完成 <code>html</code> 页面之后，再加载入口函数的内容。</p>
</blockquote>
<p>显示效果：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E5%BC%B9%E7%AA%97.png" alt="ext-弹窗"></p>
<h2 id="3-官方-API-文档"><a href="#3-官方-API-文档" class="headerlink" title="3.官方 API 文档"></a>3.官方 API 文档</h2><p>小闫同学将开发工程师常用的官方文档进行了汇总，地址为「<a href="https://www.pythonnote.cn/OfficialDocuments/」文档会不定期补充更新，请收藏或转发给好友。">https://www.pythonnote.cn/OfficialDocuments/」文档会不定期补充更新，请收藏或转发给好友。</a></p>
<blockquote>
<p><code>Ext.js</code> 的文档也包含在内，点击对应按钮即可跳转。</p>
<p>包含了英文文档以及中文文档，英文吃力的同学，中文更方便哦 ~</p>
</blockquote>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3.png" alt="document"></p>
<p>下面是官方文档界面说明：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/api%20%E8%AF%B4%E6%98%8E.png" alt="API-zh"></p>
<blockquote>
<p>文档讲解的超级详细，当哪里不理解的时候，可以快速检索学习。</p>
</blockquote>
<h2 id="4-对原生-js-扩展"><a href="#4-对原生-js-扩展" class="headerlink" title="4.对原生 js 扩展"></a>4.对原生 js 扩展</h2><h3 id="4-1-Array-remove"><a href="#4-1-Array-remove" class="headerlink" title="4.1 Array remove"></a>4.1 Array remove</h3><p><code>extjs</code> 对原生的 <code>js</code> 进行了一些扩展，使得开发更加的高效化，比如 <code>Array</code> 的方法：<code>remove</code>。下面是它的 <code>API</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">remove( o ) : Array</span><br><span class="line">Removes the specified object from the array. If the object is not found nothing happens.</span><br><span class="line"></span><br><span class="line">Available since: 1.1.0</span><br><span class="line"></span><br><span class="line">Parameters</span><br><span class="line">o : Object</span><br><span class="line">The object to remove</span><br><span class="line"></span><br><span class="line">Returns</span><br><span class="line">Array</span><br><span class="line">this array</span><br></pre></td></tr></table></figure>

<p>简单的翻译来说：从数组中移除某个指定的对象，如果对象不存在，那么相当于什么都没发生，也不会报错。传入的参数是要移除的对象，返回的是这个数组。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msgArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">msgArray.remove(<span class="number">1</span>);</span><br><span class="line">alert(msgArray); <span class="comment">// 1 被移除，弹出窗口显示 2,3,4,5</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果直接在 <code>js</code> 代码中执行上述代码会报错：没有 <code>remove</code> 方法。而在 <code>Ext.onReady</code> 中执行上述代码时，会正常无误。</p>
</blockquote>
<p>当然上面只是众多 <code>API</code> 中的一个小例子，是为了说明它对原生 <code>js</code> 进行了很多扩展。那么他底层是怎么做的呢？</p>
<h3 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2 原理"></a>4.2 原理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> == obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, n = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>[i] != obj) &#123;</span><br><span class="line">      <span class="keyword">this</span>[n++] = <span class="keyword">this</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.length -= <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> msgArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">msgArray.remove(<span class="number">1</span>);</span><br><span class="line">alert(msgArray); <span class="comment">// 1 被移除，弹出窗口显示 2,3,4,5</span></span><br></pre></td></tr></table></figure>

<p>其实大部分都是通过上述 <code>prototype</code> 为类添加方法，只不过官方的代码逻辑一定比这个完善的多。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>extjs</category>
      </categories>
      <tags>
        <tag>extjs</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch 中这些必备 API 你晓得嘛？</title>
    <url>/Elasticsearch%20%E4%B8%AD%E8%BF%99%E4%BA%9B%E5%BF%85%E5%A4%87%20API%20%E4%BD%A0%E6%99%93%E5%BE%97%E5%98%9B%EF%BC%9F/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 


<p>众所周知，ES 中的 mapping 只能在索引建立初期进行创建，且建立之后不可更改。mapping 对应的字段会映射成指定类型，未定义字段则自动映射，一般为 text 类型。那么想更改索引名或者更改某字段的 mapping 时，是否就束手无策了呢？当然不是！！！官方提供了一个接口，供索引备份迁移操作使用，那便是 <strong>reindex</strong>。当旧索引与新索引在同一节点时，效率相当高，万条数据瞬间完成（<code>大约只需0.4s</code>）。数百万数据也只需几分钟即可完成 操作，是不是很溜呢？快来学习一下吧。</p>
 <a id="more"></a> 

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-索引备份迁移"><a href="#1-索引备份迁移" class="headerlink" title="1.索引备份迁移"></a>1.索引备份迁移</h2><p><strong>请求方式：POST</strong></p>
<p><strong>请求 API <code>_reindex</code></strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"source"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"要备份的索引名"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dest"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"新建的索引名"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果新索引中有数据，且 id 与旧索引中重复，那么会进行覆盖操作。</p>
</blockquote>
<p>但是当数据量实在太大，高达几十 G 的时候，速度就会变得很慢，那是因为它底层还是利用了 scroll 操作。该如何进行<strong>优化</strong>呢？可以提升批量操作的文档数大小，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"source"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"要备份的索引名"</span>,</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">5000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dest"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>  : <span class="string">"新建的索引名"</span>,</span><br><span class="line">    <span class="attr">"routing"</span>: <span class="string">"=cat"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>批量操作大小是如何确定的呢？是根据文档数以及文档容量进行确定的。根据查阅资料得知，一个好的起点是<strong>每批处理数据 5-15 MB</strong>，这是个什么概念？</p>
<blockquote>
<p>1000 个 1kb 的文档大约 1MB；1000 个 100kb 的文档是 100MB。</p>
</blockquote>
<p>然后<strong>逐步增加每批处理数据容量</strong>，进行调优，直到最终性能无法再次提升。还有一个方法，那便是提升硬件，比如<strong>换固态</strong>，你懂得~</p>
<p>还有一种方法提升写入效率，这是终极操作，那便是 <code>sliced</code>。<code>reindex</code> 支持 Sliced Scroll 操作。它的原理可以简单的理解为将每次的 Scroll 请求分解，分解后并行化请求，从而提升效率。方式为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _reindex?slices=5&amp;refresh</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"source"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"要备份的索引名"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dest"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"新建的索引名"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-删除索引中指定的数据"><a href="#2-删除索引中指定的数据" class="headerlink" title="2.删除索引中指定的数据"></a>2.删除索引中指定的数据</h2><p><strong>请求方式：POST</strong></p>
<p><strong>请求 API <code>_delete_by_query</code></strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"字段名"</span>: <span class="string">"字段值"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法便是先查出指定数据再删除。</p>
</blockquote>
<h2 id="3-设置副本数、分片、动态映射"><a href="#3-设置副本数、分片、动态映射" class="headerlink" title="3. 设置副本数、分片、动态映射"></a>3. 设置副本数、分片、动态映射</h2><p>设置这些指标项可在建立 mapping 时一同设置。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>:&#123;</span><br><span class="line">        <span class="attr">"index"</span>:&#123;</span><br><span class="line">            <span class="comment">// 刷新间隔</span></span><br><span class="line">            <span class="attr">"refresh_interval"</span>:<span class="string">"3s"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 副本数</span></span><br><span class="line">        <span class="attr">"number_of_replicas"</span>:<span class="string">"0"</span>,</span><br><span class="line">        <span class="comment">// 切片（分布在每个节点上的切片）</span></span><br><span class="line">        <span class="attr">"number_of_shards"</span>:<span class="string">"1"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">        <span class="attr">"_doc"</span>:&#123;</span><br><span class="line">            <span class="comment">// 自动映射为 keyword 类型而不是默认的text类型</span></span><br><span class="line">            <span class="attr">"dynamic_templates"</span>:[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"string_fields"</span>:&#123;</span><br><span class="line">                        <span class="attr">"match"</span>:<span class="string">"*"</span>,</span><br><span class="line">                        <span class="attr">"match_mapping_type"</span>:<span class="string">"string"</span>,</span><br><span class="line">                        <span class="attr">"mapping"</span>:&#123;</span><br><span class="line">                            <span class="attr">"type"</span>:<span class="string">"keyword"</span>,</span><br><span class="line">                            <span class="attr">"norms"</span>:<span class="literal">false</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// 建立mapping</span></span><br><span class="line">            <span class="attr">"properties"</span>:&#123;</span><br><span class="line">                <span class="attr">"mydate"</span>:&#123;</span><br><span class="line">                    <span class="attr">"type"</span>:<span class="string">"date"</span>,</span><br><span class="line">                    <span class="attr">"format"</span>:<span class="string">"yyyy/MM/dd HH:mm:ss||date_time||strict_date_time"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"字段名"</span>:&#123;</span><br><span class="line">                    <span class="attr">"type"</span>:<span class="string">"字段类型"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Extjs-lesson3</title>
    <url>/Extjs-lesson3/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p><code>Ext.js</code> 系列课程笔记「组件」</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-Ext-Window"><a href="#1-Ext-Window" class="headerlink" title="1.Ext.Window"></a>1.Ext.Window</h2><h3 id="1-1-展示"><a href="#1-1-展示" class="headerlink" title="1.1 展示"></a>1.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E6%BC%94%E7%A4%BA%E7%AA%97%E5%8F%A3.png" alt="演示窗口"></p>
<h3 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Ext.onReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> win = <span class="keyword">new</span> Ext.Window(&#123;</span><br><span class="line">      title: <span class="string">"演示窗口"</span>,</span><br><span class="line">      width: <span class="number">600</span>,</span><br><span class="line">      height: <span class="number">300</span>,</span><br><span class="line">      modal: <span class="literal">true</span>,</span><br><span class="line">      closable: <span class="literal">true</span>,</span><br><span class="line">      maximizable: <span class="literal">true</span>,</span><br><span class="line">      minimizable: <span class="literal">true</span>,</span><br><span class="line">      bodyStyle: <span class="string">"padding:30px"</span>,</span><br><span class="line">      html: <span class="string">'&lt;h1 style="text-align: center"&gt;欢迎关注：全栈技术精选&lt;/h1&gt;'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    win.show();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="1-3-详解"><a href="#1-3-详解" class="headerlink" title="1.3 详解"></a>1.3 详解</h3><p>介绍几个常用的<strong>配置项</strong>：</p>
<p><code>title</code> ：标题栏显示文字</p>
<p><code>width</code> ：窗口宽度</p>
<p><code>height</code> ：窗口高度</p>
<p><code>modal</code> ：是否设置为模态窗体</p>
<blockquote>
<p>模态窗体：打开此窗体后，不能对其他窗体进行操作</p>
</blockquote>
<p><code>closable</code> ：是否显示关闭按钮</p>
<p><code>maximizable</code> ：是否显示最大化按钮</p>
<p><code>minimizable</code> ：是否显示最小化按钮</p>
<p><code>html</code> ：窗口显示的内容</p>
<p><code>resizable</code> ：用户是否可以调整窗口的大小</p>
<p><code>bodyStyle</code> ：窗口内容与边框的间距</p>
<p><code>buttonAlign</code> ：窗口中 <code>button</code> 的对齐方式（<code>left</code>/<code>center</code>/<code>right</code>）默认是 <code>right</code></p>
<p>介绍几个<strong>方法</strong>：</p>
<p><code>show</code> ：窗口显示</p>
<p><code>hide</code> ：窗口隐藏</p>
<p><code>close</code> ：窗口关闭</p>
<h3 id="1-4-学习方法"><a href="#1-4-学习方法" class="headerlink" title="1.4 学习方法"></a>1.4 学习方法</h3><p>学习的方法就是通过官方的 <code>API</code> 文档，上篇文章介绍了使用方法，下面再提供一副图片详细介绍每个类的说明如何查看：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/api%20%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E.png" alt="类说明"></p>
<p>文档地址为「<a href="https://www.pythonnote.cn/OfficialDocuments/」，可点击跳转文档页面。">https://www.pythonnote.cn/OfficialDocuments/」，可点击跳转文档页面。</a></p>
<blockquote>
<p>小闫同学将开发工程师常用的官方文档进行了汇总，文档会不定期补充更新，请收藏或转发给好友。</p>
</blockquote>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3.png" alt="document"></p>
<h2 id="2-Ext-FormPanel"><a href="#2-Ext-FormPanel" class="headerlink" title="2.Ext.FormPanel"></a>2.Ext.FormPanel</h2><h3 id="2-1-展示"><a href="#2-1-展示" class="headerlink" title="2.1 展示"></a>2.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E8%A1%A8%E5%8D%95.png" alt="表单"></p>
<h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Ext.onReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化提示信息设置，比如图片中错误提示信息`This field is required`</span></span><br><span class="line">    Ext.QuickTips.init();</span><br><span class="line">    <span class="comment">// 创建一个表单面板对象</span></span><br><span class="line">    <span class="keyword">var</span> movie_form = <span class="keyword">new</span> Ext.FormPanel(&#123;</span><br><span class="line">      <span class="comment">// 表单提交的地址</span></span><br><span class="line">      url: <span class="string">"/movie_submit"</span>,</span><br><span class="line">      <span class="comment">// 将该组件放置在页面的 body 标签中</span></span><br><span class="line">      renderTo: <span class="built_in">document</span>.body,</span><br><span class="line">      <span class="comment">// 如果为True，则使用自定义的圆形边框渲染面板，如果为false，则使用纯1px正方形边框渲染（默认为false）。</span></span><br><span class="line">      frame: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 面板的标题栏文字</span></span><br><span class="line">      title: <span class="string">"Movie Information Form"</span>,</span><br><span class="line">      <span class="comment">// 宽度</span></span><br><span class="line">      width: <span class="number">250</span>,</span><br><span class="line">      <span class="comment">// 表单内容</span></span><br><span class="line">      items: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 该元素是文本字段</span></span><br><span class="line">          xtype: <span class="string">"textfield"</span>,</span><br><span class="line">          <span class="comment">// 输入框前显示内容</span></span><br><span class="line">          fieldLabel: <span class="string">"Title"</span>,</span><br><span class="line">          <span class="comment">// 选项名称</span></span><br><span class="line">          name: <span class="string">"title"</span>,</span><br><span class="line">          <span class="comment">// 校验不许为空</span></span><br><span class="line">          allowBlank: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          xtype: <span class="string">"textfield"</span>,</span><br><span class="line">          fieldLabel: <span class="string">"Director"</span>,</span><br><span class="line">          name: <span class="string">"director"</span>,</span><br><span class="line">          <span class="comment">// 校验内容只能是英文字母</span></span><br><span class="line">          vtype: <span class="string">"alpha"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 该元素是时间字段</span></span><br><span class="line">          xtype: <span class="string">"datefield"</span>,</span><br><span class="line">          fieldLabel: <span class="string">"Released"</span>,</span><br><span class="line">          name: <span class="string">"released"</span>,</span><br><span class="line">          <span class="comment">// 校验不能选择周一到周五的日期</span></span><br><span class="line">          disabledDays: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="comment">// 按钮</span></span><br><span class="line">      buttons: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 按钮显示文本</span></span><br><span class="line">          text: <span class="string">"Save"</span>,</span><br><span class="line">          <span class="comment">// 按钮的处理函数</span></span><br><span class="line">          handler: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 将表单内容提交</span></span><br><span class="line">            movie_form.getForm().submit(&#123;</span><br><span class="line">              <span class="comment">// 成功后的处理逻辑</span></span><br><span class="line">              success: <span class="function"><span class="keyword">function</span>(<span class="params">f, a</span>) </span>&#123;</span><br><span class="line">                Ext.Msg.alert(<span class="string">"Success"</span>, <span class="string">"It worked"</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="comment">// 失败后的处理逻辑</span></span><br><span class="line">              failure: <span class="function"><span class="keyword">function</span>(<span class="params">f, a</span>) </span>&#123;</span><br><span class="line">                Ext.Msg.alert(<span class="string">"Warning"</span>, <span class="string">"Error"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          text: <span class="string">"Reset"</span>,</span><br><span class="line">          handler: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 将表单内容重置</span></span><br><span class="line">            movie_form.getForm().reset();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">    movie_form.show();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="3-Ext-grid-GridPanel"><a href="#3-Ext-grid-GridPanel" class="headerlink" title="3.Ext.grid.GridPanel"></a>3.Ext.grid.GridPanel</h2><h3 id="3-1-展示"><a href="#3-1-展示" class="headerlink" title="3.1 展示"></a>3.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/gridpanel.png" alt="GridPanel"></p>
<h3 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2 代码"></a>3.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Ext.onReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建数据源</span></span><br><span class="line">    <span class="keyword">var</span> mystore = <span class="keyword">new</span> Ext.data.Store(&#123;</span><br><span class="line">      <span class="comment">// 数据本身，数组</span></span><br><span class="line">      data: [</span><br><span class="line">        [<span class="number">1</span>, <span class="string">"Office Space"</span>, <span class="string">"Mike Judge"</span>, <span class="string">"1999-02-19"</span>, <span class="number">1</span>, <span class="string">"Work Sucks"</span>, <span class="string">"19.95"</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="string">"Super Troopers2"</span>, <span class="string">"Jay Chandrasekhar"</span>, <span class="string">"2002-02-15"</span>, <span class="number">1</span>, <span class="string">"Altered State Police"</span>, <span class="string">"14.95"</span>, <span class="number">1</span>],</span><br><span class="line">        <span class="comment">//...more rows of data removed for readability...//</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="comment">// 从上面数组中读取数据时，字段与数据一一对应解释为 Extjs 使用的数据</span></span><br><span class="line">      <span class="comment">// 参数为 id 列，以及其他各个字段的名称</span></span><br><span class="line">      reader: <span class="keyword">new</span> Ext.data.ArrayReader(&#123; <span class="attr">id</span>: <span class="string">"id"</span> &#125;, [</span><br><span class="line">        <span class="string">"id"</span>,</span><br><span class="line">        <span class="string">"title"</span>,</span><br><span class="line">        <span class="string">"director"</span>,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">"released"</span>, <span class="attr">type</span>: <span class="string">"date"</span>, <span class="attr">dateFormat</span>: <span class="string">"Y-m-d"</span> &#125;,</span><br><span class="line">        <span class="string">"genre"</span>,</span><br><span class="line">        <span class="string">"tagline"</span>,</span><br><span class="line">        <span class="string">"price"</span>,</span><br><span class="line">        <span class="string">"available"</span></span><br><span class="line">      ])</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 创建一个 GridPanel 对象</span></span><br><span class="line">    <span class="keyword">var</span> grid = <span class="keyword">new</span> Ext.grid.GridPanel(&#123;</span><br><span class="line">      <span class="comment">// 数据再页面中的 body 标签中显示</span></span><br><span class="line">      renderTo: <span class="built_in">document</span>.body,</span><br><span class="line">      <span class="comment">// 如果为True，则使用自定义的圆形边框渲染面板，如果为false，则使用纯1px正方形边框渲染（默认为false）</span></span><br><span class="line">      frame: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 标题栏显示文字</span></span><br><span class="line">      title: <span class="string">"Movie Database"</span>,</span><br><span class="line">      <span class="comment">// 高度</span></span><br><span class="line">      height: <span class="number">200</span>,</span><br><span class="line">      <span class="comment">// 宽度</span></span><br><span class="line">      width: <span class="number">500</span>,</span><br><span class="line">      <span class="comment">// 数据源</span></span><br><span class="line">      store: mystore,</span><br><span class="line">      <span class="comment">// 指定表格的表头</span></span><br><span class="line">      columns: [</span><br><span class="line">        &#123; <span class="attr">header</span>: <span class="string">"Id"</span>, <span class="attr">dataIndex</span>: <span class="string">"id"</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">header</span>: <span class="string">"Title"</span>, <span class="attr">dataIndex</span>: <span class="string">"title"</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">header</span>: <span class="string">"Director"</span>, <span class="attr">dataIndex</span>: <span class="string">"director"</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          header: <span class="string">"Released"</span>,</span><br><span class="line">          dataIndex: <span class="string">"released"</span>,</span><br><span class="line">          renderer: Ext.util.Format.dateRenderer(<span class="string">"m/d/Y"</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; <span class="attr">header</span>: <span class="string">"Genre"</span>, <span class="attr">dataIndex</span>: <span class="string">"genre"</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">header</span>: <span class="string">"Tagline"</span>, <span class="attr">dataIndex</span>: <span class="string">"tagline"</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 展示表格面板</span></span><br><span class="line">    grid.show();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="4-Ext-tree-TreePanel"><a href="#4-Ext-tree-TreePanel" class="headerlink" title="4.Ext.tree.TreePanel"></a>4.Ext.tree.TreePanel</h2><h3 id="4-1-展示"><a href="#4-1-展示" class="headerlink" title="4.1 展示"></a>4.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/treepanel.png" alt="TreePanel"></p>
<h3 id="4-2-代码"><a href="#4-2-代码" class="headerlink" title="4.2 代码"></a>4.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Ext.onReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 树的节点数据源</span></span><br><span class="line">    <span class="keyword">var</span> node = &#123;</span><br><span class="line">      text: <span class="string">"根"</span>,</span><br><span class="line">      <span class="comment">// 是否展开子节点</span></span><br><span class="line">      expanded: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 是否为叶子节点</span></span><br><span class="line">      leaf: <span class="literal">false</span>,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          text: <span class="string">"根下节点一[user图标]"</span>,</span><br><span class="line">          leaf: <span class="literal">true</span>,</span><br><span class="line">          <span class="comment">// ExtJs自带的图标显示为“文件夹”或是“列表”，通过 iconCls 可以列换树型菜单的图标。</span></span><br><span class="line">          iconCls: <span class="string">"nodeicon"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; <span class="attr">text</span>: <span class="string">"根下节点二"</span>, <span class="attr">leaf</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          text: <span class="string">"根下节点三"</span>,</span><br><span class="line">          leaf: <span class="literal">false</span>,</span><br><span class="line">          children: [</span><br><span class="line">            &#123; <span class="attr">text</span>: <span class="string">"节点三子节点一"</span>, <span class="attr">leaf</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              text: <span class="string">"节点三子节点二"</span>,</span><br><span class="line">              leaf: <span class="literal">false</span>,</span><br><span class="line">              expanded: <span class="literal">true</span>,</span><br><span class="line">              children: [</span><br><span class="line">                &#123;</span><br><span class="line">                  text: <span class="string">"节点三子节点二节点一"</span>,</span><br><span class="line">                  leaf: <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  text: <span class="string">"节点三子节点二节点二"</span>,</span><br><span class="line">                  leaf: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 树面板(本地数据源)</span></span><br><span class="line">    <span class="comment">// 创建一个新的TreePanel表单对象</span></span><br><span class="line">    <span class="keyword">var</span> treelocal = <span class="keyword">new</span> Ext.tree.TreePanel(&#123;</span><br><span class="line">      title: <span class="string">"TreePanelLocal"</span>,</span><br><span class="line">      <span class="comment">//rootVisible: false, --&gt; 根节点的可见性</span></span><br><span class="line">      <span class="comment">// 根节点</span></span><br><span class="line">      root: node</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 树面板(服务器数据源)</span></span><br><span class="line">    <span class="comment">// 创建一个新的TreePanel表单对象</span></span><br><span class="line">    <span class="keyword">var</span> treeservice = <span class="keyword">new</span> Ext.tree.TreePanel(&#123;</span><br><span class="line">      title: <span class="string">"TreePanelService"</span>,</span><br><span class="line">      root: &#123; <span class="attr">text</span>: <span class="string">"根"</span>, <span class="attr">expanded</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      <span class="comment">// 树的数据载入组件,通过 url 寻找服务器返回的 json 数据，并且自动转换成 TreeNode</span></span><br><span class="line">      loader: <span class="keyword">new</span> Ext.tree.TreeLoader(&#123;</span><br><span class="line">        url: <span class="string">"/App_Ashx/Demo/Tree.ashx"</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 窗体</span></span><br><span class="line">    <span class="keyword">var</span> win = <span class="keyword">new</span> Ext.Window(&#123;</span><br><span class="line">      title: <span class="string">"窗口"</span>,</span><br><span class="line">      width: <span class="number">476</span>,</span><br><span class="line">      height: <span class="number">574</span>,</span><br><span class="line">      <span class="comment">// 用户是否可以调整窗口的大小</span></span><br><span class="line">      resizable: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 是否设置为模态窗体</span></span><br><span class="line">      modal: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 是否显示关闭按钮</span></span><br><span class="line">      closable: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 是否显示最大化按钮</span></span><br><span class="line">      maximizable: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 是否显示最小化按钮</span></span><br><span class="line">      minimizable: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 窗口中 `button` 的对齐方式（`left`/`center`/`right`）默认是 `right`</span></span><br><span class="line">      buttonAlign: <span class="string">"center"</span>,</span><br><span class="line">      items: [treelocal, treeservice],</span><br><span class="line">      buttons: [</span><br><span class="line">        &#123;</span><br><span class="line">          text: <span class="string">"获取选中项"</span>,</span><br><span class="line">          handler: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 获取选中节点</span></span><br><span class="line">            selectNode = treelocal.getSelectionModel().getSelectedNode();</span><br><span class="line">            alert(</span><br><span class="line">              <span class="string">"TreePanelLocal："</span> +</span><br><span class="line">              <span class="comment">// 如果节点为空时显示根节点的文本，否则显示选中的节点文本信息</span></span><br><span class="line">                (selectNode == <span class="literal">null</span> ? treelocal.root.text : selectNode.text)</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">    win.show();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>extjs</category>
      </categories>
      <tags>
        <tag>extjs</tag>
      </tags>
  </entry>
  <entry>
    <title>Extjs-lesson2</title>
    <url>/Extjs-lesson2/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p><code>Ext.js</code> 系列课程笔记「类」</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-定义类"><a href="#1-定义类" class="headerlink" title="1.定义类"></a>1.定义类</h2><p><code>Ext.js</code> 是面向对象的，因此我们需要了解一下它的语法，以便后续程序的展开。也许你一直好奇为什么使用该框架经常见到 <code>Ext</code>，因为框架中定义了各种类（提供了 300 多个类），不能保证与原生 <code>js</code> 或者其他框架没有一点冲突，因此将所有的命名封装到了 <code>Ext</code> 中，在此命名空间中就可以为所欲为了。就好比 <code>JQuery</code> 中的 <code>$</code>。</p>
<p>本来想写 <code>Ext.define</code> 的，结果惊奇的发现 <code>Extjs2.3</code> 中没有该方法，我也是一脸懵逼。好吧，这一些列文章，我会围绕老版本 <code>2.3</code> 进行展开，以适应那些老版本的企业项目。既然如此，那我们就回顾一下 <code>js</code> 的面向对象吧。</p>
<h3 id="1-1-构造函数模式"><a href="#1-1-构造函数模式" class="headerlink" title="1.1 构造函数模式"></a>1.1 构造函数模式</h3><blockquote>
<p>所谓”构造函数”，其实就是一个普通函数，但是内部使用了<code>this</code>变量。对构造函数使用<code>new</code>运算符，就能生成实例，并且<code>this</code>变量会绑定在实例对象上。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.call = <span class="string">"爸爸"</span></span><br><span class="line">  <span class="keyword">this</span>.like = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"藏私房钱~"</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-1-问题"><a href="#1-1-1-问题" class="headerlink" title="1.1.1 问题"></a>1.1.1 问题</h4><p>每生成一个实例， <code>call</code> 属性和 <code>like</code> 方法都会生成相同的内容，这是否太占用空间，浪费内存？那么能否只生成一次，以后的实例都去引用，而非重复内容创建多份呢？当然可以！请看下面：</p>
<h3 id="1-2-Prototype模式"><a href="#1-2-Prototype模式" class="headerlink" title="1.2 Prototype模式"></a>1.2 Prototype模式</h3><p>昨天的文章 <a href="https://www.pythonnote.cn/Extjs-lesson1/">Extjs-lesson1</a> 末尾提到了这种方式。我们可以将所有不变的属性以及方法直接定义在 <code>prototype</code> 对象上来解决上面提到的问题。</p>
<blockquote>
<p><code>Javascript</code> 规定，每一个构造函数都有一个<code>prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.call = <span class="string">"爸爸"</span>;</span><br><span class="line">Father.prototype.like = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"藏私房钱~"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h2><h3 id="2-1-构造函数绑定"><a href="#2-1-构造函数绑定" class="headerlink" title="2.1 构造函数绑定"></a>2.1 构造函数绑定</h3><blockquote>
<p>使用 <code>apply</code> 方法，让子类继承父类的方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.call = <span class="string">"爸爸"</span>;</span><br><span class="line">    <span class="keyword">this</span>.like = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(<span class="string">"藏私房钱~"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age, school</span>) </span>&#123;</span><br><span class="line">    Father.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);  <span class="xml"><span class="tag">&lt;<span class="name">----</span> 看这里</span></span></span><br><span class="line"><span class="xml">    this.name = name;</span></span><br><span class="line"><span class="xml">    this.age = age;</span></span><br><span class="line"><span class="xml">    this.school = school;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">// 创建对象，调用父类方法</span></span><br><span class="line"><span class="xml">  var smallSon = new Son("小明", 6, "庞各庄一高");</span></span><br><span class="line"><span class="xml">  smallSon.like();</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-Prototype模式"><a href="#2-2-Prototype模式" class="headerlink" title="2.2 Prototype模式"></a>2.2 Prototype模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.call = <span class="string">"爸爸"</span>;</span><br><span class="line">Father.prototype.like = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"藏私房钱~"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age, school</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.school = school;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 Son 的 prototype 对象指向一个 Father 示例</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="comment">// 将 constructor 属性，指向它原本的构造函数</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line"><span class="keyword">var</span> smallSon = <span class="keyword">new</span> Son(<span class="string">"小明"</span>, <span class="number">6</span>, <span class="string">"庞各庄一高"</span>);</span><br><span class="line">smallSon.like();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一行代码会将原先 <code>Son</code> 的 <code>prototype</code> 对象重新赋值，导致原先的被删除。任何一个 <code>prototype</code> 对象都有一个 <code>constructor</code> 属性，指向它的构造函数。经过第一行代码之后， <code>constructor</code> 属性也指向了 <code>Father</code>，这样一来，所有通过 <code>Son</code> 构造的实例的  <code>constructor</code> 属性都会指向了 <code>Father</code>，继承将完全混乱，所以第二行代码进行拨乱反正。</p>
</blockquote>
<h3 id="2-3-直接继承prototype"><a href="#2-3-直接继承prototype" class="headerlink" title="2.3 直接继承prototype"></a>2.3 直接继承prototype</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 Son 的 prototype 对象指向 Father 的 prototype 对象</span></span><br><span class="line">Son.prototype = Father.prototype;</span><br><span class="line"><span class="comment">// 将 constructor 属性，指向它原本的构造函数</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>优点</strong> ：效率比较高（不用执行和建立 <code>Father</code> 的实例了），比较省内存。</p>
<p><strong>缺点 ：</strong> <code>Son.prototype</code> 和 <code>Father.prototype</code> 现在指向了同一个对象，那么任何对 <code>Son.prototype</code> 的修改，都会反映到 <code>Father.prototype</code>。</p>
</blockquote>
<h4 id="2-3-1-改进"><a href="#2-3-1-改进" class="headerlink" title="2.3.1 改进"></a>2.3.1 改进</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">oEmpty.prototype = Father.prototype;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> oEmpty();</span><br><span class="line">Son.prototype.constructor = Son;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实就是利用一个空对象做中介，既节省内存，又不会因为 <code>Son.prototype</code> 的修改，反映到 <code>Father.prototype</code> 上。</p>
</blockquote>
<h2 id="3-创建对象"><a href="#3-创建对象" class="headerlink" title="3.创建对象"></a>3.创建对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> smallSon = <span class="keyword">new</span> Son(<span class="string">"小明"</span>, <span class="number">6</span>, <span class="string">"庞各庄一高"</span>);</span><br></pre></td></tr></table></figure>

<p>就是通过 <code>new</code> 关键字</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>extjs</category>
      </categories>
      <tags>
        <tag>extjs</tag>
      </tags>
  </entry>
  <entry>
    <title>Extjs-lesson4</title>
    <url>/Extjs-lesson4/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p><code>Ext.js</code> 系列课程笔记「表单子项」</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-TextField"><a href="#1-TextField" class="headerlink" title="1.TextField"></a>1.TextField</h2><h3 id="1-1-展示"><a href="#1-1-展示" class="headerlink" title="1.1 展示"></a>1.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/TextField.png" alt="TextField"></p>
<h3 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h3><blockquote>
<p>窗体 <code>Window</code> 以及表单 <code>FormPanel</code> 的代码省略，以后的代码将只展示必要部分。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化提示信息，让下面的框框显示提示动作</span></span><br><span class="line">Ext.QuickTips.init();</span><br><span class="line"><span class="comment">// 提示的方式在框框右边缘，参数的值有："qtip","title","under","side",id(元素id)</span></span><br><span class="line"><span class="comment">// side方式用的较多，右边出现红色感叹号，鼠标上去出现错误提示。</span></span><br><span class="line">Ext.form.Field.prototype.msgTarget = <span class="string">"side"</span>;</span><br><span class="line"><span class="comment">// 用户名</span></span><br><span class="line"><span class="comment">// 创建一个新的TextField文本框对象</span></span><br><span class="line"><span class="keyword">var</span> txtusername = <span class="keyword">new</span> Ext.form.TextField(&#123;</span><br><span class="line">  <span class="comment">// 宽</span></span><br><span class="line">  width: <span class="number">140</span>,</span><br><span class="line">  <span class="comment">// 不允许文本框为空</span></span><br><span class="line">  allowBlank: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 文本框的最大长度为 20 个字符；超过 20 个字符仍然可以输入，但会有警告信息</span></span><br><span class="line">  maxLength: <span class="number">20</span>,</span><br><span class="line">  <span class="comment">// 该 TextField 的名称</span></span><br><span class="line">  name: <span class="string">"username"</span>,</span><br><span class="line">  <span class="comment">// 文本框前面显示的文字</span></span><br><span class="line">  fieldLabel: <span class="string">"用户名称"</span>,</span><br><span class="line">  <span class="comment">// 当非空校验没有通过时的提示信息</span></span><br><span class="line">  blankText: <span class="string">"请输入用户名"</span>,</span><br><span class="line">  <span class="comment">// 当最大长度校验没有通过时的提示信息</span></span><br><span class="line">  maxLengthText: <span class="string">"用户名不能超过20个字符"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 密码input</span></span><br><span class="line"><span class="comment">// 创建一个新的TextField文本框对象</span></span><br><span class="line"><span class="keyword">var</span> txtpassword = <span class="keyword">new</span> Ext.form.TextField(&#123;</span><br><span class="line">  width: <span class="number">140</span>,</span><br><span class="line">  allowBlank: <span class="literal">false</span>,</span><br><span class="line">  maxLength: <span class="number">20</span>,</span><br><span class="line">  <span class="comment">// 字段类型，默认是 text，填写为 password 时密码会加密显示</span></span><br><span class="line">  inputType: <span class="string">"password"</span>,</span><br><span class="line">  name: <span class="string">"password"</span>,</span><br><span class="line">  fieldLabel: <span class="string">"密码"</span>,</span><br><span class="line">  blankText: <span class="string">"请输入密码"</span>,</span><br><span class="line">  maxLengthText: <span class="string">"密码不能超过20个字符"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="2-Button"><a href="#2-Button" class="headerlink" title="2.Button"></a>2.Button</h2><h3 id="2-1-展示"><a href="#2-1-展示" class="headerlink" title="2.1 展示"></a>2.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/Button.png" alt="Button"></p>
<h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提交按钮处理方法</span></span><br><span class="line"><span class="keyword">var</span> btnsubmitclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Ext.MessageBox.alert(<span class="string">"提示"</span>, <span class="string">"你点了确定按钮!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重置按钮"点击时"处理方法</span></span><br><span class="line"><span class="keyword">var</span> btnresetclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Ext.MessageBox.alert(<span class="string">"提示"</span>, <span class="string">"你点了重置按钮!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重置按钮"鼠标悬停"处理方法</span></span><br><span class="line"><span class="keyword">var</span> btnresetmouseover = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Ext.MessageBox.alert(<span class="string">"提示"</span>, <span class="string">"你鼠标悬停在重置按钮之上!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//提交按钮</span></span><br><span class="line"><span class="comment">//创建一个新的Button按钮对象</span></span><br><span class="line"><span class="keyword">var</span> btnsubmit = <span class="keyword">new</span> Ext.Button(&#123;</span><br><span class="line">  text: <span class="string">"提交"</span>,</span><br><span class="line">  <span class="comment">//当用户点击的时候[即js中的onclick事件]执行方法btnsubmitclick。</span></span><br><span class="line">  handler: btnsubmitclick</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//重置按钮</span></span><br><span class="line"><span class="comment">//创建一个新的Button按钮对象</span></span><br><span class="line"><span class="keyword">var</span> btnreset = <span class="keyword">new</span> Ext.Button(&#123;</span><br><span class="line">  text: <span class="string">"重置"</span>,</span><br><span class="line">  <span class="comment">//事件监听，按顺序执行。填写格式：事件名: 处理函数</span></span><br><span class="line">  listeners: &#123;</span><br><span class="line">    <span class="comment">//鼠标悬停时执行方法btnresetmouseover</span></span><br><span class="line">    mouseover: btnresetmouseover,</span><br><span class="line">    <span class="comment">//当用户点击的时候[即js中的onclick事件]执行方法btnresetclick</span></span><br><span class="line">    click: btnresetclick</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>handler</code> 是一个特殊的 <code>listeners</code> ，执行的是首发事件。</p>
</blockquote>
<h2 id="3-NumberField"><a href="#3-NumberField" class="headerlink" title="3.NumberField"></a>3.NumberField</h2><h3 id="3-1-展示"><a href="#3-1-展示" class="headerlink" title="3.1 展示"></a>3.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/NumberField.png" alt="NumberField"></p>
<h3 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2 代码"></a>3.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个NumberField数字文本框对象</span></span><br><span class="line"><span class="keyword">var</span> numberfield = <span class="keyword">new</span> Ext.form.NumberField(&#123;</span><br><span class="line">  <span class="comment">//文本框前面的显示文字（标签）</span></span><br><span class="line">  fieldLabel: <span class="string">"身高"</span>,</span><br><span class="line">  <span class="comment">//宽度</span></span><br><span class="line">  width: <span class="number">80</span>,</span><br><span class="line">  <span class="comment">//设置小数点后面的位数，当位数超过时系统会自动截断</span></span><br><span class="line">  decimalPrecision: <span class="number">1</span>,</span><br><span class="line">  <span class="comment">//设置数字文本框最小值</span></span><br><span class="line">  minValue: <span class="number">0.01</span>,</span><br><span class="line">  <span class="comment">//设置数字文本框最大值</span></span><br><span class="line">  maxValue: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">//这个是自己添加的属性，属性添加可以参看重写文本框部分代码</span></span><br><span class="line">  unitText: <span class="string">" cm"</span>,</span><br><span class="line">  <span class="comment">//不允许为空</span></span><br><span class="line">  allowBlank: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">//如果校验为空时的提示文字</span></span><br><span class="line">  blankText: <span class="string">"请输入身高"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-重写文本框"><a href="#3-2-1-重写文本框" class="headerlink" title="3.2.1 重写文本框"></a>3.2.1 重写文本框</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重写Ext.form.TextField这个类</span></span><br><span class="line">Ext.override(Ext.form.TextField, &#123;</span><br><span class="line">  unitText: <span class="string">''</span>,</span><br><span class="line">  <span class="comment">//重写 onRender 方法</span></span><br><span class="line">  onRender: <span class="function"><span class="keyword">function</span> (<span class="params">ct, position</span>) </span>&#123;</span><br><span class="line">    Ext.form.TextField.superclass.onRender.call(<span class="keyword">this</span>, ct, position);</span><br><span class="line">    <span class="comment">// 如果单位字符串已定义 则在后方增加单位对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.unitText != <span class="string">''</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.unitEl = ct.createChild(&#123;</span><br><span class="line">        tag: <span class="string">'div'</span>,</span><br><span class="line">        html: <span class="keyword">this</span>.unitText</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 在样式表中加了样式"x-form-unit"。</span></span><br><span class="line">      <span class="keyword">this</span>.unitEl.addClass(<span class="string">'x-form-unit'</span>);</span><br><span class="line">      <span class="comment">// 增加单位名称的同时 按单位名称大小减少文本框的长度 初步考虑了中英文混排 未考虑为负的情况</span></span><br><span class="line">      <span class="keyword">this</span>.width = <span class="keyword">this</span>.width - (<span class="keyword">this</span>.unitText.replace(<span class="regexp">/[^\x00-\xff]/g</span>, <span class="string">"xx"</span>).length * <span class="number">6</span> + <span class="number">2</span>);</span><br><span class="line">      <span class="comment">// 同时修改错误提示图标的位置</span></span><br><span class="line">      <span class="keyword">this</span>.alignErrorIcon = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorIcon.alignTo(<span class="keyword">this</span>.unitEl, <span class="string">'tl-tr'</span>, [<span class="number">2</span>, <span class="number">0</span>]);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="4-Hidden"><a href="#4-Hidden" class="headerlink" title="4.Hidden"></a>4.Hidden</h2><blockquote>
<p>毕竟是隐藏字段，顾名思义不可见，因此无展示图例</p>
</blockquote>
<h3 id="4-1-代码"><a href="#4-1-代码" class="headerlink" title="4.1 代码"></a>4.1 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新建一个Hidden隐藏字段对象</span></span><br><span class="line"><span class="keyword">var</span> hiddenfield = <span class="keyword">new</span> Ext.form.Hidden(&#123;</span><br><span class="line">  <span class="comment">//名称，后端收到的信息为 userid: 1</span></span><br><span class="line">  name: <span class="string">"userid"</span>,</span><br><span class="line">  <span class="comment">//值</span></span><br><span class="line">  value: <span class="string">"1"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="5-DateField"><a href="#5-DateField" class="headerlink" title="5.DateField"></a>5.DateField</h2><h3 id="5-1-展示"><a href="#5-1-展示" class="headerlink" title="5.1 展示"></a>5.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/NumberField.png" alt="DateField"></p>
<h3 id="5-2-代码"><a href="#5-2-代码" class="headerlink" title="5.2 代码"></a>5.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新建一个 DateField 日期字段对象</span></span><br><span class="line"><span class="keyword">var</span> datefield = <span class="keyword">new</span> Ext.form.DateField(&#123;</span><br><span class="line">  <span class="comment">//文本框前方显示文字（标签）</span></span><br><span class="line">  fieldLabel: <span class="string">"出生日期"</span>,</span><br><span class="line">  <span class="comment">//日期显示格式</span></span><br><span class="line">  format: <span class="string">"Y-m-d"</span>,</span><br><span class="line">  <span class="comment">//是否可编辑</span></span><br><span class="line">  editable: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">//是否可以为空</span></span><br><span class="line">  allowBlank: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">//校验为空时提示信息</span></span><br><span class="line">  blankText: <span class="string">"请选择日期"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="6-RadioGroup"><a href="#6-RadioGroup" class="headerlink" title="6.RadioGroup"></a>6.RadioGroup</h2><h3 id="6-1-展示"><a href="#6-1-展示" class="headerlink" title="6.1 展示"></a>6.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/checkbox.png" alt="单选组"></p>
<h3 id="6-2-代码"><a href="#6-2-代码" class="headerlink" title="6.2 代码"></a>6.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个RadioGroup对象</span></span><br><span class="line"><span class="keyword">var</span> radiogroup = <span class="keyword">new</span> Ext.form.RadioGroup(&#123;</span><br><span class="line">  <span class="comment">//单选框前面的显示文字信息</span></span><br><span class="line">  fieldLabel: <span class="string">"性别"</span>,</span><br><span class="line">  <span class="comment">//宽度</span></span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">  items: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//这个属性是设置单选的关键</span></span><br><span class="line">      <span class="comment">//只有同一组 name 的单选按钮才能单选</span></span><br><span class="line">      name: <span class="string">"sex"</span>,</span><br><span class="line">      <span class="comment">//单选框的值</span></span><br><span class="line">      inputValue: <span class="string">"0"</span>,</span><br><span class="line">      <span class="comment">//单选框的文字说明</span></span><br><span class="line">      boxLabel: <span class="string">"男"</span>,</span><br><span class="line">      <span class="comment">//默认勾选男，哪个选项默认勾选，就在哪个选项中添加此属性</span></span><br><span class="line">      checked: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//与上方 name 设置一致</span></span><br><span class="line">      name: <span class="string">"sex"</span>,</span><br><span class="line">      <span class="comment">//单选框的值</span></span><br><span class="line">      inputValue: <span class="string">"1"</span>,</span><br><span class="line">      <span class="comment">//单选框的文字说明</span></span><br><span class="line">      boxLabel: <span class="string">"女"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//获取单选组的值</span></span><br><span class="line">radiogroup.on(<span class="string">"change"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">rdgroup, checked</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//获取单选框的选中值</span></span><br><span class="line">  alert(checked.getRawValue());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="7-CheckBoxGroup"><a href="#7-CheckBoxGroup" class="headerlink" title="7.CheckBoxGroup"></a>7.CheckBoxGroup</h2><h3 id="7-1-展示"><a href="#7-1-展示" class="headerlink" title="7.1 展示"></a>7.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/checkbox.png" alt="复选组"></p>
<h3 id="7-2-代码"><a href="#7-2-代码" class="headerlink" title="7.2 代码"></a>7.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个复选组的对象</span></span><br><span class="line"><span class="keyword">var</span> checkboxgroup = <span class="keyword">new</span> Ext.form.CheckboxGroup(&#123;</span><br><span class="line">  <span class="comment">//复选组前文字提示信息</span></span><br><span class="line">  fieldLabel: <span class="string">"兴趣爱好"</span>,</span><br><span class="line">  <span class="comment">//宽度</span></span><br><span class="line">  width: <span class="number">170</span>,</span><br><span class="line">  <span class="comment">//元素</span></span><br><span class="line">  items: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//选择框的文字说明</span></span><br><span class="line">      boxLabel: <span class="string">"抽烟"</span>,</span><br><span class="line">      <span class="comment">//选择框的值</span></span><br><span class="line">      inputValue: <span class="string">"0"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//选择框的文字说明</span></span><br><span class="line">      boxLabel: <span class="string">"喝酒"</span>,</span><br><span class="line">      <span class="comment">//选择框的值</span></span><br><span class="line">      inputValue: <span class="string">"1"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//选择框的文字说明</span></span><br><span class="line">      boxLabel: <span class="string">"烫头"</span>,</span><br><span class="line">      <span class="comment">//选择框的值</span></span><br><span class="line">      inputValue: <span class="string">"2"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//获取复选组的值</span></span><br><span class="line">checkboxgroup.on(<span class="string">"change"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cbgroup, checked</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//因为是多选，所以需要循环取出所有勾选的值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; checked.length; i++) &#123;</span><br><span class="line">    alert(checked[i].getRawValue());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="8-Combobox"><a href="#8-Combobox" class="headerlink" title="8.Combobox"></a>8.Combobox</h2><h3 id="8-1-展示"><a href="#8-1-展示" class="headerlink" title="8.1 展示"></a>8.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E4%B8%8B%E6%8B%89%E6%A1%86.png" alt="Combobox"></p>
<h3 id="8-2-代码"><a href="#8-2-代码" class="headerlink" title="8.2 代码"></a>8.2 代码</h3><blockquote>
<p><code>Ext.js2.3</code> 中没有 <code>ArrayStore</code> ，我们使用 <code>Store</code> 替代</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建数据源[数组数据源]</span></span><br><span class="line"><span class="keyword">var</span> combostore = <span class="keyword">new</span> Ext.data.Store(&#123;</span><br><span class="line">  <span class="comment">// 数据本身，数组</span></span><br><span class="line">  data: [</span><br><span class="line">    [<span class="number">1</span>, <span class="string">"团员"</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="string">"党员"</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="string">"其他"</span>]</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 从上面数组中读取数据时，字段与数据一一对应解释为 Extjs 使用的数据</span></span><br><span class="line">  <span class="comment">// 参数为 id 列，以及其他各个字段的名称</span></span><br><span class="line">  reader: <span class="keyword">new</span> Ext.data.ArrayReader(&#123; <span class="attr">id</span>: <span class="string">"id"</span> &#125;, [<span class="string">"id"</span>, <span class="string">"name"</span>])</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//创建Combobox</span></span><br><span class="line"><span class="keyword">var</span> combobox = <span class="keyword">new</span> Ext.form.ComboBox(&#123;</span><br><span class="line">  <span class="comment">//下拉框前的提示文字信息</span></span><br><span class="line">  fieldLabel: <span class="string">"政治面貌"</span>,</span><br><span class="line">  <span class="comment">//数据源；此属性必填</span></span><br><span class="line">  store: combostore,</span><br><span class="line">  <span class="comment">//显示的列，对应数据源的 name 列；此属性必填</span></span><br><span class="line">  displayField: <span class="string">"name"</span>,</span><br><span class="line">  <span class="comment">//对应数据源中 id 列的值；此属性必填</span></span><br><span class="line">  valueField: <span class="string">"id"</span>,</span><br><span class="line">  <span class="comment">//请设置为”all”,否则默认为”query”的情况下，你选择某个值后，再此下拉时，只出现匹配选项。而 all 则每次都显示全部</span></span><br><span class="line">  triggerAction: <span class="string">"all"</span>,</span><br><span class="line">  <span class="comment">//未填时显示的提示信息</span></span><br><span class="line">  emptyText: <span class="string">"请选择..."</span>,</span><br><span class="line">  <span class="comment">//不允许为空</span></span><br><span class="line">  allowBlank: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">//校验为空时提示信息</span></span><br><span class="line">  blankText: <span class="string">"请选择政治面貌"</span>,</span><br><span class="line">  <span class="comment">//不可编辑</span></span><br><span class="line">  editable: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">//指定数据源为本地数据源，如果是本地创建的数据源，该属性也是必须的</span></span><br><span class="line">  <span class="comment">//设置为'remote'表示数据源来自于服务器</span></span><br><span class="line">  mode: <span class="string">"local"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//Combobox获取值</span></span><br><span class="line"><span class="comment">//选择时alert出下拉列表的值</span></span><br><span class="line">combobox.on(<span class="string">"select"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(combobox.getValue());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>extjs</category>
      </categories>
      <tags>
        <tag>extjs</tag>
      </tags>
  </entry>
  <entry>
    <title>Extjs-lesson6</title>
    <url>/Extjs-lesson6/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p><code>Ext.js</code> 系列课程笔记「布局」</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-AccordionLayout"><a href="#1-AccordionLayout" class="headerlink" title="1.AccordionLayout"></a>1.AccordionLayout</h2><p><strong>介绍</strong>：经常用来对左侧功能列表进行分类</p>
<p><strong>效果</strong>：手风琴式布局，可以折叠的布局</p>
<h3 id="1-1-展示"><a href="#1-1-展示" class="headerlink" title="1.1 展示"></a>1.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/c34b732d4c43f42e62044916ec83fd25e9f162da/AccordionLayout.png" alt="AccordionLayout"></p>
<h3 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Ext.onReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> AccordionLayout = <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">    title: <span class="string">"AccordionLayout"</span>,</span><br><span class="line">    <span class="comment">//布局样式</span></span><br><span class="line">    layout: <span class="string">"accordion"</span>,</span><br><span class="line">    height: <span class="number">200</span>,</span><br><span class="line">    items: [</span><br><span class="line">      <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">        title: <span class="string">"国家"</span>,</span><br><span class="line">        items: [</span><br><span class="line">          <span class="keyword">new</span> Ext.BoxComponent(&#123;</span><br><span class="line">            autoEl: &#123; <span class="attr">tag</span>: <span class="string">"div"</span>, <span class="attr">html</span>: <span class="string">"中国"</span> &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        ]</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">        title: <span class="string">"省"</span>,</span><br><span class="line">        items: [</span><br><span class="line">          <span class="keyword">new</span> Ext.BoxComponent(&#123;</span><br><span class="line">            autoEl: &#123; <span class="attr">tag</span>: <span class="string">"div"</span>, <span class="attr">html</span>: <span class="string">"台湾省"</span> &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        ]</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">        title: <span class="string">"市"</span>,</span><br><span class="line">        items: [</span><br><span class="line">          <span class="keyword">new</span> Ext.BoxComponent(&#123;</span><br><span class="line">            autoEl: &#123; <span class="attr">tag</span>: <span class="string">"div"</span>, <span class="attr">html</span>: <span class="string">"台北市"</span> &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        ]</span><br><span class="line">      &#125;)</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">//将面板显示到HTML中：</span></span><br><span class="line">    <span class="comment">//&lt;div id="AccordionLayout" style="width: 300px; float: left; height: 200px"&gt;&lt;/div&gt;</span></span><br><span class="line">    renderTo: <span class="string">"AccordionLayout"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="2-BorderLayout"><a href="#2-BorderLayout" class="headerlink" title="2.BorderLayout"></a>2.BorderLayout</h2><p><strong>介绍</strong>：经常用来做后台框架的布局。</p>
<p><strong>效果</strong>：将页面分为了上下左右和中间几个位置</p>
<h3 id="2-1-展示"><a href="#2-1-展示" class="headerlink" title="2.1 展示"></a>2.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/c34b732d4c43f42e62044916ec83fd25e9f162da/BorderLayout.png" alt="BorderLayout"></p>
<h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Ext.onReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> BorderLayout = <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">    title: <span class="string">"BorderLayout"</span>,</span><br><span class="line">    layout: <span class="string">"border"</span>,</span><br><span class="line">    width: <span class="number">1100</span>,</span><br><span class="line">    height: <span class="number">300</span>,</span><br><span class="line">    items: [</span><br><span class="line">      <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">        title: <span class="string">"北宫玄武"</span>,</span><br><span class="line">        region: <span class="string">"north"</span>,</span><br><span class="line">        html: <span class="string">"可以放个logo什么的"</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">        title: <span class="string">"南方朱鸟"</span>,</span><br><span class="line">        region: <span class="string">"south"</span>,</span><br><span class="line">        html: <span class="string">"版权信息？"</span>,</span><br><span class="line">        autoEl: <span class="string">"center"</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">        title: <span class="string">"中间"</span>,</span><br><span class="line">        region: <span class="string">"center"</span>,</span><br><span class="line">        html: <span class="string">"《史记-天宫书》"</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">        title: <span class="string">"东宫苍龙"</span>,</span><br><span class="line">        region: <span class="string">"west"</span>,</span><br><span class="line">        html: <span class="string">"树型菜单或是手风琴"</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">        title: <span class="string">"西宫咸池"</span>,</span><br><span class="line">        region: <span class="string">"east"</span>,</span><br><span class="line">        html: <span class="string">"常用功能或是去掉？"</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">//将面板显示到HTML中：</span></span><br><span class="line">    <span class="comment">//&lt;div id="BorderLayout" style="padding: 10px 0px; clear: both"&gt;&lt;/div&gt;</span></span><br><span class="line">    renderTo: <span class="string">"BorderLayout"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="3-ColumnLayout"><a href="#3-ColumnLayout" class="headerlink" title="3.ColumnLayout"></a>3.ColumnLayout</h2><p><strong>效果：</strong>将内部组件水平方向展开</p>
<h3 id="3-1-展示"><a href="#3-1-展示" class="headerlink" title="3.1 展示"></a>3.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/c34b732d4c43f42e62044916ec83fd25e9f162da/ColumnLayout.png" alt="ColumnLayout"></p>
<h3 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2 代码"></a>3.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Ext.onReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ColumnLayout = <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">    width: <span class="number">600</span>,</span><br><span class="line">    title: <span class="string">"ColumnLayout"</span>,</span><br><span class="line">    layout: <span class="string">"column"</span>,</span><br><span class="line">    items: [</span><br><span class="line">      <span class="keyword">new</span> Ext.form.FormPanel(&#123;</span><br><span class="line">        title: <span class="string">"第一列"</span>,</span><br><span class="line">        columnWidth: <span class="number">0.33</span>,</span><br><span class="line">        labelWidth: <span class="number">50</span>,</span><br><span class="line">        items: [<span class="keyword">new</span> Ext.form.TextField(&#123; <span class="attr">fieldLabel</span>: <span class="string">"姓名"</span> &#125;)]</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> Ext.form.FormPanel(&#123;</span><br><span class="line">        title: <span class="string">"第二列"</span>,</span><br><span class="line">        columnWidth: <span class="number">0.33</span>,</span><br><span class="line">        labelWidth: <span class="number">50</span>,</span><br><span class="line">        items: [<span class="keyword">new</span> Ext.form.TextField(&#123; <span class="attr">fieldLabel</span>: <span class="string">"年龄"</span> &#125;)]</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> Ext.form.FormPanel(&#123;</span><br><span class="line">        title: <span class="string">"第三列"</span>,</span><br><span class="line">        columnWidth: <span class="number">0.34</span>,</span><br><span class="line">        labelWidth: <span class="number">60</span>,</span><br><span class="line">        items: [<span class="keyword">new</span> Ext.form.TextField(&#123; <span class="attr">fieldLabel</span>: <span class="string">"爱好"</span> &#125;)]</span><br><span class="line">      &#125;)</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">//将面板显示到HTML中：</span></span><br><span class="line">    <span class="comment">//&lt;div id="ColumnLayout" style="float: left; width: 500px; padding-left: 10px;"&gt;&lt;/div&gt;</span></span><br><span class="line">    renderTo: <span class="string">"ColumnLayout"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="4-ContainerLayout"><a href="#4-ContainerLayout" class="headerlink" title="4.ContainerLayout"></a>4.ContainerLayout</h2><p><strong>介绍</strong>：这种是默认的布局方式，其他的布局都继承了该类进行适当的扩展。</p>
<p><strong>效果</strong>：将内部组件竖直方向进行堆叠</p>
<blockquote>
<p>当你写一个面板，没有 <code>layout</code> 时，默认就采用了这种布局。</p>
</blockquote>
<h3 id="4-1-展示"><a href="#4-1-展示" class="headerlink" title="4.1 展示"></a>4.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/c34b732d4c43f42e62044916ec83fd25e9f162da/ContainerLayout.png" alt="ContainerLayout"></p>
<h3 id="4-2-代码"><a href="#4-2-代码" class="headerlink" title="4.2 代码"></a>4.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Ext.onReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> box1 = <span class="keyword">new</span> Ext.BoxComponent(&#123;</span><br><span class="line">    autoEl: &#123;</span><br><span class="line">      tag: <span class="string">"div"</span>,</span><br><span class="line">      style: <span class="string">"background:red;width:300px;height:30px"</span>,</span><br><span class="line">      html: <span class="string">"box1"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> box2 = <span class="keyword">new</span> Ext.BoxComponent(&#123;</span><br><span class="line">    autoEl: &#123;</span><br><span class="line">      tag: <span class="string">"div"</span>,</span><br><span class="line">      style: <span class="string">"background:yellow;width:300px;height:30px"</span>,</span><br><span class="line">      html: <span class="string">"box2"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> box3 = <span class="keyword">new</span> Ext.BoxComponent(&#123;</span><br><span class="line">    autoEl: &#123;</span><br><span class="line">      tag: <span class="string">"div"</span>,</span><br><span class="line">      style: <span class="string">"background:blue;width:300px;height:30px;color:#fff"</span>,</span><br><span class="line">      html: <span class="string">"box3"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//创建一个面板，没有设置 layout 字段</span></span><br><span class="line">  <span class="keyword">var</span> containerlayout = <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">    items: [box1, box2, box3],</span><br><span class="line">    <span class="comment">//将面板显示到HTML中：</span></span><br><span class="line">    <span class="comment">//&lt;div id="ContainerLayout" style="float: left; width: 300px"&gt; ContainerLayout：垂直方式放置 &lt;/div&gt;</span></span><br><span class="line">    renderTo: <span class="string">"ContainerLayout"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="5-FormLayout"><a href="#5-FormLayout" class="headerlink" title="5.FormLayout"></a>5.FormLayout</h2><p><strong>介绍</strong>：这个看起来就像表单一样</p>
<p><strong>效果</strong>：将内部组件竖直方向进行堆叠</p>
<h3 id="5-1-展示"><a href="#5-1-展示" class="headerlink" title="5.1 展示"></a>5.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/c34b732d4c43f42e62044916ec83fd25e9f162da/FormLayout.png" alt="FormLayout"></p>
<h3 id="5-2-代码"><a href="#5-2-代码" class="headerlink" title="5.2 代码"></a>5.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Ext.onReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> formlayout = <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">    title: <span class="string">"FormLayout"</span>,</span><br><span class="line">    layout: <span class="string">"form"</span>,</span><br><span class="line">    items: [</span><br><span class="line">      <span class="keyword">new</span> Ext.form.TextField(&#123; <span class="attr">fieldLabel</span>: <span class="string">"姓名"</span> &#125;),</span><br><span class="line">      <span class="keyword">new</span> Ext.form.TextField(&#123; <span class="attr">fieldLabel</span>: <span class="string">"年级"</span> &#125;),</span><br><span class="line">      <span class="keyword">new</span> Ext.form.TextField(&#123; <span class="attr">fieldLabel</span>: <span class="string">"班级"</span> &#125;)</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">//将面板显示到HTML中：</span></span><br><span class="line">    <span class="comment">//&lt;div id="FormLayout" style="float: left; width: 240px; padding-left: 10px;"&gt;&lt;/div&gt;</span></span><br><span class="line">    renderTo: <span class="string">"FormLayout"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="6-FitLayout"><a href="#6-FitLayout" class="headerlink" title="6.FitLayout"></a>6.FitLayout</h2><p><strong>介绍</strong>：强迫子组件填充满容器的布局</p>
<h3 id="6-1-展示"><a href="#6-1-展示" class="headerlink" title="6.1 展示"></a>6.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/c34b732d4c43f42e62044916ec83fd25e9f162da/FitLayout.png" alt="FitLayout"></p>
<h3 id="6-2-代码"><a href="#6-2-代码" class="headerlink" title="6.2 代码"></a>6.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Ext.onReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> FitLayout = <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">    title: <span class="string">"FitLayout"</span>,</span><br><span class="line">    height: <span class="number">100</span>,</span><br><span class="line">    renderTo: <span class="string">"FitLayout"</span>,</span><br><span class="line">    layout: <span class="string">"fit"</span>,</span><br><span class="line">    items: [</span><br><span class="line">      <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">        bodyStyle: <span class="string">"background:red"</span>,</span><br><span class="line">        html: <span class="string">"使用了fit布局,填充满"</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">        bodyStyle: <span class="string">"background:yellow"</span>,</span><br><span class="line">        html: <span class="string">"这个panel不会显示，因为是fit布局"</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> NoFitLayout = <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">    title: <span class="string">"NoFitLayout"</span>,</span><br><span class="line">    height: <span class="number">100</span>,</span><br><span class="line">    <span class="comment">//将面板显示到HTML中：</span></span><br><span class="line">    <span class="comment">//&lt;div id="FitLayout" style="width: 300px; float: left; height: 200px; padding-left: 10px;"&gt;&lt;/div&gt;</span></span><br><span class="line">    renderTo: <span class="string">"FitLayout"</span>,</span><br><span class="line">    items: [</span><br><span class="line">      <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">        bodyStyle: <span class="string">"background:yellow"</span>,</span><br><span class="line">        html: <span class="string">"未使用了fit布局,没有填充满"</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="7-TableLayout"><a href="#7-TableLayout" class="headerlink" title="7.TableLayout"></a>7.TableLayout</h2><p><strong>介绍</strong>：表格布局，含有行与列的概念</p>
<h3 id="7-1-展示"><a href="#7-1-展示" class="headerlink" title="7.1 展示"></a>7.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/c34b732d4c43f42e62044916ec83fd25e9f162da/TableLayout.png" alt="TableLayout"></p>
<h3 id="7-2-代码"><a href="#7-2-代码" class="headerlink" title="7.2 代码"></a>7.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Ext.onReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> TableLayout = <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">    title: <span class="string">"TableLayout"</span>,</span><br><span class="line">    layout: <span class="string">"table"</span>,</span><br><span class="line">    layoutConfig: &#123; <span class="attr">columns</span>: <span class="number">3</span> &#125;,</span><br><span class="line">    defaults: &#123;</span><br><span class="line">      width: <span class="number">133</span>,</span><br><span class="line">      height: <span class="number">100</span>,</span><br><span class="line">      autoEl: <span class="string">"center"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    defaultType: <span class="string">"panel"</span>,</span><br><span class="line">    items: [</span><br><span class="line">      &#123; <span class="attr">html</span>: <span class="string">"行1列1"</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">html</span>: <span class="string">"行1列2"</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">html</span>: <span class="string">"行[1,2]列3"</span>, <span class="attr">rowspan</span>: <span class="number">2</span>, <span class="attr">height</span>: <span class="number">180</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">html</span>: <span class="string">"行2列[1,2]"</span>, <span class="attr">colspan</span>: <span class="number">2</span>, <span class="attr">width</span>: <span class="number">266</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">//将面板显示到HTML中：</span></span><br><span class="line">    <span class="comment">//&lt;div id="TableLayout" style="width: 400px; float: left; padding-left: 10px;"&gt;&lt;/div&gt;</span></span><br><span class="line">    renderTo: <span class="string">"TableLayout"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>extjs</category>
      </categories>
      <tags>
        <tag>extjs</tag>
      </tags>
  </entry>
  <entry>
    <title>Extjs-lesson7</title>
    <url>/Extjs-lesson7/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p><code>Ext.js</code> 系列课程笔记「Ajax」</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-Ajax"><a href="#1-Ajax" class="headerlink" title="1.Ajax"></a>1.Ajax</h2><p>学习一个框架最重要的便是数据交互部分，拒绝一切花里胡哨，直接上示例</p>
<h3 id="1-1-展示"><a href="#1-1-展示" class="headerlink" title="1.1 展示"></a>1.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/0b7cb0607e41016236252be5e77d7eb6a616a6ac/ajax.png" alt="Ajax"></p>
<h3 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h3><p>前端 <code>js</code> 代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Ext.onReady(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建panel</span></span><br><span class="line">    <span class="keyword">var</span> panel = <span class="keyword">new</span> Ext.Panel(&#123;</span><br><span class="line">        title: <span class="string">'Ajax与数据显示'</span>,</span><br><span class="line">        width: <span class="number">476</span>,</span><br><span class="line">        height: <span class="number">374</span>,</span><br><span class="line">        resizable: <span class="literal">true</span>,</span><br><span class="line">        frame: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//创建数据显示模板</span></span><br><span class="line">    <span class="keyword">var</span> template = <span class="keyword">new</span> Ext.XTemplate(</span><br><span class="line">                <span class="string">'&lt;table  id="template"&gt;'</span>,</span><br><span class="line">                   <span class="string">'&lt;tr&gt;&lt;td&gt;编号:&lt;/td&gt;&lt;td&gt;&#123;id&#125;&lt;/td&gt;&lt;/tr&gt;'</span>,</span><br><span class="line">                   <span class="string">'&lt;tr&gt;&lt;td&gt;姓名:&lt;/td&gt;&lt;td&gt;&#123;name&#125;&lt;/td&gt;&lt;/tr&gt;'</span>,</span><br><span class="line">                   <span class="string">'&lt;tr&gt;&lt;td&gt;生日:&lt;/td&gt;&lt;td&gt;&#123;brithday&#125;&lt;/td&gt;&lt;/tr&gt;'</span>,</span><br><span class="line">                   <span class="string">'&lt;tr&gt;&lt;td&gt;身高:&lt;/td&gt;&lt;td&gt;&#123;height&#125;&lt;/td&gt;&lt;/tr&gt;'</span>,</span><br><span class="line">                   <span class="string">'&lt;tr&gt;&lt;td&gt;性别:&lt;/td&gt;&lt;td&gt;&#123;sex&#125;&lt;/td&gt;&lt;/tr&gt;'</span>,</span><br><span class="line">                   <span class="string">'&lt;tr&gt;&lt;td valign="top"&gt;描述:&lt;/td&gt;&lt;td&gt;&#123;discribe&#125;&lt;/td&gt;&lt;/tr&gt;'</span>,</span><br><span class="line">                <span class="string">'&lt;/table&gt;'</span></span><br><span class="line">            );</span><br><span class="line">    <span class="comment">//获取数据</span></span><br><span class="line">    Ext.Ajax.request(&#123;</span><br><span class="line">        url: <span class="string">'/demo/people/'</span>,</span><br><span class="line">        method: <span class="string">'post'</span>,</span><br><span class="line">        params: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">response, options</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> options) &#123;</span><br><span class="line">                alert(<span class="string">'options参数名称:'</span> + i);</span><br><span class="line">                alert(<span class="string">'options参数['</span> + i + <span class="string">']的值：'</span> + options[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> responseJson = Ext.util.JSON.decode(response.responseText);</span><br><span class="line">            template.compile();</span><br><span class="line">            template.overwrite(panel.body, responseJson);</span><br><span class="line">        &#125;,</span><br><span class="line">        failure: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">'系统出错，请联系管理人员！'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//创建窗体</span></span><br><span class="line">    <span class="keyword">var</span> win = <span class="keyword">new</span> Ext.Window(&#123;</span><br><span class="line">        title: <span class="string">'窗口'</span>,</span><br><span class="line">        id: <span class="string">'window'</span>,</span><br><span class="line">        width: <span class="number">476</span>,</span><br><span class="line">        height: <span class="number">374</span>,</span><br><span class="line">        resizable: <span class="literal">true</span>,</span><br><span class="line">        modal: <span class="literal">true</span>,</span><br><span class="line">        closable: <span class="literal">true</span>,</span><br><span class="line">        maximizable: <span class="literal">true</span>,</span><br><span class="line">        minimizable: <span class="literal">true</span>,</span><br><span class="line">        items: [panel]</span><br><span class="line">    &#125;);</span><br><span class="line">    win.show();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>后端 <code>python</code> 代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render_to_response</span><br><span class="line"></span><br><span class="line"><span class="comment"># url:/demo/people/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPeople</span><span class="params">(request)</span>:</span></span><br><span class="line">    id = request.POST.get(<span class="string">'id'</span>)</span><br><span class="line">    <span class="keyword">if</span> id == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">"id"</span>: <span class="number">1</span>, <span class="string">"name"</span>: <span class="string">'小闫同学'</span>, <span class="string">"brithday"</span>: <span class="string">"2001-05-21"</span>, <span class="string">"height"</span>: <span class="number">180</span>, <span class="string">"sex"</span>: <span class="string">'0'</span>, <span class="string">"discribe"</span>: <span class="string">'小闫同学是一名全栈开发工程师&lt;br&gt;欢迎关注公众号：全栈技术精选。'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># url:/demo/index</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_to_response(<span class="string">'test_ajax/index.html'</span>)</span><br></pre></td></tr></table></figure>



<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>extjs</category>
      </categories>
      <tags>
        <tag>extjs</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask如何处理一个请求</title>
    <url>/Flask%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>客户端发起一个请求，<code>Flask</code> 都干了什么呢？<code>url</code> 如何与视图进行绑定的？</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-过程简述"><a href="#1-过程简述" class="headerlink" title="1.过程简述"></a>1.过程简述</h2><p>1) 创建请求上下文</p>
<p>2) 创建应用上下文</p>
<p>3) 把上下文压入栈</p>
<p>4) 执行请求钩子 <code>before_first_request</code> 的相关操作</p>
<p>5) 执行请求钩子 <code>before_request</code> 的相关操作</p>
<p>6) 路由</p>
<p>7) 执行请求钩子 <code>after_request</code> 的相关操作</p>
<p>8) 执行请求钩子 <code>teardown_request</code> 的相关操作</p>
<p>9) 把上下文弹出栈</p>
<p>10) 返回响应结果</p>
<h2 id="2-过程详述"><a href="#2-过程详述" class="headerlink" title="2.过程详述"></a>2.过程详述</h2><h3 id="2-1-wsgi-接口"><a href="#2-1-wsgi-接口" class="headerlink" title="2.1 wsgi 接口"></a>2.1 wsgi 接口</h3><p>总所周知，客户端每次发起请求，服务器都会调用框架实现的 <code>wsgi</code> 接口进行通讯。在 <code>Flask</code> 中，每个请求都会先调用 <code>Flask.__call__</code> 方法，而此方法又调用了 <code>Flask.wsgi_app</code> ，它便是 <code>Flask</code> 中的 <code>wsgi</code> 接口了。接下来我们结合源码进行说明。</p>
<blockquote>
<p>小闫使用的版本为 <code>flask1.1.2</code>，以下所有源码都源自于此版本，并以 <code>wsgi_app</code> 方法展开描述。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># flask/app.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span><span class="params">(_PackageBoundObject)</span>:</span></span><br><span class="line"></span><br><span class="line">    ... 省略其他方法</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        <span class="string">"""The actual WSGI application. </span></span><br><span class="line"><span class="string">        ... 此处省略一些说明</span></span><br><span class="line"><span class="string">        :param environ: A WSGI environment. 环境字典，包含全部 HTTP 请求信息</span></span><br><span class="line"><span class="string">        :param start_response: A callable accepting a status code,</span></span><br><span class="line"><span class="string">            a list of headers, and an optional exception context to</span></span><br><span class="line"><span class="string">            start the response. 回调函数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 创建请求上下文（过程中创建了应用上下文）</span></span><br><span class="line">        ctx = self.request_context(environ)</span><br><span class="line">        error = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 上下文入栈</span></span><br><span class="line">                ctx.push()</span><br><span class="line">                <span class="comment"># 路由</span></span><br><span class="line">                response = self.full_dispatch_request()</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                error = e</span><br><span class="line">                response = self.handle_exception(e)</span><br><span class="line">            <span class="keyword">except</span>:  <span class="comment"># noqa: B001</span></span><br><span class="line">                error = sys.exc_info()[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">            <span class="comment"># 返回响应结果</span></span><br><span class="line">            <span class="keyword">return</span> response(environ, start_response)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">if</span> self.should_ignore_error(error):</span><br><span class="line">                error = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 上下文出栈</span></span><br><span class="line">            ctx.auto_pop(error)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        <span class="string">"""The WSGI server calls the Flask application object as the</span></span><br><span class="line"><span class="string">        WSGI application. This calls :meth:`wsgi_app` which can be</span></span><br><span class="line"><span class="string">        wrapped to applying middleware."""</span></span><br><span class="line">        <span class="keyword">return</span> self.wsgi_app(environ, start_response)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-创建上下文"><a href="#2-2-创建上下文" class="headerlink" title="2.2 创建上下文"></a>2.2 创建上下文</h3><p>结合上面提供的 <code>wsgi_app</code> 源码，我们可以看到先执行了如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ctx = self.request_context(environ)</span><br></pre></td></tr></table></figure>

<p>此处便是创建上下文操作。框架会先去创建请求上下文，并去判断是否有应用上下文，以及应用上下文与当前应用是否一致，然后决定是否去创建一个应用上下文。如下便是依次进行调用的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># flask/app.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span><span class="params">(_PackageBoundObject)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request_context</span><span class="params">(self, environ)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> RequestContext(self, environ)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># flask/ctx.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestContext</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self)</span>:</span></span><br><span class="line">        top = _request_ctx_stack.top</span><br><span class="line">        <span class="keyword">if</span> top <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> top.preserved:</span><br><span class="line">            top.pop(top._preserved_exc)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从栈中弹出一个应用上下文</span></span><br><span class="line">        app_ctx = _app_ctx_stack.top</span><br><span class="line">        <span class="comment"># 判断应用上下文是否存在并与当前应用一致</span></span><br><span class="line">        <span class="keyword">if</span> app_ctx <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> app_ctx.app != self.app:</span><br><span class="line">            <span class="comment"># 创建应用上下文</span></span><br><span class="line">            app_ctx = self.app.app_context()</span><br><span class="line">            <span class="comment"># 入栈</span></span><br><span class="line">            app_ctx.push()</span><br><span class="line">            self._implicit_app_ctx_stack.append(app_ctx)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._implicit_app_ctx_stack.append(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hasattr(sys, <span class="string">"exc_clear"</span>):</span><br><span class="line">            sys.exc_clear()</span><br><span class="line"></span><br><span class="line">        _request_ctx_stack.push(self)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.session <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            session_interface = self.app.session_interface</span><br><span class="line">            self.session = session_interface.open_session(self.app, self.request)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.session <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self.session = session_interface.make_null_session(self.app)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.url_adapter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.match_request()</span><br></pre></td></tr></table></figure>


<h3 id="2-3-请求钩子"><a href="#2-3-请求钩子" class="headerlink" title="2.3 请求钩子"></a>2.3 请求钩子</h3><p>如果在代码中定义了四种请求钩子，那么它们会按照如下顺序执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">before_first_request --&gt; before_request</span><br><span class="line">before_request --&gt; after_request</span><br><span class="line">after_request --&gt; teardown_request</span><br></pre></td></tr></table></figure>

<p>1.<code>before_first_request</code>:在处理第一个请求前执行</p>
<p>2.<code>before_request</code>:在每次请求前执行,在该装饰函数中,一旦return,视图函数不再执行</p>
<p>3.<code>after_request</code>:如果没有抛出错误，在每次请求后执行</p>
<pre><code>a.接受一个参数：视图函数作出的响应
b.在此函数中可以对响应值,在返回之前做最后一步处理,再返回</code></pre><p>4.teardown_request：在每次请求后执行</p>
<pre><code>a.接受一个参数:用来接收错误信息</code></pre><h3 id="2-4-路由"><a href="#2-4-路由" class="headerlink" title="2.4 路由"></a>2.4 路由</h3><p>在 <code>wsgi_app</code> 方法中如下代码便会进行请求分发：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = self.full_dispatch_request()</span><br></pre></td></tr></table></figure>

<p>下面将所涉及到的方法源码依次列出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># flask/app.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span><span class="params">(_PackageBoundObject)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">full_dispatch_request</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Dispatches the request and on top of that performs request</span></span><br><span class="line"><span class="string">        pre and postprocessing as well as HTTP exception catching and</span></span><br><span class="line"><span class="string">        error handling.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 首次处理请求前的操作，通过 @before_first_request 定义，也就是我们的请求钩子</span></span><br><span class="line">        self.try_trigger_before_first_request_functions()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            request_started.send(self)</span><br><span class="line">            <span class="comment"># 每次处理请求前进行的操作, 通过 @before_request 来定义</span></span><br><span class="line">            rv = self.preprocess_request()</span><br><span class="line">            <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 调用 dispatch_request 函数匹配 url，执行请求调度</span></span><br><span class="line">                rv = self.dispatch_request()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            rv = self.handle_user_exception(e)</span><br><span class="line">        <span class="comment"># 调用 finalize_request 方法将视图函数的返回值转换成一个真正的响应对象</span></span><br><span class="line">        <span class="keyword">return</span> self.finalize_request(rv)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Does the request dispatching.  Matches the URL and returns the</span></span><br><span class="line"><span class="string">        return value of the view or error handler.  This does not have to</span></span><br><span class="line"><span class="string">        be a response object.  In order to convert the return value to a</span></span><br><span class="line"><span class="string">        proper response object, call :func:`make_response`.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        req = _request_ctx_stack.top.request</span><br><span class="line">        <span class="keyword">if</span> req.routing_exception <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.raise_routing_exception(req)</span><br><span class="line">        rule = req.url_rule</span><br><span class="line">        <span class="comment"># if we provide automatic options for this URL and the</span></span><br><span class="line">        <span class="comment"># request came with the OPTIONS method, reply automatically</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            getattr(rule, <span class="string">"provide_automatic_options"</span>, <span class="literal">False</span>)</span><br><span class="line">            <span class="keyword">and</span> req.method == <span class="string">"OPTIONS"</span></span><br><span class="line">        ):</span><br><span class="line">            <span class="keyword">return</span> self.make_default_options_response()</span><br><span class="line">        <span class="comment"># otherwise dispatch to the handler for that endpoint</span></span><br><span class="line">        <span class="keyword">return</span> self.view_functions[rule.endpoint](**req.view_args)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finalize_request</span><span class="params">(self, rv, from_error_handler=False)</span>:</span></span><br><span class="line">        <span class="string">"""Given the return value from a view function this finalizes</span></span><br><span class="line"><span class="string">        the request by converting it into a response and invoking the</span></span><br><span class="line"><span class="string">        postprocessing functions.  This is invoked for both normal</span></span><br><span class="line"><span class="string">        request dispatching as well as error handlers.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Because this means that it might be called as a result of a</span></span><br><span class="line"><span class="string">        failure a special safe mode is available which can be enabled</span></span><br><span class="line"><span class="string">        with the `from_error_handler` flag.  If enabled, failures in</span></span><br><span class="line"><span class="string">        response processing will be logged and otherwise ignored.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :internal:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        response = self.make_response(rv)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 每次正常处理请求后进行的操作, 通过 @after_request 来定义</span></span><br><span class="line">            response = self.process_response(response)</span><br><span class="line">            request_finished.send(self, response=response)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> from_error_handler:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">            self.logger.exception(</span><br><span class="line">                <span class="string">"Request finalizing failed with an error while handling an error"</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<h3 id="2-5-路由表的创建"><a href="#2-5-路由表的创建" class="headerlink" title="2.5 路由表的创建"></a>2.5 路由表的创建</h3><p>下面是一个最简单的视图，其作用便是在访问根目录时，返回 <code>Hello World</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br></pre></td></tr></table></figure>

<p>你有没有想过视图函数与 <code>url</code> 是如何绑定的呢？它是通过方法 <code>add_url_rule</code> 创建的路由规则，下面我们来看一下源码：</p>
<p>1) 先查看一下 <code>@app.route</code> 装饰器干了哪些工作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># flask/app.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span><span class="params">(_PackageBoundObject)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(self, rule, **options)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">            <span class="comment"># 获取 endpoint，可以看作为每个 view_func 的 ID</span></span><br><span class="line">            endpoint = options.pop(<span class="string">"endpoint"</span>, <span class="literal">None</span>)</span><br><span class="line">            <span class="comment"># 调用 add_url_rule 方法添加路由信息</span></span><br><span class="line">            self.add_url_rule(rule, endpoint, f, **options)</span><br><span class="line">            <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure>

<p>2) 然后就来看看 <code>add_url_rule</code> 为何方神圣。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># flask/app.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span><span class="params">(_PackageBoundObject)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义view_functions</span></span><br><span class="line">    self.view_functions = &#123;&#125;</span><br><span class="line">    <span class="comment"># 定义url_map</span></span><br><span class="line">    self.url_map = Map()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @setupmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_url_rule</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        rule,</span></span></span><br><span class="line"><span class="function"><span class="params">        endpoint=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        view_func=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        provide_automatic_options=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        **options</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span>:</span></span><br><span class="line">        <span class="keyword">if</span> endpoint <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            endpoint = _endpoint_from_view_func(view_func)</span><br><span class="line">        options[<span class="string">"endpoint"</span>] = endpoint</span><br><span class="line">        methods = options.pop(<span class="string">"methods"</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if the methods are not given and the view_func object knows its</span></span><br><span class="line">        <span class="comment"># methods we can use that instead.  If neither exists, we go with</span></span><br><span class="line">        <span class="comment"># a tuple of only ``GET`` as default.</span></span><br><span class="line">        <span class="keyword">if</span> methods <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            methods = getattr(view_func, <span class="string">"methods"</span>, <span class="literal">None</span>) <span class="keyword">or</span> (<span class="string">"GET"</span>,)</span><br><span class="line">        <span class="keyword">if</span> isinstance(methods, string_types):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(</span><br><span class="line">                <span class="string">"Allowed methods have to be iterables of strings, "</span></span><br><span class="line">                <span class="string">'for example: @app.route(..., methods=["POST"])'</span></span><br><span class="line">            )</span><br><span class="line">        methods = set(item.upper() <span class="keyword">for</span> item <span class="keyword">in</span> methods)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Methods that should always be added</span></span><br><span class="line">        required_methods = set(getattr(view_func, <span class="string">"required_methods"</span>, ()))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># starting with Flask 0.8 the view_func object can disable and</span></span><br><span class="line">        <span class="comment"># force-enable the automatic options handling.</span></span><br><span class="line">        <span class="keyword">if</span> provide_automatic_options <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            provide_automatic_options = getattr(</span><br><span class="line">                view_func, <span class="string">"provide_automatic_options"</span>, <span class="literal">None</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> provide_automatic_options <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"OPTIONS"</span> <span class="keyword">not</span> <span class="keyword">in</span> methods:</span><br><span class="line">                provide_automatic_options = <span class="literal">True</span></span><br><span class="line">                required_methods.add(<span class="string">"OPTIONS"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                provide_automatic_options = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add the required methods now.</span></span><br><span class="line">        methods |= required_methods</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建 rule</span></span><br><span class="line">        rule = self.url_rule_class(rule, methods=methods, **options)</span><br><span class="line">        rule.provide_automatic_options = provide_automatic_options</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 把 rule 添加到 url_map</span></span><br><span class="line">        self.url_map.add(rule)</span><br><span class="line">        <span class="keyword">if</span> view_func <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            old_func = self.view_functions.get(endpoint)</span><br><span class="line">            <span class="keyword">if</span> old_func <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> old_func != view_func:</span><br><span class="line">                <span class="keyword">raise</span> AssertionError(</span><br><span class="line">                    <span class="string">"View function mapping is overwriting an "</span></span><br><span class="line">                    <span class="string">"existing endpoint function: %s"</span> % endpoint</span><br><span class="line">                )</span><br><span class="line">             <span class="comment"># 把 view_func 添加到 view_functions 字典</span></span><br><span class="line">            self.view_functions[endpoint] = view_func</span><br></pre></td></tr></table></figure>


<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Extjs-lesson5</title>
    <url>/Extjs-lesson5/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p><code>Ext.js</code> 系列课程笔记「表单子项二」</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="9-下拉菜单二级联动"><a href="#9-下拉菜单二级联动" class="headerlink" title="9.下拉菜单二级联动"></a>9.下拉菜单二级联动</h2><h3 id="9-1-展示"><a href="#9-1-展示" class="headerlink" title="9.1 展示"></a>9.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/07b7355a50ae630e96605fa2869ccc2fcb319e9a/%E4%BA%8C%E7%BA%A7%E8%81%94%E5%8A%A8.png" alt="Combobox_Two"></p>
<h3 id="9-2-代码"><a href="#9-2-代码" class="headerlink" title="9.2 代码"></a>9.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建市数据源</span></span><br><span class="line"><span class="keyword">var</span> combocitystore = <span class="keyword">new</span> Ext.data.Store(&#123;</span><br><span class="line">  <span class="comment">//设定读取的代理，添加后端地址</span></span><br><span class="line">  proxy: <span class="keyword">new</span> Ext.data.HttpProxy(&#123; <span class="attr">url</span>: <span class="string">"/demo/city"</span> &#125;),</span><br><span class="line">  <span class="comment">//设定读取的格式</span></span><br><span class="line">  <span class="comment">//读取json返回值 - 根节点为data，对象列为id和name</span></span><br><span class="line">  <span class="comment">//服务器返回数据：&#123;"data": [&#123;"id": 1, "name": "北京"&#125;,&#123;"id": 2, "name":"上海"&#125;]&#125;</span></span><br><span class="line">  reader: <span class="keyword">new</span> Ext.data.JsonReader(&#123; <span class="attr">root</span>: <span class="string">"data"</span> &#125;, [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"id"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"name"</span> &#125;</span><br><span class="line">  ])</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//创建区数据源</span></span><br><span class="line"><span class="keyword">var</span> comboareastore = <span class="keyword">new</span> Ext.data.Store(&#123;</span><br><span class="line">  <span class="comment">//设定读取的代理，添加后端地址</span></span><br><span class="line">  proxy: <span class="keyword">new</span> Ext.data.HttpProxy(&#123; <span class="attr">url</span>: <span class="string">"/demo/area"</span> &#125;),</span><br><span class="line">  <span class="comment">//读取json返回值 - 根节点为data，对象列为id和name</span></span><br><span class="line">  <span class="comment">//服务器返回数据示例：&#123;"data": [&#123;"id": 1, "name": "东城区"&#125;,&#123;"id": 2, "name": "西城区"&#125;,&#123;"id": 2, "name": "海淀区"&#125;]&#125;</span></span><br><span class="line">  reader: <span class="keyword">new</span> Ext.data.JsonReader(&#123; <span class="attr">root</span>: <span class="string">"data"</span> &#125;, [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"id"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"name"</span> &#125;</span><br><span class="line">  ])</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//创建市Combobox</span></span><br><span class="line"><span class="keyword">var</span> comboboxcity = <span class="keyword">new</span> Ext.form.ComboBox(&#123;</span><br><span class="line">  id: <span class="string">"comboboxcity"</span>,</span><br><span class="line">  <span class="comment">//框前面的文字（标签）</span></span><br><span class="line">  fieldLabel: <span class="string">"市"</span>,</span><br><span class="line">  <span class="comment">//宽度</span></span><br><span class="line">  width: <span class="number">120</span>,</span><br><span class="line">  <span class="comment">//数据源为市数据源</span></span><br><span class="line">  store: combocitystore,</span><br><span class="line">  <span class="comment">//显示的列</span></span><br><span class="line">  displayField: <span class="string">"name"</span>,</span><br><span class="line">  <span class="comment">//对应的值列</span></span><br><span class="line">  valueField: <span class="string">"id"</span>,</span><br><span class="line">  <span class="comment">//请设置为”all”,否则默认为”query”的情况下，你选择某个值后，再此下拉时，只出现匹配选项</span></span><br><span class="line">  triggerAction: <span class="string">"all"</span>,</span><br><span class="line">  <span class="comment">//默认显示提示文字</span></span><br><span class="line">  emptyText: <span class="string">"请选择..."</span>,</span><br><span class="line">  <span class="comment">//不允许为空</span></span><br><span class="line">  allowBlank: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">//校验为空时的提示文字</span></span><br><span class="line">  blankText: <span class="string">"请选择市"</span>,</span><br><span class="line">  <span class="comment">//不可编辑</span></span><br><span class="line">  editable: <span class="literal">false</span>,</span><br><span class="line">  mode: <span class="string">"local"</span>, <span class="comment">//该属性和以下方法为了兼容ie8</span></span><br><span class="line">  listeners: &#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      combocitystore.load();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建区Combobox</span></span><br><span class="line"><span class="keyword">var</span> comboareacity = <span class="keyword">new</span> Ext.form.ComboBox(&#123;</span><br><span class="line">  <span class="comment">//框前面的文字（标签）</span></span><br><span class="line">  fieldLabel: <span class="string">"区"</span>,</span><br><span class="line">  <span class="comment">//宽度</span></span><br><span class="line">  width: <span class="number">120</span>,</span><br><span class="line">  <span class="comment">//数据源为区数据源</span></span><br><span class="line">  store: comboareastore,</span><br><span class="line">  <span class="comment">//显示的列</span></span><br><span class="line">  displayField: <span class="string">"name"</span>,</span><br><span class="line">  <span class="comment">//对应的值列</span></span><br><span class="line">  valueField: <span class="string">"id"</span>,</span><br><span class="line">  <span class="comment">//请设置为”all”,否则默认为”query”的情况下，你选择某个值后，再此下拉时，只出现匹配选项</span></span><br><span class="line">  triggerAction: <span class="string">"all"</span>,</span><br><span class="line">  <span class="comment">//默认显示提示文字</span></span><br><span class="line">  emptyText: <span class="string">"请选择..."</span>,</span><br><span class="line">  <span class="comment">//不允许为空</span></span><br><span class="line">  allowBlank: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">//校验为空时的提示文字</span></span><br><span class="line">  blankText: <span class="string">"请选择区"</span>,</span><br><span class="line">  <span class="comment">//不可编辑</span></span><br><span class="line">  editable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//联动的实现</span></span><br><span class="line">comboboxcity.on(<span class="string">"select"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//注意等号左边comboareastore是区的数据源,当市变化时，给区的数据源加上个向service端发送的参数</span></span><br><span class="line">  comboareastore.baseParams.id = comboboxcity.getValue();</span><br><span class="line">  <span class="comment">//把区的下拉列表设置为空，由于非空验证，Ext会提示用户“请选择区”</span></span><br><span class="line">  comboareacity.setValue(<span class="string">""</span>);</span><br><span class="line">  <span class="comment">//区的数据源重新加载</span></span><br><span class="line">  comboareastore.load();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="10-FileUploadField"><a href="#10-FileUploadField" class="headerlink" title="10.FileUploadField"></a>10.FileUploadField</h2><h3 id="10-1-展示"><a href="#10-1-展示" class="headerlink" title="10.1 展示"></a>10.1 展示</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/cbb3848f687e75d1ebf3a5598a1dac5ea09adb21/fileupload.png" alt="File"></p>
<h3 id="10-2-代码"><a href="#10-2-代码" class="headerlink" title="10.2 代码"></a>10.2 代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Ext.onReady(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//初始化提示信息</span></span><br><span class="line">  Ext.QuickTips.init();</span><br><span class="line">	<span class="comment">//定义函数，弹窗</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="function"><span class="keyword">function</span>(<span class="params">title, msg</span>) </span>&#123;</span><br><span class="line">    Ext.Msg.show(&#123;</span><br><span class="line">      <span class="comment">//消息框的标题栏文字</span></span><br><span class="line">      title: title,</span><br><span class="line">      <span class="comment">//提示信息</span></span><br><span class="line">      msg: msg,</span><br><span class="line">      <span class="comment">//宽度</span></span><br><span class="line">      minWidth: <span class="number">200</span>,</span><br><span class="line">      <span class="comment">//模态窗体：打开此窗体后，不能对其他窗体进行操作</span></span><br><span class="line">      modal: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">//显示图标</span></span><br><span class="line">      icon: Ext.Msg.INFO,</span><br><span class="line">      <span class="comment">//显示 ok 按钮</span></span><br><span class="line">      buttons: Ext.Msg.OK</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 文件上传框</span></span><br><span class="line">  <span class="keyword">var</span> fibasic = <span class="keyword">new</span> Ext.form.FileUploadField(&#123;</span><br><span class="line">    <span class="comment">//传到html中的标签中：&lt;div id="fi-basic"&gt;&lt;/div&gt;</span></span><br><span class="line">    renderTo: <span class="string">"fi-basic"</span>,</span><br><span class="line">    <span class="comment">//宽</span></span><br><span class="line">    width: <span class="number">400</span></span><br><span class="line">  &#125;);</span><br><span class="line">	<span class="comment">//创建一个按钮</span></span><br><span class="line">  <span class="keyword">new</span> Ext.Button(&#123;</span><br><span class="line">    <span class="comment">//按钮显示文本</span></span><br><span class="line">    text: <span class="string">"Get File Path"</span>,</span><br><span class="line">    <span class="comment">//传到HTML中的标签中：&lt;div id="fi-basic-btn"&gt;&lt;/div&gt;</span></span><br><span class="line">    renderTo: <span class="string">"fi-basic-btn"</span>,</span><br><span class="line">    <span class="comment">//处理函数</span></span><br><span class="line">    handler: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//获取 id 为 fibasic 的值</span></span><br><span class="line">      <span class="keyword">var</span> v = fibasic.getValue();</span><br><span class="line">      <span class="comment">//使用 msg 函数，如果文件上传框中有值，那么显示文件的路径；如果没有值，显示 None</span></span><br><span class="line">      msg(<span class="string">"Selected File"</span>, v &amp;&amp; v != <span class="string">""</span> ? v : <span class="string">"None"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>extjs</category>
      </categories>
      <tags>
        <tag>extjs</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 上传大文件</title>
    <url>/Git%20%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
我们知道 github 上面限制每次推送的文件不能超过 100M，否则报错失败，那么非要推送大文件呢？有没有什么解决办法呢？答案当然是肯定的。这就用到了 `Git LFS` 。

 <a id="more"></a> 

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>因为只试验了 windows 平台，本文以此为例。其他系统可上网搜如何下载安装对应版本的 <code>git-lfs</code>。</p>
<h2 id="1-windows-平台安装-git-lfs"><a href="#1-windows-平台安装-git-lfs" class="headerlink" title="1.windows 平台安装 git-lfs"></a>1.windows 平台安装 git-lfs</h2><p>1.先打开网址：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">https://github.com/git-lfs/git-lfs/releases</span></span><br></pre></td></tr></table></figure>

<p>2.然后点击最新版本的版本号，将页面拉取到最底部，下载安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Windows Installer</span><br></pre></td></tr></table></figure>

<p>3.运行下载的 exe 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">windows installer</span><br></pre></td></tr></table></figure>

<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><p>1.打开 <code>git bash</code>，首先输入下列命令开启 lfs 功能：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure>

<p>2.然后使用如下命令进行大文件追踪，然后会生成文件 <code>.gitattributes</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git lfs track '大文件名'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 追踪大文件test.tar.gz</span></span><br><span class="line">git lfs track 'test.tar.gz'</span><br></pre></td></tr></table></figure>

<p>3.添加文件 <code>.gittributes</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .gitattributes</span><br></pre></td></tr></table></figure>

<p>4.然后提交文件 <code>.gitattributes</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m 'submit .gitattributes file'</span><br></pre></td></tr></table></figure>

<p>5.将文件 <code>.gitattributes</code> 推送到远程仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>6.添加大文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add test.tar.gz</span><br></pre></td></tr></table></figure>

<p>7.提交大文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m 'submit big file.'</span><br></pre></td></tr></table></figure>

<p>8.直接推送大文件到远程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>然后你就会发现大文件推送到远程的 github 仓库了。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 彻底删除某个commit的方法</title>
    <url>/Git-%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AAcommit%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
如果因为一些原因，需要删除某个错误的  commit ，而且需要干净的操作，彻底让其消失，不留痕迹，该如何操作？

 <a id="more"></a> 

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<blockquote>
<p>我向仓库提交了一个大文件，大约 300M，push 失败（因为 git 最大能提交 100M 文件），删除本地文件不行，尝试过修改配置文件，解除 git 只能提交小于 100M 文件的限制，但是未起作用。只能通过删除包含提交此文件的 commit 解决。</p>
</blockquote>
<p>废话少说，直奔主题。</p>
<p>1.首先输入如下命令查看历史提交的 commit：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重要的是<strong>记下</strong>要删除的 commit 的<strong>上一条</strong> commit 的 <strong>commit号</strong>。如下图，如果要删除箭头所指的 commit，需要记录红框中的 commit号：</p>
</blockquote>
<p><img src="https://github.com/EthanYan6/pic/raw/master/Git-%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AAcommit%E7%9A%84%E6%96%B9%E6%B3%95/gitlog.png" alt="gitlog"></p>
<p>2.然后执行如下的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase -i commit号</span><br></pre></td></tr></table></figure>

<p>会出现如下界面：</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/Git-%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AAcommit%E7%9A%84%E6%96%B9%E6%B3%95/gitrebase.png" alt="gitrebase"></p>
<p>3.然后将要删除的 commit号 的前缀 <code>pick</code> 改为 <code>drop</code>。</p>
<p>4.然后可以通过如下命令再次查看是否已经删除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p>5.最后通过如下命令将现在的状态推送到远程仓库即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin HEAD -force</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop学习笔记(一)</title>
    <url>/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>大数据必备技能之 <code>Hadoop</code> ，你了解吗？</p>
<p>官方文档汇总：<a href="https://www.pythonnote.cn/OfficialDocuments/">https://www.pythonnote.cn/OfficialDocuments/</a></p>
<blockquote>
<p>包含了后端常使用的各种文档，小闫静心制作，快收藏起来吧 ~</p>
</blockquote>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h1 id="Hadoop-简介"><a href="#Hadoop-简介" class="headerlink" title="Hadoop 简介"></a>Hadoop 简介</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><code>Hadoop</code> 是阿帕奇基金会(<code>Apache</code>)开源的一款分布式系统基础架构。由以下几部分组成：<code>HDFS</code> 、<code>MapReduce</code> 和 <code>YARN</code> 。它使用户可以快速简便的开发分布式程序去处理数据，而不需掌握过多的分布式知识以及底层实现逻辑。</p>
<h2 id="2-发展史"><a href="#2-发展史" class="headerlink" title="2.发展史"></a>2.发展史</h2><p>1) 02年由 <code>Doug Cutting</code> 开发了一款网络搜索引擎 <code>Nutch</code> ，这便是 <code>Hadoop</code> 的前身。</p>
<p>2) 03年到04年诞生了 <code>GFS</code> 和 <code>Map Reduce</code>。</p>
<p>3) 08年 <code>Hadoop</code> 创造了最快排序 <code>1TB</code> 数据的新世界纪录。<code>Hive</code> 成为了它的子项目。</p>
<p>4) 11年 <code>Hadoop</code> 1.0.0版本出现。</p>
<p>5) 13年到15年 <code>Hadoop</code> 2.x版本诞生并不断更新迭代。</p>
<p>6) 16年  <code>Hadoop</code> 进入3.x时代。</p>
<h2 id="3-核心"><a href="#3-核心" class="headerlink" title="3.核心"></a>3.核心</h2><p>分布式文件系统 <code>HDFS</code> ；分布式计算系统 <code>MapReduce</code> ；分布式资源管理系统 <code>YARN</code> 。</p>
<h3 id="3-1-HDFS"><a href="#3-1-HDFS" class="headerlink" title="3.1 HDFS"></a>3.1 HDFS</h3><p><strong>核心（角色）：</strong><code>NameNode</code>、<code>DataNode</code></p>
<p><strong>作用：</strong>分布式文件存储</p>
<p><strong>特点：</strong>高可靠性、高扩展性、高吞吐率。</p>
<blockquote>
<p>副本可以保证高可靠性</p>
</blockquote>
<p><strong>原理：</strong><code>NameNode</code> 负责管理存储所有的元数据信息（文件系统的目录信息、文件信息以及分块等信息）。<code>DataNode</code> 负责管理存储块文件。<code>DataNode</code> 会定时向 <code>NameNode</code> 报告自己的状态（比如磁盘空间、资源消耗、是死是活），可将此过程称为心跳。当客户端发起一次读或写的请求，请求先到达 <code>NameNode</code> ，它判断一下读写权限，再查找一个可用并适合的 <code>DataNode</code> ，然后向客户端返回该 <code>DataNode</code> 的相关信息。客户端拿到节点信息后与其交互，进行读或写操作。完成后客户端拿到对应结果（读取的数据或者写结果状态信息），最后向 <code>NameNode</code> 反馈结果。</p>
<p>注意：<code>HDFS</code> 会将数据文件以指定的块大小拆分成数据块，并将数据块以副本的方式保存到不同的节点上。其中数据写入时采用的方式是先完成第一个副本，然后再将其复制到其他节点，保证一个节点出现异常，数据不会丢失。过程虽然复杂，但是用户无感知，所有的切分、容错、负载均衡等都悄悄的完成，使得用户只知道上传了一个文件或者读取了一个文件。</p>
<h3 id="3-2-MapReduce"><a href="#3-2-MapReduce" class="headerlink" title="3.2 MapReduce"></a>3.2 MapReduce</h3><p><strong>核心：</strong><code>Map</code>(映射)、<code>Reduce</code>(归纳)</p>
<p><strong>作用：</strong>大数据量计算</p>
<p><strong>特点：</strong>简化并行应用开发，不需要关注并行计算底层实现，而是直接调用所提供的 <code>API</code> 即可。</p>
<p><strong>原理：</strong>将输入的数据集切分为若干独立的数据块，由 <code>map</code> 任务以并行的方式处理。然后将 <code>map</code> 的输出先进性排序，然后再把结果输入 <code>reduce</code> 任务，由 <code>reduce</code> 任务来完成最终的统一处理。</p>
<p>注意：部署 <code>Hadoop</code> 集群时，通常计算节点和存储节点部署在同一节点，使作业优先调度到那些已经存储有数据的节点进行计算，这样可以大大节省数据传输消耗的带宽。</p>
<h3 id="3-3-YARN"><a href="#3-3-YARN" class="headerlink" title="3.3 YARN"></a>3.3 YARN</h3><p><strong>来源：</strong>是为了解除 <code>Hadoop1.x</code> 中只能运行 <code>MapReduce</code> 框架的限制，将 <code>MapReduce</code> 框架中 <code>Job Tracker</code> 的资源管理和作业调度监控功能进行分离。</p>
<p><strong>作用：</strong>为运行在 <code>YARN</code> 上的分布式应用程序提供统一的资源管理和调度</p>
<p><strong>特点：</strong>为 <code>Hadoop</code> 集群在利用率、资源统一管理和数据共享等方面带来了极大便利；可以运行不同类型的作业：<code>MapReduce</code> 、<code>Spark</code> 等计算框架。</p>
<h2 id="4-选择原因"><a href="#4-选择原因" class="headerlink" title="4.选择原因"></a>4.选择原因</h2><p>首先当然是它开源，免费的原因（你懂得 ~）。其次就是社区活跃，参与的人超多，这样一来，在使用过程中有任何问题，随时可以找到解决办法，而不需死扣晦涩的文档。还有它适用于大数据分布式存储和计算的各个场景，满足很多人的需求。最后就是它的成熟性，发展的十余年间，被各大企业所验证。</p>
<h2 id="5-版本"><a href="#5-版本" class="headerlink" title="5.版本"></a>5.版本</h2><p>1) 社区版（官方，免费，但可能需要自己再研发额外功能）</p>
<p>2) <code>Cloudera CDH</code> （目前公司使用最多，安装、配置、升级等简便，文档完善，与 <code>Spark</code> 结合好，但是不开源，而且和社区版在某些功能上有些出入）</p>
<p>3) <code>Hortonworks HDP</code> （原装 <code>Hadoop</code> ，开源，版本与社区版一致，支持 <code>Tez</code>，集成了开源监控方案 <code>Ganglia</code> 和 <code>Nagios</code>，但是安装升级等比较繁琐，需要费点功夫）</p>
<blockquote>
<p>学习自《基于Hadoop与Spark的大数据开发实战》</p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop学习笔记(三)之MapReduce</title>
    <url>/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p> <code>Hadoop</code> 之分布式计算框架，你了解吗？</p>
<p>官方文档汇总：<a href="https://www.pythonnote.cn/OfficialDocuments/">https://www.pythonnote.cn/OfficialDocuments/</a></p>
<blockquote>
<p>包含了后端常使用的各种文档，小闫静心制作，快收藏起来吧 ~</p>
</blockquote>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><h2 id="1-MapReduce-编程模型"><a href="#1-MapReduce-编程模型" class="headerlink" title="1.MapReduce 编程模型"></a>1.MapReduce 编程模型</h2><h3 id="1-1-基础"><a href="#1-1-基础" class="headerlink" title="1.1 基础"></a>1.1 基础</h3><h4 id="1-1-1-是什么？"><a href="#1-1-1-是什么？" class="headerlink" title="1.1.1 是什么？"></a>1.1.1 是什么？</h4><p>是谷歌开源的一种大数据并行计算编程模型，它降低了并行计算应用开发的门槛。</p>
<h4 id="1-1-2-设计目标"><a href="#1-1-2-设计目标" class="headerlink" title="1.1.2 设计目标"></a>1.1.2 设计目标</h4><p>1) 分而治之。采用分布式并行计算，将计算任务进行拆分，由主节点下的各个子节点共同完成，最后汇总各子节点的计算结果，得出最终计算结果。</p>
<p>2) 降低分布式并行编程的使用门槛。</p>
<h4 id="1-1-3-特点"><a href="#1-1-3-特点" class="headerlink" title="1.1.3 特点"></a>1.1.3 特点</h4><p>1) 简单，容易使用。</p>
<blockquote>
<p>只需要简单的实现一些接口，就可以完成一个分布式程序。</p>
</blockquote>
<p>2) 扩展性强。</p>
<blockquote>
<p>算力不足，加机器，就是这么简单粗暴。</p>
</blockquote>
<p>3) 高容错性。</p>
<blockquote>
<p>某个节点挂掉，<code>Hadoop</code> 可以自动将计算任务转移到另外一个节点上进行，不会使作业因为某个节点挂掉而整体失败。</p>
</blockquote>
<p>4) 可离线计算 <code>PB</code> 量级的数据。</p>
<blockquote>
<p>不适合实时处理，延迟较高。</p>
</blockquote>
<h4 id="1-1-4-避免以下场景使用"><a href="#1-1-4-避免以下场景使用" class="headerlink" title="1.1.4 避免以下场景使用"></a>1.1.4 避免以下场景使用</h4><p>1) 实时计算。</p>
<blockquote>
<p>因为延迟高，不适用实时计算。</p>
</blockquote>
<p>2) 流式计算。</p>
<blockquote>
<p><code>MapReduce</code> 输入数据集要求是静态的，而流式计算则要求动态数据。</p>
</blockquote>
<p>3) 有向图计算。</p>
<blockquote>
<p>有向图计算就是多个应用程序存在依赖关系，后一个应用程序的输入为前一个应用程序的输出。如果这种情况下使用 <code>MapReduce</code> ，会造成大量中间结果的磁盘 <code>IO</code> ，影响性能。</p>
</blockquote>
<h3 id="1-2-编程模型"><a href="#1-2-编程模型" class="headerlink" title="1.2 编程模型"></a>1.2 编程模型</h3><h4 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1 概述"></a>1.2.1 概述</h4><p><code>MapReduce</code> 可分为 <code>Map</code> 和 <code>Reduce</code> 两阶段，我们需要实现这两个函数来完成分布式程序设计。</p>
<p>1) <code>map()</code> 函数输入值为键值对，输出值为新的一组键值对。而 <code>MapReduce</code>  框架会自动将这些输出结果按照键 <code>key</code> 进行聚集（默认策略，也可以自定义聚集策略），键相同的数据被统一交给 <code>reduce</code> 函数。</p>
<p>2) <code>reduce()</code> 函数输入值为聚集后的键值对（键值对类似于 <code>key: [value1, value2, value3 ...]</code>），输出值为一组新的键值对。最后将最终结果写入 <code>HDFS</code> 。</p>
<h4 id="1-2-2-示例-统计词频"><a href="#1-2-2-示例-统计词频" class="headerlink" title="1.2.2 示例 - 统计词频"></a>1.2.2 示例 - 统计词频</h4><p><strong>需求：</strong>统计文件中每个单词出现的次数。</p>
<p><code>map()</code> 函数接收键值对（文件名: 文本内容），然后将文本内容中的单词都以新键值对输出（类似于 <code>hadoop: 1</code> 这种形式，遇到一个单词就将其转换成这样的键值对）。最终结果可能是这样的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;hadoop: 1&gt;&lt;mapreduce: 1&gt;&lt;hdfs: 1&gt;...</span><br></pre></td></tr></table></figure>

<p>然后 <code>MapReduce</code>  框架合并相同键的键值对，就变成了如下的样子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;hadoop: [1, 1, 1, 1]&gt;&lt;mapreduce: [1, 1]&gt;...</span><br></pre></td></tr></table></figure>

<p><code>reduce()</code> 函数接收一个键值对（<code>&lt;hadoop: [1, 1, 1, 1]&gt;</code>），并将其值（数组）进行累加，然后将结果 <code>&lt;hadoop: 4&gt;</code> 新的键值对输出，从而得出词频。</p>
<p><strong>部署步骤：</strong></p>
<p>1)  上传程序与测试文件数据</p>
<p>2) 提交 <code>MapReduce</code> 作业到集群中运行</p>
<p>3) 查看作业输出结果</p>
<h2 id="2-MapReduce-组件"><a href="#2-MapReduce-组件" class="headerlink" title="2.MapReduce 组件"></a>2.MapReduce 组件</h2><h3 id="2-1-Combiner"><a href="#2-1-Combiner" class="headerlink" title="2.1 Combiner"></a>2.1 Combiner</h3><p><code>Hadoop</code> 框架一般使用 <code>Mapper</code> 将数据处理成键值对，然后在网络节点间对其进行整理，最后使用 <code>Reducer</code> 处理数据并进行最终输出。<code>Combiner</code> 可以有效的减少 <code>maptask</code> 和 <code>reducetask</code> 之间传输的数据量（减少网络带宽），减轻 <code>Reducer</code> 上的计算负载。</p>
<p>简单的来说，就是在 <code>Reducer</code> 之前进行预处理，减轻它的压力。</p>
<p><strong>注意</strong>：<code>Combiner</code> 是在每个 <code>maptask</code> 所在的节点运行，而  <code>Reducer</code> 是接收全部的 <code>Mapper</code> 输出结果。<code>Combiner</code> 的输出结果需要与 <code>Reducer</code> 的输入结果类型等对应。<code>Combiner</code> 的使用原则是有或者没有都不影响业务逻辑。</p>
<h3 id="2-2-Partitioner"><a href="#2-2-Partitioner" class="headerlink" title="2.2 Partitioner"></a>2.2 Partitioner</h3><p>它是负责划分数据的类，可以将不同的数据分配给不同 <code>reducetask</code> 执行。<code>MapReduce</code> 默认的 <code>Partitioner</code> 是 <code>Hash Partitioner</code>，也就是先计算 <code>key</code> 的散列值（一般为 <code>md5</code> 值），然后通过 <code>Reducer</code> 个数进行取模运算。这样既可以随机的将整个 <code>key</code> 空间平均分配给每个 <code>Reducer</code> ，还可以确保不同的 <code>Mapper</code> 产生的相同的 <code>key</code> 能被分配到同一个 <code>Reducer</code>。公式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">hashcode%</span><span class="bash">reducetask</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> hashcode 是散列值</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> reducetask 是 reducer 个数</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-自定义-Record-Reader"><a href="#2-3-自定义-Record-Reader" class="headerlink" title="2.3 自定义 Record Reader"></a>2.3 自定义 Record Reader</h3><p><code>Record Reader</code> 表示从分片中读取一条记录的方式。每读取一条记录都会调用一次 <code>Record Reader</code> 类。系统默认的类是 <code>Line Record Reader</code> ，它以每行的偏移量作为 <code>map</code> 输入的键，以每行的内容作为 <code>map</code> 输入的值。这种情况就满足不了大多数情况，比如我们前面统计词频的例子需要以文件名为键，这时就需要自定义类。</p>
<h2 id="3-MapReduce-高级应用"><a href="#3-MapReduce-高级应用" class="headerlink" title="3.MapReduce 高级应用"></a>3.MapReduce 高级应用</h2><h3 id="3-1-join"><a href="#3-1-join" class="headerlink" title="3.1 join"></a>3.1 join</h3><p>我们可以借助 <code>Hive</code> 、<code>Spark SQL</code> 等框架来实现 <code>join</code> 操作。（不用怀疑，它就是 <code>SQL</code> 里面实现的那个 <code>join</code>）那么如何自己实现呢？</p>
<p><strong><code>MapReduce Map</code>端 <code>join</code> 实现原理：</strong></p>
<p>1) <code>Map</code> 端读取所有的文件，并在输出的内容里加上标识（代表数据是从哪个文件里来的）。</p>
<p>2) 在 <code>reduce</code> 处理函数中，按照标识对数据进行处理。</p>
<p>3) 根据 <code>key</code> 用 <code>join</code> 来求出结果直接输出。</p>
<h3 id="3-2-排序"><a href="#3-2-排序" class="headerlink" title="3.2 排序"></a>3.2 排序</h3><p>在 <code>MapReduce</code> 中默认可以进行排序。</p>
<p><strong>原理：</strong><code>key</code> 为数字类型时，按照数字大小对 <code>key</code> 进行排序；<code>key</code> 为字符串类型时，按照字典顺序对字符串排序。</p>
<h3 id="3-3-二次排序"><a href="#3-3-二次排序" class="headerlink" title="3.3 二次排序"></a>3.3 二次排序</h3><p>默认情况是对 <code>key</code> 进行排序，但有时还需要对 <code>value</code> 进行排序，这就是<strong>二次排序</strong>。比如在键相同的情况下，按值进行排序。</p>
<h3 id="3-4-小文件合并"><a href="#3-4-小文件合并" class="headerlink" title="3.4 小文件合并"></a>3.4 小文件合并</h3><p>前面我们说过小文件十分占用 <code>HDFS</code> 的存储空间，所以我们需要将小文件进行合并，输出为 <code>Sequence File</code> 。 </p>
<blockquote>
<p>学习自《基于Hadoop与Spark的大数据开发实战》</p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>MacBook Pro你真的会使用吗？</title>
    <url>/MacBookPro%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
那些不使用鼠标的人是否是打肿脸充胖子？因囊中羞涩而安装的xx软件装不上怎么办？MacBook Pro真的那么好用吗？下面为您解答

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>经过不懈的努力，小闫同学终于使用上了 MacBook Pro，先小小的炫耀一番。（不要打我哈~）</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/MacBookPro%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F/IMG_0212.jpg" alt="小闫同学的 MacBook Pro"></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/MacBookPro%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F/IMG_0211.jpg" alt="小闫同学的 MacBook Pro"></p>
<p>激动的心，颤抖的手，打开了笔记本才发现我是个弟弟，怎么用？经过了一番研究，将电脑弄死好几次的探索，终于入了门。分享给大家吧。</p>
<p>首先 macOS 是类 Linux 系统，因此会命令的童鞋超级好上手。其次，都说Mac 可以提高生产力，可以解放鼠标，怎么做到的呢？那就是超级丰富的快捷键以及非常大块且灵敏的触摸板的功劳了。</p>
<p>一拿到手，第一件事请将触摸板设置成 <strong>tap to click（单击）</strong>。设置方式为依次点击如下按钮：左上角的苹果logo -&gt; System Preferences -&gt; trackpad -&gt; 勾选 tap to click。（这样就不需要点按触摸板了）</p>
<p>第二件事请打开 <strong>three finger drag （三指拖拽）</strong>功能。设置方式如下：左上角的苹果logo -&gt; System Preferences -&gt; Accessibility -&gt; Pointer control -&gt; 点击右方左下角的 trackpad options -&gt; 勾选 enable dragging -&gt; 选择 three finger drag。</p>
<p>第三件事请设置 <strong>Hot corners （触摸角功能）</strong>。设置方式如下：在桌面任意位置鼠标右键（或者触摸板双指触碰一下）-&gt; change desktop background -&gt; screen saver -&gt; Hot corners。我将右下角设置为了 Lock Screen ，只要鼠标往右下角一划或者在触摸板上往右下角一划即可锁屏走人。</p>
<p>这都是一些简单但是非常提高效率设置，那么 Mac 上是如何提高生产力的呢？光这些可不够，下面再介绍一些常用操作。</p>
<p>在 Mac 上面，command 键等同于 Windows 上的 control 键，所以复制粘贴你懂得 ~ 下面快来学习一些 Mac 的小知识吧！</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>1.快速将当前窗口最大化： </p>
<p><code>control + command + F</code></p>
<p>再次按上述快捷键即可恢复原样 </p>
<p>2.快速将当前窗口最小化： </p>
<p><code>command + M</code></p>
<blockquote>
<p>如果当前窗口处于最大化状态，那么此命令无效 </p>
</blockquote>
<p>3.快速将最小化的窗口调出来： </p>
<p>​    3.1 先使用如下快捷键，打开所有的应用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command + tab</span><br></pre></td></tr></table></figure>

<p>​    3.2 按住 command 键不松开，按 tab 键向后选择，按 shift + tab 键向前选择</p>
<p>​    3.3 选中图标之后按住 option 键，松开 command 键即可打开应用</p>
<p>4.类似 home 键和 end 键的快捷操作：</p>
<p>​    4.1 快速移动到行首：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">control + A</span><br></pre></td></tr></table></figure>

<p>​    4.2 快速移动到行尾：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">control + E</span><br></pre></td></tr></table></figure>

<p>​    4.3 到下一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">control + N</span><br></pre></td></tr></table></figure>

<p>​    4.4 到上一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">control + P</span><br></pre></td></tr></table></figure>

<p>​    4.5 从光标处开始删除，知道行尾：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">control + K</span><br></pre></td></tr></table></figure>



<h2 id="安装软件出现文件已损坏"><a href="#安装软件出现文件已损坏" class="headerlink" title="安装软件出现文件已损坏"></a>安装软件出现文件已损坏</h2><p>1.关闭软件，点击取消，先别着急移到废纸篓 </p>
<p>2.输入如下命令，开启安装任何应用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure>

<p>3.如果是10.15的新系统，有可能还是失败，那么输入如下命令即可解决： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xattr -cr /Applications/MindNode.app</span><br></pre></td></tr></table></figure>

<p>​    3.1 上方的命令是先输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xattr -cr</span><br></pre></td></tr></table></figure>

<p>​    3.2 然后将损坏的应用图标拖到终端命令后，按回车即可 </p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>快捷键</tag>
        <tag>MacBook Pro</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac用户注意了,你的sed命令</title>
    <url>/Mac%E7%94%A8%E6%88%B7%E6%B3%A8%E6%84%8F%E4%BA%86-%E4%BD%A0%E7%9A%84sed%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>在 <code>MacOS</code> 上使用 <code>sed</code> 命令时与 <code>linux</code> 上并不相同，一定要主要！</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>当我们在使用 <code>sed</code> 对文本内容进行替换操作时（比如进行全局替换），一般如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i "s#err#right#g" test_sed.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将 <code>test_sed.txt</code> 文件中的 <code>err</code> 全部替换为 <code>right</code></p>
</blockquote>
<p>但是在 <code>MacOS</code> 上输出上面的命令，会报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed: 1: "test_sed.txt": undefined label 'est_sed.txt'</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>是：在 <code>MacOS</code> 上使用 <code>sed</code> 命令时参数不同</p>
<p><strong>使用方法</strong>：要达到与上述命令相同结果，只需像下面这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i '' "s#err#right#g" test_sed.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个参数为是否需要备份，如果填空不进行备份；一旦填入内容，将生成一个以填入内容为后缀的备份文件。</p>
</blockquote>
<p>如要生成备份文件，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i '.bak' "s#right#err#g" test_sed.txt</span><br></pre></td></tr></table></figure>

<p>会生成一个 <code>test_sed.txt.bak</code> 文件，此文件内容没有更改，<code>test_sed.txt</code> 文件内容中所有的 <code>right</code> 被更改为 <code>err</code></p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop学习笔记(四)之YARN</title>
    <url>/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p> <code>Hadoop</code> 之 <code>YARN</code>，你了解吗？</p>
<p>官方文档汇总：<a href="https://www.pythonnote.cn/OfficialDocuments/">https://www.pythonnote.cn/OfficialDocuments/</a></p>
<blockquote>
<p>包含了后端常使用的各种文档，小闫静心制作，快收藏起来吧 ~</p>
</blockquote>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h1 id="1-YARN"><a href="#1-YARN" class="headerlink" title="1.YARN"></a>1.YARN</h1><h2 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h2><p><code>YARN</code> 的出现是为了解决在 <code>Hadoop1.x</code> 版本中存在的一些问题。</p>
<p>之前，<code>MapReduce</code> 是 <code>Master/Slave</code> 结构，也就是集群中一个 <code>Job Tracker</code> 多个 <code>Task Tracker</code> 。 <code>Job Tracker</code> 负责资源管理和作业调度，<code>Task Tracker</code> 负责定期向 <code>Job Tracker</code> 报告节点的状态（节点死活，资源使用情况、任务执行情况）以及接收 <code>Job Tracker</code> 的命令来执行。不知你是否发现，<strong>问题就出现在这一个 <code>Job Tracker</code> 上，它挂掉，整个集群都完蛋。而且它由于负责了所有节点的  <code>RPC</code> 请求，压力可想而知，也因此成为了节点规模扩大的瓶颈。最后一点便是集群仅支持 <code>MapReduce</code>，不支持其他计算框架</strong>。如果想使用 <code>Spark</code> 呢？对不起，再搭建一个集群，想使用 <code>HBase</code> 只能再搭建一个集群。这样的一堆集群既不好管理，又使得资源利用率极低（一段时间内这个集群忙，那个集群闲），同时跨集群的数据转移更是问题。于是乎，<code>YARN</code> 诞生了。</p>
<h2 id="1-2-简介"><a href="#1-2-简介" class="headerlink" title="1.2 简介"></a>1.2 简介</h2><p>1) <code>YARN</code> 全称是 <code>Yet Another Resource Negotiator</code> 「另一种资源协调者」。</p>
<p>2) 它是一个通用的资源管理系统。</p>
<p>3) 它的引入提高了集群的利用率，便于资源统一管理调度，在数据共享方面也带来了极大好处。</p>
<p>4) 它是 <code>Job Tracker</code> 的替代者。</p>
<h2 id="1-3-架构"><a href="#1-3-架构" class="headerlink" title="1.3 架构"></a>1.3 架构</h2><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/291587280526_.pic_hd.jpg" alt="YARN 架构"></p>
<p>1) <code>YARN</code> 由四部分组成：<code>Client</code> 、<code>ResourceManager</code>(<code>RM</code>)、<code>NodeManager</code>(<code>NM</code>)、<code>ApplicationMaster</code>(<code>AM</code>)。</p>
<p>2) 采用了 <code>Master/Slave</code> 结构。一个 <code>ResourceManager</code> 对应多个 <code>NodeManager</code>。<code>Client</code> 向 <code>ResourceManager</code> 提交任务或终止任务。<code>ApplicationMaster</code>(<code>AM</code>) 由对应的应用程序完成，每个应用程序对应一个 <code>ApplicationMaster</code>(<code>AM</code>) ，<code>ApplicationMaster</code>(<code>AM</code>)  向 <code>ResourceManager</code> 申请资源用于在 <code>NodeManager</code> 上启动相应的任务。<code>NodeManager</code>(<code>NM</code>) 通过心跳信息向 <code>ResourceManager</code> 汇报自身状态信息。<code>MapTask</code> 对应的是 <code>MapReduce</code> 作业启动时产生的任务，<code>MPITask</code> 是 <code>MPI</code> 框架对应的执行任务。</p>
<blockquote>
<p><code>MPI</code> 是消息传递接口，可以理解为更原生的一种分布式模型</p>
</blockquote>
<h2 id="1-4-核心组件功能"><a href="#1-4-核心组件功能" class="headerlink" title="1.4 核心组件功能"></a>1.4 核心组件功能</h2><p>1) <code>ResourceManager</code> ：整个集群只有一个。负责集群资源的统一管理和调度；启动或监控 <code>ApplicationMaster</code> （一旦某个 <code>AM</code> 出现故障，<code>RM</code> 将会在另一个节点上启动该 <code>AM</code>）；监控 <code>NodeManager</code> ，接收其心跳信息并为其分配任务（一旦某个 <code>NM</code> 出故障，标记一下该 <code>NM</code> 上的任务，来告诉对应的 <code>AM</code> 如何处理）。</p>
<p>2) <code>NodeManager</code>：整个集群中有多个，负责单节点资源管理和使用。定时向 <code>ResourceManager</code> 汇报节点状态信息；接收并处理来自 <code>ResourceManager</code> 的 <code>Container</code> 启动或停止的各种命令；处理来自 <code>ApplicationMaster</code> 的命令。</p>
<p>3)  <code>ApplicationMaster</code> ：每个应用一个，负责应用程序的管理。数据切分；为应用程序或作业向 <code>ResourceManager</code> 申请资源（<code>Container</code>），并分配给内部任务；与 <code>NodeManager</code> 通信以启动或者停止任务；任务监控和容错（在任务执行失败时重新为该任务申请资源以重启任务）；处理 <code>ResourceManager</code> 发过来的命令：终止 <code>Container</code>、让 <code>NodeManager</code> 重启等。</p>
<p>4) <code>Container</code>：对任务运行环境的抽象。任务运行资源（节点、内存、CPU）；任务启动命令；任务运行环境；任务是运行在 <code>Container</code> 中，一个 <code>Container</code> 中既可以运行 <code>ApplicationMaster</code>，也可以运行具体的 <code>Map</code>、<code>Reduce</code>、<code>MPI</code>、<code>Spark Task</code>。</p>
<h2 id="1-5-工作原理"><a href="#1-5-工作原理" class="headerlink" title="1.5 工作原理"></a>1.5 工作原理</h2><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/album_temp_1587282871.PNG" alt="YARN工作原理"></p>
<p>1) 用户向 <code>YARN</code> 中提交应用程序/作业，其中包括 <code>ApplicationMaster</code> 程序、启动 <code>ApplicationMaster</code> 的命令、用户程序等。</p>
<p>2) <code>Resource Manager</code> 为作业分配第一个 <code>Container</code>，并与对应的 <code>NodeManager</code> 通信，要求它在这个 <code>Container</code> 中启动该作业的 <code>ApplicationMaster</code>。</p>
<p>3) <code>Application Master</code> 首先向 <code>Resource Manager</code> 注册，这样用户可以直接通过 <code>Resource Manager</code> 查询作业的运行状态；然后将为各个任务申请资源并监控任务的运行状态，直到运行结束。即重复步骤（7）。</p>
<p>4) <code>Application Master</code> 采用轮询的方式通过 <code>RPC</code> 请求向 <code>ResourceManager</code> 申请和获取资源。</p>
<p>5) 一旦 <code>ApplicationMaster</code> 申请到资源，便与对应的 <code>NodeManager</code> 通信，要求它启动任务。</p>
<p>6) <code>NodeManager</code> 启动任务。</p>
<p>7) 各个任务通过 <code>RPC</code> 协议向 <code>ApplicationMaster</code> 汇报自己的状态和进度，以便 <code>ApplicaitonMaster</code> 随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务；在作业运行过程中，用户可随时通过 <code>RPC</code> 向 <code>ApplicationMaster</code> 查询作业当前运行状态。</p>
<p>8) 作业完成后，<code>ApplicationMaster</code> 向 <code>ResourceManager</code> 注销并关闭自己。</p>
<h2 id="1-6-特点"><a href="#1-6-特点" class="headerlink" title="1.6 特点"></a>1.6 特点</h2><p>1) <code>ResourceManager</code> 基于 <code>ZooKeeper</code> 实现高可用机制，避免发生单点故障。</p>
<p>2) <code>Node Manager</code> 执行失败后，<code>ResourceManager</code> 将失败任务告诉对应的 <code>ApplicationMaster</code>，由 <code>ApplicationMaster</code> 决定如何处理失败的任务。</p>
<p>3) <code>Application Master</code> 执行失败后，由 <code>ResourceManager</code> 负责重启 <code>ApplicationMaster</code> 需处理内部任务的容错问题，并保存已经运行完成的 <code>Task</code>，重启后无需重新运行。</p>
<blockquote>
<p>学习自《基于Hadoop与Spark的大数据开发实战》</p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop学习笔记(二)之HDFS</title>
    <url>/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p> <code>Hadoop</code> 之分布式文件系统，你了解吗？</p>
<p>官方文档汇总：<a href="https://www.pythonnote.cn/OfficialDocuments/">https://www.pythonnote.cn/OfficialDocuments/</a></p>
<blockquote>
<p>包含了后端常使用的各种文档，小闫静心制作，快收藏起来吧 ~</p>
</blockquote>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><h2 id="1-HDFS-入门"><a href="#1-HDFS-入门" class="headerlink" title="1.HDFS 入门"></a>1.HDFS 入门</h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h3><p>面对各行各业日益增长的数据量，普通的机器无论在存储空间还是管理能力上都显得力不从心。既然单台机器的资源有限，那么增加机器的方式是否可行？答案是肯定的，于是乎出现了分布式的概念。分布式文件管理系统便可以将一堆机器组合在一起，并隐藏细节，让用户感觉与之前单机储存文件毫无差别，但其实文件是通过网络来访问的。</p>
<h3 id="1-2-简介"><a href="#1-2-简介" class="headerlink" title="1.2 简介"></a>1.2 简介</h3><p>1) 官方称：<code>HDFS</code> 可以运行在廉价的服务器上，为海量的数据存储提供了高容错、高可靠性、高可扩展性、高获得性、高吞吐率等特征。</p>
<p>2) <code>HDFS</code> 基于开源的 <code>GFS</code> 开发实现。</p>
<p>3) <code>HDFS</code> 的默认存储单位是数据块 <code>Block</code>，默认数据块大小是 <code>64MB</code> 。文件存储时会分成一个个数据块，但是当一个小文件没达到数据块大小时，文件是多大就占用多大的空间。</p>
<p>4) <code>NameNode</code> 称为元数据节点，管理保存所有的节点信息、文件信息等等。它的一些系统文件我们需要了解：<code>edits</code> 保存了一些操作信息；<code>fsimage</code> 是名字空间文件。</p>
<p>5) 数据节点 <code>DataNode</code> 是存储数据的地方，一个文件会被分成若干个数据块储存在对应的数据节点上。数据节点的系统文件：以 <code>blk_</code> 开头无后缀的文件保存的就是数据块，以 <code>blk_</code> 开头以 <code>.meta</code> 结尾的文件则保存对应数据块的属性信息，<code>subdir</code> 开头的目录保存的也是数据块相关信息（数据块太多了，就一起放在这种目录下）。</p>
<p>6) 从元数据节点 <code>Secondary Name Node</code> 虽然名字中有个「从」字，但并非是备份，而是与 <code>Name Node</code> 各司其职，它主要的作用是隔一段时间合并一下日志文件等，并帮助 <code>Name Node</code> 将内存中的元数据信息 <code>checkpoint</code> 到硬盘上。</p>
<blockquote>
<p><code>checkpoint</code> 即检查点，保存某一刻内存数据到硬盘的文件中。</p>
</blockquote>
<h3 id="1-3-优点"><a href="#1-3-优点" class="headerlink" title="1.3 优点"></a>1.3 优点</h3><p>1) 可以处理超大文件（<code>MB</code> 到 <code>TB</code> 级别）</p>
<p>2) 对于服务器要求不高，<code>Hadoop</code> 集群可部署在廉价的机器上节约项目成本，因为它的多副本，使你不必担心宕机等意外事故带来的影响。</p>
<p>3) 一次写入，多次读取。</p>
<p>4) 现在还支持对已有文件追加内容。</p>
<h3 id="1-4-缺点"><a href="#1-4-缺点" class="headerlink" title="1.4 缺点"></a>1.4 缺点</h3><p>1) 不适合低延迟数据访问，即访问数据时间可能会长一些。</p>
<p>2) 不适合存储大量小文件。因为存储一个文件，其元数据会保存在 <code>NameNode</code> 中，而 <code>NameNode</code> 的内存决定了 <code>HDFS</code> 储存文件的上限，大量小文件会耗费资源。</p>
<blockquote>
<p>文件存储后，其元数据（文件的相关信息，如创建日期，文件大小，存储路径等等）会保存在 <code>NameNode</code> 中。一个小文件和一个大文件的元数据大小是差不多的，元数据存储满后，不再接受文件存储。如果存储大量的小文件，会导致存储空间上的浪费，还会增加 <code>NameNode</code> 的压力，从而影响集群性能。可以采用 <code>Sequence File</code> 等方式对小文件进行合并，或者使用 <code>Name Node Federation</code> 的方式改善。</p>
</blockquote>
<h3 id="1-5-设计目标"><a href="#1-5-设计目标" class="headerlink" title="1.5 设计目标"></a>1.5 设计目标</h3><p>1) 集群中管理数量庞大的服务器，如何做到错误检测，快速、自动恢复是核心目标。</p>
<p>2) 需要高数据传输带宽，保证支撑数以千万计的文件。</p>
<p>3) 需要支持大文件存储。</p>
<p>4) 移动计算而非移动数据。</p>
<h3 id="1-6-架构"><a href="#1-6-架构" class="headerlink" title="1.6 架构"></a>1.6 架构</h3><p>1) <code>HDFS</code> 采用 <code>master/slave</code> 架构。</p>
<p>2) 一个 <code>HDFS</code> 集群由一个 <code>NameNode</code> 和一些 <code>DataNode</code> 组成， <code>NameNode</code> 相当于控制中心，负责管理文件系统的名字空间、数据块与数据节点的映射以及数据节点的调度。 <code>DataNode</code> 则负责处理实际的客户端读写的请求，存储数据。</p>
<h2 id="2-HDFS-基本操作"><a href="#2-HDFS-基本操作" class="headerlink" title="2.HDFS 基本操作"></a>2.HDFS 基本操作</h2><h3 id="2-1-HDFS-shell"><a href="#2-1-HDFS-shell" class="headerlink" title="2.1 HDFS shell"></a>2.1 HDFS shell</h3><blockquote>
<p>先启动 <code>Hadoop</code> 才能使用</p>
</blockquote>
<p>1) 列出文件目录，同 <code>ls</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -ls 目录路径</span><br></pre></td></tr></table></figure>

<blockquote>
<p>递归的查看文件可以使用 <code>-R</code> 参数</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出 /data 下的所有文件</span></span><br><span class="line">hadoop fs -ls -R /data</span><br></pre></td></tr></table></figure>

<p>2) 在 <code>HDFS</code> 中创建文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -mkdir 文件夹名称</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果想嵌套（级联）的创建目录，可以使用 <code>-p</code> 参数</p>
</blockquote>
<p>3) 上传文件到 <code>HDFS</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -put 本地文件路径 HDFS文件路径</span><br></pre></td></tr></table></figure>

<p>4) 从 <code>HDFS</code> 上下载文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -get HDFS文件路径 本地路径</span><br></pre></td></tr></table></figure>

<p>5) 查看 <code>HDFS</code> 上某个文件内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -cat HDFS上文件路径</span><br></pre></td></tr></table></figure>

<p>6) 统计目录下各文件的大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -du 目录路径</span><br></pre></td></tr></table></figure>

<p>7) 删除  <code>HDFS</code> 上某个文件或文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -rm 文件</span><br><span class="line">hadoop fs -rmdir 文件夹</span><br></pre></td></tr></table></figure>

<p>8) 帮助命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -help 命令</span><br></pre></td></tr></table></figure>

<h2 id="3-HDFS-运行原理"><a href="#3-HDFS-运行原理" class="headerlink" title="3.HDFS 运行原理"></a>3.HDFS 运行原理</h2><h3 id="3-1-读流程"><a href="#3-1-读流程" class="headerlink" title="3.1 读流程"></a>3.1 读流程</h3><p>客户端通过 <code>RPC</code> 调用 <code>NameNode</code> 的相关方法，如果客户端身份验证成功，会获取到要读取的文件对应的数据块保存在哪些 <code>DataNode</code> 上；客户端向 <code>DataNode</code> 发起读取的请求，获取数据（客户端读取的是连续的流，但实际过程是先到最近的 <code>DataNode</code> 读取数据，读取完之后连接关闭，再去读取下一个 <code>DataNode</code> 上的数据块）；当所有的数据读取完成后，资源关闭。</p>
<h3 id="3-2-写流程"><a href="#3-2-写流程" class="headerlink" title="3.2 写流程"></a>3.2 写流程</h3><p>客户端向 <code>NameNode</code> 发起  <code>RPC</code> 请求创建文件， <code>NameNode</code> 验证用户权限、检测文件是否存在，最终创建一条元数据信息，然后客户端开始向 <code>DataNode</code> 保存数据，进行切分并完成第一个副本的创建，再将其复制到其他的节点上，直到所有的节点完成后，关闭连接。</p>
<h3 id="3-3-副本"><a href="#3-3-副本" class="headerlink" title="3.3 副本"></a>3.3 副本</h3><p><code>HDFS</code> 上文件对应的数据块保存有多个副本，并为其提供容错机制，当副本丢失或者宕机时，能够快速自动恢复。但是要注意，我们需要对副本系数进行设置，而且此系数一经写入，不可更改。</p>
<h4 id="3-3-1-摆放策略"><a href="#3-3-1-摆放策略" class="headerlink" title="3.3.1 摆放策略"></a>3.3.1 摆放策略</h4><p>第一个副本放置在上传文件的 <code>Data Node</code> 上，如果是在集群外提交，则根据磁盘速度以及 <code>CPU</code> 效率选取一个节点。</p>
<p>第二个副本放在与第一个副本不同机架的节点上。</p>
<p>第三个副本放在与第二个副本相同机架的不同节点上。</p>
<p>更多的副本就随机放在节点中。</p>
<h3 id="3-4-负载均衡"><a href="#3-4-负载均衡" class="headerlink" title="3.4 负载均衡"></a>3.4 负载均衡</h3><p>1) 如果某个 <code>DataNode</code> 上空闲空间低于临界点，按照负载均衡策略，系统会自动将数据转移到其他空闲的 <code>DataNode</code> 上。</p>
<p>2) 如果对某个文件的请求突然增加，有可能启动一个计划来创建该文件新的副本，最后再重新平衡集群中其他数据。</p>
<p>3) <code>HDFS</code> 会调整存储分布以均衡 <code>IO</code> 性能，平衡 <code>IO</code> 负载，平均数据，平衡集群。</p>
<p>4) <code>Hadoop</code> 的 <code>bin/start-balancer.sh</code> 脚本可以启动均衡服务。使用 <code>-threshold</code> 参数设置判断集群是否平衡的阈值；使用 <code>hdfs-site.xml</code> 文件中的 <code>dfs.balance.bandwidth</code> 设置 <code>Balancer</code> 运行时允许占用的带宽。 </p>
<h2 id="4-HDFS-高级知识"><a href="#4-HDFS-高级知识" class="headerlink" title="4.HDFS 高级知识"></a>4.HDFS 高级知识</h2><h3 id="4-1-序列化机制"><a href="#4-1-序列化机制" class="headerlink" title="4.1 序列化机制"></a>4.1 序列化机制</h3><p>1) 序列化：将对象转化为字节流，以便在网络上传输或者写在磁盘上持久化存储。</p>
<p>2) 反序列化：将字节流转回成对象。</p>
<p>3) <code>Hadoop</code> 中多个节点进程间通讯是通过 <code>RPC</code> 完成的，所以需要序列化机制。</p>
<p>4) <code>Hadoop</code> 序列化中，用户可以复用对象，减少了 <code>java</code> 对象的分配和回收，提高应用效率。</p>
<h3 id="4-2-Sequence-File"><a href="#4-2-Sequence-File" class="headerlink" title="4.2 Sequence File"></a>4.2 Sequence File</h3><h4 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h4><p>前面我们介绍过，当 <code>HDFS</code> 中保存有大量的小文件时，<code>NameNode</code> 压力会很大，使得存储的元数据信息非常多，而 <code>Sequence File</code> 则可以将小文件合并。</p>
<p>1) <code>Sequence File</code> 是 <code>Hadoop</code> 提供的一种对二进制文件的支持。</p>
<p>2) 二进制文件直接将键值对序列化到文件中。</p>
<p>3) 使用 <code>Sequence File</code> 进行存储的文件，占用空间会大于原数据，因为为了查找方便，<code>Sequence File</code> 的存储中添加了一些额外的信息，使得数据增大。</p>
<h4 id="4-2-2-特点"><a href="#4-2-2-特点" class="headerlink" title="4.2.2 特点"></a>4.2.2 特点</h4><p>1) 支持压缩。分为基于 <code>Record</code> 和 <code>Block</code> 压缩，前一种只压缩值不压缩键，后一种则是键和值都压缩。默认为无压缩，每个记录（<code>Record</code>）是由它的记录长度（字节数）、键的长度、键和值组成。</p>
<p>2) 对于 <code>MapReduce</code> 任务十分友好，因为文件可以被切分，使用 <code>Map Task</code> 并行处理可大幅提高作业的执行效率。</p>
<p>3) 使用简单，因为 <code>Hadoop</code> 提供了 <code>API</code> ，业务逻辑中应用便捷。</p>
<h3 id="4-3-Map-File"><a href="#4-3-Map-File" class="headerlink" title="4.3 Map File"></a>4.3 Map File</h3><p><code>Map File</code> 是排序过的 <code>Sequence File</code> ，由 <code>index</code> 和 <code>data</code> 两部分组成。<code>index</code> 是文件的数据索引，主要记录了每个 <code>Record</code> 的 <code>key</code> 值以及该  <code>Record</code> 在文件中的偏移位置。在 <code>Map File</code> 被访问的时候，索引文件会先被加载到内存，通过 <code>index</code> 映射关系可快速定位到指定 <code>Record</code> 所在文件位置。所以 <code>Map File</code> 比 <code>Sequence File</code> 检索效率更高，缺点便是维护多余的 <code>index</code> 数据，占用了部分内存。</p>
<blockquote>
<p>学习自《基于Hadoop与Spark的大数据开发实战》</p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法奇奇怪怪小知识</title>
    <url>/Markdown%E8%AF%AD%E6%B3%95%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 


<p><code>markdown</code> 语法因为其通用性、简便性广受程序员的喜爱，下面再记录一些语法。</p>
 <a id="more"></a> 

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-上标-下标"><a href="#1-上标-下标" class="headerlink" title="1.上标/下标"></a>1.上标/下标</h2><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>氧气: O<sub>2</sub></p>
<p><code>n</code> 的平方: n<sup>2</sup></p>
<h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">氧气: O<span class="xml"><span class="tag">&lt;<span class="name">sub</span>&gt;</span></span>2<span class="xml"><span class="tag">&lt;/<span class="name">sub</span>&gt;</span></span></span><br><span class="line">n的平方: n<span class="xml"><span class="tag">&lt;<span class="name">sup</span>&gt;</span></span>2<span class="xml"><span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-注脚"><a href="#2-注脚" class="headerlink" title="2.注脚"></a>2.注脚</h2><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E6%B3%A8%E8%84%9A.png" alt="注脚示例"></p>
<h3 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">欢迎关注公众号「全栈技术精选[^1]」，它由小闫同学[^2]一手创建，旨在技术共享。</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]:<span class="link">全栈技术精选是一个汇集了后端开发、数据分析、爬虫等全方位的技术公众号，干货满满而且免费</span></span><br><span class="line"></span><br><span class="line">[<span class="symbol">^2</span>]:<span class="link">小闫同学是一名 `python` 开发工程师，也是一名技术文章博主</span></span><br></pre></td></tr></table></figure>

<h2 id="3-居中"><a href="#3-居中" class="headerlink" title="3.居中"></a>3.居中</h2><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><center>作者：小闫</center>

<h3 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;center&gt;作者：小闫&lt;&#x2F;center&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-流程图"><a href="#4-流程图" class="headerlink" title="4.流程图"></a>4.流程图</h2><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="流程图"></p>
<h3 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```flow</span></span><br><span class="line"><span class="code">st=&gt;start: Start|past:&gt;http://www.google.com[blank]</span></span><br><span class="line"><span class="code">e=&gt;end: End:&gt;http://www.google.com</span></span><br><span class="line"><span class="code">op1=&gt;operation: My Operation|past</span></span><br><span class="line"><span class="code">op2=&gt;operation: Stuff|current</span></span><br><span class="line"><span class="code">sub1=&gt;subroutine: My Subroutine|invalid</span></span><br><span class="line"><span class="code">cond=&gt;condition: Yes </span></span><br><span class="line"><span class="code">or No?|approved:&gt;http://www.baidu.com</span></span><br><span class="line"><span class="code">c2=&gt;condition: Good idea|rejected</span></span><br><span class="line"><span class="code">io=&gt;inputoutput: catch something...|request</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">st-&gt;op1(right)-&gt;cond</span></span><br><span class="line"><span class="code">cond(yes, right)-&gt;c2</span></span><br><span class="line"><span class="code">cond(no)-&gt;sub1(left)-&gt;op1</span></span><br><span class="line"><span class="code">c2(yes)-&gt;io-&gt;e</span></span><br><span class="line"><span class="code">c2(no)-&gt;op2-&gt;e</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>

<h2 id="5-任务清单"><a href="#5-任务清单" class="headerlink" title="5.任务清单"></a>5.任务清单</h2><h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95.png" alt="任务清单"></p>
<h3 id="语法：-4"><a href="#语法：-4" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span> <span class="selector-attr">[ ]</span> 任务一 还没有发表今日文章</span><br><span class="line"><span class="selector-tag">-</span> <span class="selector-attr">[x]</span> 任务二 收取广告费</span><br></pre></td></tr></table></figure>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>OAuth2.0与OAuth1.0你了解了吗？</title>
    <url>/OAuth2-0%E4%B8%8EOAuth1-0%E4%BD%A0%E4%BA%86%E8%A7%A3%E4%BA%86%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>使用了 <code>OAuth2.0</code> ，但是你晓得为什么使用 <code>OAuth2.0</code> 吗？快来看看吧。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-OAuth简介"><a href="#1-OAuth简介" class="headerlink" title="1.OAuth简介"></a>1.OAuth简介</h2><p><code>OAuth</code> 协议简单的来说就是第三方应用在不知道我方用户账号密码的情况下，通过我们的授权，进行登录操作。它减少了用户注册的次数，方便用户快捷登录，提升用户体验度，更保障了用户的信息不被泄露。毕竟 <code>qq/微博</code> 大部分人都使用，而第三方应用却很少有人使用，用户既可以使用常用的登录方式登录，又不需要担心  <code>qq/微博</code>  泄露我们的信息给第三方应用。</p>
<h2 id="2-OAuth2-0选择缘由"><a href="#2-OAuth2-0选择缘由" class="headerlink" title="2.OAuth2.0选择缘由"></a>2.OAuth2.0选择缘由</h2><h3 id="2-1-OAuth1-0"><a href="#2-1-OAuth1-0" class="headerlink" title="2.1 OAuth1.0"></a>2.1 OAuth1.0</h3><p><img src="https://img-blog.csdnimg.cn/20190521200756553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l2b2xjYW5v,size_16,color_FFFFFF,t_70" alt="OAuth1.0过程解析"></p>
<h4 id="2-1-1-访问过程"><a href="#2-1-1-访问过程" class="headerlink" title="2.1.1 访问过程"></a>2.1.1 访问过程</h4><p>1) 客户端向资源服务器请求未授权 <code>Request Token</code></p>
<p>2) 服务器返回未授权<code>Request Token</code>和 <code>secret</code>，具体返回的参数为：<code>oauth_token</code> 和 <code>oauth_token_secret</code></p>
<p>3) 客户端携带上一步的 <code>oauth_token</code> 以及 <code>oauth_callback</code> 等参数请求服务器，调起授权页面</p>
<p>4) 用户授权</p>
<p>5) 资源服务器将用户重定向回客户端，并带回授权过的 <code>Request Token</code> 也就是 <code>oauth_token</code></p>
<p>6) 获取到授权 <code>Request Token</code>，再向资源服务器换取票据  <code>accessToken</code> </p>
<p>7) 通过票据 <code>accessToken</code> 访问用户在资源服务器存储的受保护的资源</p>
<h4 id="2-1-2-优点"><a href="#2-1-2-优点" class="headerlink" title="2.1.2 优点"></a>2.1.2 优点</h4><p> <code>OAuth1.0</code> 协议每个 <code>Token</code> 都会进行加密</p>
<h4 id="2-1-3-缺点"><a href="#2-1-3-缺点" class="headerlink" title="2.1.3 缺点"></a>2.1.3 缺点</h4><p>1) 用的是 <code>http</code> 协议</p>
<p>2) 容易在申请 <code>RequestToken</code> 过程中，被攻击者调包，然后伪造回调地址，拿到用户的 <code>accessToken</code> 然后为所欲为。</p>
<h3 id="2-2-OAuth2-0"><a href="#2-2-OAuth2-0" class="headerlink" title="2.2 OAuth2.0"></a>2.2 OAuth2.0</h3><p><img src="https://images0.cnblogs.com/blog2015/545673/201505/221134251825386.png" alt="OAuth2.0"></p>
<h4 id="2-2-1-访问过程"><a href="#2-2-1-访问过程" class="headerlink" title="2.2.1 访问过程"></a>2.2.1 访问过程</h4><p>在 <code>OAuth2.0</code> 协议中常用的授权方法有四种：授权码模式、简化模式、密码模式、客户端模式。通过授权码模式进行说明：</p>
<p>1) 引导用户到授权服务器，请求用户授权，用户授权后返回授权码(<code>Authorization Code</code>)</p>
<p>2) 客户端由授权码到授权服务器换取访问令牌(<code>Access Token</code>)</p>
<blockquote>
<p>如果需要，开发者可以通过 <code>refresh_token</code> 刷新授权 <code>access_token</code>，避免过期</p>
</blockquote>
<p>3) 用访问令牌去访问得到授权的资源</p>
<h4 id="2-2-2-优点"><a href="#2-2-2-优点" class="headerlink" title="2.2.2 优点"></a>2.2.2 优点</h4><p>1) 使用 <code>https</code> ，更加安全</p>
<p>2) 所有的 <code>token</code> 不再有对应的 <code>secret</code> 存在，签名过程简洁</p>
<p>3) 能更好地支持不是基于浏览器的应用</p>
<p>4) 有刷新令牌的机制</p>
<h4 id="2-2-3-缺点"><a href="#2-2-3-缺点" class="headerlink" title="2.2.3 缺点"></a>2.2.3 缺点</h4><p>1) <code>OAuth2.0</code> 不兼容老版本</p>
<p>2) <code>OAuth2.0</code> 的访问令牌，也就是 <code>access_token</code> 有有效期</p>
<h3 id="2-3-对比"><a href="#2-3-对比" class="headerlink" title="2.3 对比"></a>2.3 对比</h3><p>1)  <code>OAuth2.0</code> 使用 <code>https</code> 的方式更加安全； <code>OAuth1.0</code> 虽然所有的 <code>token</code> 都会进行加密，但因为使用 <code>http</code> 方式而有被劫持攻击风险。</p>
<p>2)  <code>OAuth2.0</code> 可以通过多种方式获取访问令牌，考虑到了客户端存在的各种形态，包容性好；而  <code>OAuth1.0</code> 只有一种方式</p>
<p>3) <code>OAuth2.0</code> 较 <code>OAuth1.0</code> 相比，整个授权验证流程更简单更安全（省去了复杂的签名过程）</p>
<h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h2><p>1.授权码模式中，为什么不直接获取令牌，而是通过授权码，岂不是多此一举？</p>
<p>答：授权码是为了防止中间者攻击。比如第三方使用 <code>http</code> 协议，直接传递令牌，很容易被劫持，有了授权码之后，情况便大不相同。授权码一般有效期十分钟且只能被使用一次，攻击者即使获取到授权码，换到了令牌，当第三方应用也通过授权码获取令牌时，授权服务器就会因为授权码被使用两次而让令牌失效，从而保证安全。</p>
<p>2.为什么授权模式为了避免 <code>CSRF</code> 攻击，可以在 <code>URL</code> 请求后面加个参数 <code>state</code>，这是什么原理？</p>
<p>答：<code>state</code> 参数能标记这是来自哪一个网站，且 <code>state</code> 参数是攻击者拿不到的，因此可以避免 <code>CSRF</code> 攻击。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>oauth</category>
      </categories>
      <tags>
        <tag>oauth</tag>
      </tags>
  </entry>
  <entry>
    <title>Python后端面试汇总</title>
    <url>/Python%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
只身打入敌人内部，亲身经历，题目汇总，亲情大奉献，请点击以下链接观看：

<p><a href="http://mp.weixin.qq.com/mp/homepage?__biz=Mzg3NTA0OTM1OQ==&hid=8&sn=811ae175b0ce7f4208d0a3bea3157ac0&scene=18#wechat_redirect" target="_blank" rel="noopener">python面试题大汇总</a></p>
<a id="more"></a>









<p>点进来干什么，题目全在链接里面了 ~ </p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux如何让滚屏起飞</title>
    <url>/Tmux%E5%A6%82%E4%BD%95%E8%AE%A9%E6%BB%9A%E5%B1%8F%E8%B5%B7%E9%A3%9E/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>在 <code>Panel</code> 中查看历史时，滚屏只能一行一行走？那是你打开方式不正确！</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-滚屏操作"><a href="#1-滚屏操作" class="headerlink" title="1.滚屏操作"></a>1.滚屏操作</h2><p><code>Tmux</code> 在 <code>Panel</code> （也有人叫面板或者窗格）中查看历史不像一般终端中那样方便。</p>
<h3 id="1-1-以前"><a href="#1-1-以前" class="headerlink" title="1.1 以前"></a>1.1 以前</h3><p><strong>快捷键</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">先按 Ctrl + b</span><br><span class="line">然后按 [</span><br></pre></td></tr></table></figure>

<p>使用快捷键进入 <code>copy-mode</code> 模式，就可以利用方向键上下移动光标查看了，但是如果历史信息太多，一行一行未免太不爽了，该如何操作呢？</p>
<h3 id="1-2-现在"><a href="#1-2-现在" class="headerlink" title="1.2 现在"></a>1.2 现在</h3><p>为了向 <code>vi</code> 那样，可以半屏半屏，一屏一屏的滚，可以进行如下设置：</p>
<p>1.先打开配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.tmux.conf</span><br></pre></td></tr></table></figure>

<p>2.将下面设置输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setw -g mode-keys vi</span><br></pre></td></tr></table></figure>

<p>3.重新载入配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux source-file ~/.tmux.conf</span><br></pre></td></tr></table></figure>

<p>4.使用快捷键进入 <code>copy-mode</code> 模式，然后就可以像 <code>vi</code> 中一样操作了。</p>
<p>比如：<code>Ctrl-u</code> 向上滚半屏， <code>Ctrl-d</code> 向下滚半屏。</p>
<p><strong>根据某关键字搜索</strong>：</p>
<p>使用快捷键进入 <code>copy-mode</code> 模式，然后按 <code>/</code> ，就可以输入关键字了，回车查找。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>tmux</category>
      </categories>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL处理排行榜问题</title>
    <url>/SQL%E5%A4%84%E7%90%86%E6%8E%92%E8%A1%8C%E6%A6%9C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>对现有的数据，根据某一字段进行排名，如果没有 <code>RANK</code> 函数，<code>SQL</code> 语句怎么写？接下来就分享一道面试题……</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-面试题"><a href="#1-面试题" class="headerlink" title="1.面试题"></a>1.面试题</h2><p>现在有一张表，保存着学生的相关信息（<code>id</code> 、名字以及分数），如下图所示。请写出 <code>sql</code> 语句查询排名第4的学生信息。</p>
<img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E6%8E%92%E5%90%8D%E9%97%AE%E9%A2%981.png" alt="排名问题" style="zoom:50%;">

<h2 id="2-答案"><a href="#2-答案" class="headerlink" title="2.答案"></a>2.答案</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 进行排名，相同的分数同名次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">name</span>,</span><br><span class="line">             score,</span><br><span class="line">            (<span class="keyword">case</span> <span class="keyword">when</span> @p=score <span class="keyword">then</span> @r</span><br><span class="line">                  <span class="keyword">when</span> @p:=score <span class="keyword">then</span> @r:=@r+<span class="number">1</span> <span class="keyword">end</span>) <span class="keyword">as</span> stu_rank</span><br><span class="line">        <span class="keyword">from</span> tb_student, (<span class="keyword">select</span> @r:=<span class="number">0</span>,@p:=<span class="literal">NULL</span>) r</span><br><span class="line">       <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) v_rank</span><br><span class="line"><span class="keyword">where</span> v_rank.stu_rank=<span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此语句为小闫参考网络类似案例后所写，可以达到预期效果，但在性能或者复杂度上可能有所欠缺，如果您有更好的方法，请关注公众号「全栈技术精选」后台给我留言吧</p>
</blockquote>
<h2 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h2><h3 id="3-1-准备数据"><a href="#3-1-准备数据" class="headerlink" title="3.1 准备数据"></a>3.1 准备数据</h3><p>在讲解之前，先让我们创建一个测试数据库 <code>testdb</code>，然后创建一张测试用表 <code>tb_student</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> testdb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_student(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">    score <span class="built_in">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>然后按照图片中的信息进行构造数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student(<span class="keyword">name</span>, score) <span class="keyword">values</span>(<span class="string">'小三'</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student(<span class="keyword">name</span>, score) <span class="keyword">values</span>(<span class="string">'jack'</span>, <span class="number">99</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student(<span class="keyword">name</span>, score) <span class="keyword">values</span>(<span class="string">'rose'</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student(<span class="keyword">name</span>, score) <span class="keyword">values</span>(<span class="string">'马蓉'</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student(<span class="keyword">name</span>, score) <span class="keyword">values</span>(<span class="string">'李小璐'</span>, <span class="number">40</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student(<span class="keyword">name</span>, score) <span class="keyword">values</span>(<span class="string">'fuck'</span>, <span class="number">300</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student(<span class="keyword">name</span>, score) <span class="keyword">values</span>(<span class="string">'李小璐2'</span>, <span class="number">40</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student(<span class="keyword">name</span>, score) <span class="keyword">values</span>(<span class="string">'李小璐3'</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-2-知识点"><a href="#3-2-知识点" class="headerlink" title="3.2 知识点"></a>3.2 知识点</h3><p><strong>赋值号</strong>：<code>:=</code></p>
<p><strong>条件语句</strong>：<code>case when</code></p>
<h3 id="3-3-过程"><a href="#3-3-过程" class="headerlink" title="3.3 过程"></a>3.3 过程</h3><p>1.首先需要根据分数进行排名（分数相同的同学，名次应该也是相同的，并列关系）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,</span><br><span class="line">       score,</span><br><span class="line">      (<span class="keyword">case</span> <span class="keyword">when</span> @p=score <span class="keyword">then</span> @r</span><br><span class="line">            <span class="keyword">when</span> @p:=score <span class="keyword">then</span> @r:=@r+<span class="number">1</span> <span class="keyword">end</span>) <span class="keyword">as</span> stu_rank</span><br><span class="line"><span class="keyword">from</span> tb_student, (<span class="keyword">select</span> @r:=<span class="number">0</span>,@p:=<span class="literal">NULL</span>) <span class="keyword">as</span> r</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E6%8E%92%E5%90%8D%E9%97%AE%E9%A2%982.png" style="zoom:50%;">

<p>2.然后再查出某一名次的学生</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 进行排名，相同的分数应该是同名次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">name</span>,</span><br><span class="line">             score,</span><br><span class="line">            (<span class="keyword">case</span> <span class="keyword">when</span> @p=score <span class="keyword">then</span> @r</span><br><span class="line">                  <span class="keyword">when</span> @p:=score <span class="keyword">then</span> @r:=@r+<span class="number">1</span> <span class="keyword">end</span>) <span class="keyword">as</span> stu_rank</span><br><span class="line">        <span class="keyword">from</span> tb_student, (<span class="keyword">select</span> @r:=<span class="number">0</span>,@p:=<span class="literal">NULL</span>) r</span><br><span class="line">       <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) v_rank</span><br><span class="line"><span class="keyword">where</span> v_rank.stu_rank=<span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E6%8E%92%E5%90%8D%E9%97%AE%E9%A2%983.png" style="zoom:50%;">



<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux让你开发效率飞起</title>
    <url>/Tmux%E8%AE%A9%E4%BD%A0%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E9%A3%9E%E8%B5%B7/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p><code>ssh</code> 连接突然中断，之前操作记录丢失怎么办？终端不好管理，分窗口太乱怎么办？分屏幕操作切到眼花缭乱怎么办？鼠标键盘配合手忙脚乱怎么办？快来试试开发辅助神器 <code>Tmux</code> 吧！</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>你可以将 <code>Tmux</code> 称为一个分屏神器，但这有些以偏概全。因为它既可以有效的管理终端，又可以保存会话。它采用了 <code>C/S</code> 架构，使会话与终端窗口分离。这么说有些难理解，下面举个例子：</p>
<p>正常情况都是打开终端，执行命令；关闭终端，结束会话。当你使用 <code>ssh</code> 远程登录时，如果由于不可抗力因素（比如你女朋友不想让你看电脑，而是陪陪她，然后突然断网…）使得会话中断，再次登录想接着之前的思路，对不起，找不到历史记录了，岂不是尴尬？</p>
<p><code>Tmux</code> 就是为了解决这一痛点，将会话和终端分离。关闭终端后，会话继续保留，下次打开终端，连接即可。</p>
<h2 id="2-概念"><a href="#2-概念" class="headerlink" title="2.概念"></a>2.概念</h2><h3 id="2-1-会话"><a href="#2-1-会话" class="headerlink" title="2.1 会话"></a>2.1 会话</h3><p>一个会话可以看做一个进程或者一个服务器，它保留着之前操作的所有信息。</p>
<h3 id="2-2-窗口"><a href="#2-2-窗口" class="headerlink" title="2.2 窗口"></a>2.2 窗口</h3><p>进入一个会话后，我们可以创建许多窗口。每个窗口就好像给终端创建了 <code>tab</code> 页，每一个窗口都是一个终端页面。</p>
<h3 id="2-3-面板-窗格"><a href="#2-3-面板-窗格" class="headerlink" title="2.3 面板/窗格"></a>2.3 面板/窗格</h3><p>一个窗口，我们可以分为很多个 <code>Panel</code> 。就是将一个终端分为上下左右等小窗格。</p>
<blockquote>
<p>如下图，将一个窗口分为左右两个窗格，左边执行项目，右边查看日志。</p>
</blockquote>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/tmux.png" alt="Tmux 展示图"></p>
<h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3.安装"></a>3.安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu 或 Debian</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install tmux</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> CentOS 或 Fedora</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install tmux</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Mac</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install tmux</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-启动退出"><a href="#3-1-启动退出" class="headerlink" title="3.1 启动退出"></a>3.1 启动退出</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tmux</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure>

<h2 id="4-常用操作命令总结"><a href="#4-常用操作命令总结" class="headerlink" title="4.常用操作命令总结"></a>4.常用操作命令总结</h2><p>它有很多的操作命令，与此同时还提供了各种快捷键，可以根据个人喜欢进行选择。一听见要记快捷键或者命令就头疼，有木有？放心，常用的没几个：</p>
<h3 id="4-1-会话相关"><a href="#4-1-会话相关" class="headerlink" title="4.1 会话相关"></a>4.1 会话相关</h3><p>新建一个命名的会话，比如叫 <code>ethanyan_test</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux new -s ethanyan_test</span><br></pre></td></tr></table></figure>

<p>退出当前会话，但是保留，不杀死会话，为了下次直接连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux detach</span><br></pre></td></tr></table></figure>

<p>下次打开终端窗口，在接入上次会话</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux at -t ethanyan_test</span><br></pre></td></tr></table></figure>

<p>嫌弃会话的名称太难听了，想改个名字（这次我们使用快捷键方便一点）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Ctrl+b $</span><br></pre></td></tr></table></figure>

<p>解读：进入会话后，按 <code>Ctrl + b</code>，然后再输入 <code>$</code> 即可更改名字。（ <code>$</code> 就是在英文输入法下，先按 <code>shift</code> 再按键盘字母上面一排的数字 <code>4</code>）</p>
<blockquote>
<p>使用快捷键的方式，都是先按 <code>Ctrl + b</code>，告诉系统你要输入命令了，就如同 <code>vim</code> 中按 <code>esc</code> 进入命令模式一样，再输入快捷键。</p>
</blockquote>
<h3 id="4-2-窗口相关"><a href="#4-2-窗口相关" class="headerlink" title="4.2 窗口相关"></a>4.2 窗口相关</h3><p>窗口相关直接使用快捷键就完事了。</p>
<p>按 <code>Ctrl + b</code> 之后，再按如下的快捷键：</p>
<p><code>c</code> ：创建一个新窗口</p>
<p><code>w</code> ：列出所有窗口，此时可通过方向键和回车键切换选择</p>
<p><code>,</code> ：重命名当前窗口</p>
<p><code>&amp;</code> ：关闭当前窗口</p>
<h3 id="4-3-窗格相关"><a href="#4-3-窗格相关" class="headerlink" title="4.3 窗格相关"></a>4.3 窗格相关</h3><p>按 <code>Ctrl + b</code> 之后，再按如下的快捷键：</p>
<p><code>方向键</code> ：选择窗格</p>
<p><code>q</code> ：显示窗格编号，然后可以快速按对应数字键选择对应的窗格</p>
<p><code>z</code> ：将当前的窗格全屏或者还原</p>
<p><code>%</code> ：划分为左右两个窗格</p>
<p><code>&quot;</code> ：划分为上下两个窗格</p>
<blockquote>
<p>以上的快捷键和命令都是最最常用的，其他网上查到的命令不知道也无妨。</p>
</blockquote>
<h2 id="5-vi-命令记录"><a href="#5-vi-命令记录" class="headerlink" title="5.vi 命令记录"></a>5.vi 命令记录</h2><p>如果要到<strong>行首</strong>，可以在命令模式下，直接按数字键 <code>0</code>。如果要到<strong>行尾</strong>，按大写的 <code>A</code> ，即 <code>shift + a</code></p>
<h3 id="5-1-NERDTree-插件的快捷键"><a href="#5-1-NERDTree-插件的快捷键" class="headerlink" title="5.1 NERDTree 插件的快捷键"></a>5.1 NERDTree 插件的快捷键</h3><p><code>o</code> : 打开节点或者打开文件（打开文件的时候，光标会跑到文件中）</p>
<p><code>go</code> : 打开节点或者打开文件（打开文件的时候，光标在目录树中）</p>
<p><code>p</code> : 到上级目录</p>
<p><code>P</code> : 到根目录</p>
<p><code>？</code>: 帮助</p>
<p><code>q</code> : 关闭</p>
<p><code>K</code> : 到同级目录的第一个节点</p>
<p><code>J</code> : 到同级目录的最后一个节点</p>
<p><code>i</code> : 水平分割预览</p>
<p><code>s</code>: 垂直分割预览</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>tmux</category>
      </categories>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue脚手架搭建项目中的坑</title>
    <url>/Vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<center>Author:闫玉良</center>
Vue 框架如同 Python 中的 Django 框架一样，让一切操作变得超级简单，只需在规定的目录下书写规定的代码即可，至于如何运作，框架自己搞定。此篇文章仅用于记录 Vue 项目中的一些小坑。

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>我发现 <code>Vue</code> 这个框架真的超级严格，不按规定书写代码，就报错给你看！这与 <code>Python</code> 不同，在 <code>Python</code> 中大多数人都会遵循 <code>PEP8</code> ，但毕竟只是规范，除了一些中大型企业会去 <code>review</code> 代码，小型企业都是随缘，全凭编程人员习惯。</p>
<p>虽然动不动就报错，但是好在报错信息超级丰富，可快速定位，除了逻辑问题，其他问题均可快速定位解决。</p>
<h4 id="1-空行坑"><a href="#1-空行坑" class="headerlink" title="1.空行坑"></a>1.空行坑</h4><p>在 <code>Vue</code> 中，每个文件代码都<strong>必须</strong>以空行结尾！否则提醒你：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Newline required at end of file but not found</span><br><span class="line"><span class="meta">#</span><span class="bash"> 结尾未看到规定的空行</span></span><br></pre></td></tr></table></figure>

<p>注意，还只能是一行，要不然会提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Too many blank lines at the end of file. Max of 0 allowed</span><br><span class="line"><span class="meta">#</span><span class="bash"> 结尾的空行太多了，超出最大限制</span></span><br></pre></td></tr></table></figure>

<h4 id="2-字符串的坑"><a href="#2-字符串的坑" class="headerlink" title="2.字符串的坑"></a>2.字符串的坑</h4><p>在 <code>Python</code> 中字符串，可以是单引号、双引号，还可以是三引号。但如果在你的 <code>js</code> 文件中向这样写道：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"CopClass"</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'今晚吃什么'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它会提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">✘  http://eslint.org/docs/rules/quotes  Strings must use singlequote</span><br><span class="line">src/components/EnterPage.vue:13:9</span><br><span class="line">  name: "CopClass",</span><br></pre></td></tr></table></figure>

<p>瞧，告诉你字符串必须使用单引号，还指出了具体的位置。</p>
<h4 id="3-空格坑"><a href="#3-空格坑" class="headerlink" title="3.空格坑"></a>3.空格坑</h4><p>在 <code>data</code> 传递参数 <code>msg</code> 时，可要注意了，像下面的几种情况都会报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// first</span></span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'今晚吃什么'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// second</span></span><br><span class="line">  data ()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'今晚吃什么'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// third</span></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      msg: <span class="string">'今晚吃什么'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>都会及时告诉你某某处缺少空格，请核查。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>about me</title>
    <url>/about%20me/</url>
    <content><![CDATA[<a id="more"></a>





<ul>
<li>姓    名：闫玉良</li>
<li>英文名：EthanYan</li>
<li>昵    称：小闫同学</li>
<li>微信公众号：全栈技术精选（<code>id</code> 为 <code>Pythonnote</code>）</li>
<li>个人博客：<a href="https://www.pythonnote.cn/"><code>https://www.pythonnote.cn/</code></a></li>
<li>个人博客2：<a href="https://tech.shangyexinzhi.com/" target="_blank" rel="noopener"><code>https://tech.shangyexinzhi.com</code></a></li>
<li>GitHub：<code>https://github.com/EthanYan6</code></li>
<li>Gitee：<code>https://gitee.com/Ethanyan</code></li>
<li>CSDN、简书与头条号更新不及时，暂且不填</li>
</ul>
<center> > 扫描下方二维码关注微信公众号 < </center>

<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/Pythonnote.png" alt="全栈技术精选"></p>
]]></content>
      <categories>
        <category>website</category>
      </categories>
      <tags>
        <tag>website</tag>
      </tags>
  </entry>
  <entry>
    <title>bat脚本常用命令</title>
    <url>/bat%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<center>Author：闫玉良</center>
bat 脚本？如果不是从事微软开发相关工作的人员，是不是感觉很耳熟但是又好像不熟悉？还等什么，一睹为快

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>bat 脚本是 windows 上所用的脚本，我们经常使用的 cmd 一些命令就可以使用。也许你会说为什么不使用 powershell 脚本？因为古老的一些服务器上面没有安装 powershell 你信不信？比如 windows server 2003。</p>
<p>很荣幸，我遇到了，没有什么办法，只能查阅相关资料迎难而上了！脚本其实很简单，下面做一个记录，供大家有需要时获取：</p>
<h4 id="1-设置变量"><a href="#1-设置变量" class="headerlink" title="1.设置变量"></a>1.设置变量</h4><p>设置变量使用 <code>SET</code> 关键字，语法如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">SET 变量名=变量值</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.<strong>变量名与变量值一定要紧挨等于号！！！</strong>否则报错到怀疑人生。</p>
<p>2.变量值如果是个字符串，直接写内容，不需要加双引号。（是不是很方便）</p>
</blockquote>
<h4 id="2-使用变量"><a href="#2-使用变量" class="headerlink" title="2.使用变量"></a>2.使用变量</h4><p>使用变量时语法如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">%变量名%</span><br></pre></td></tr></table></figure>

<h4 id="3-判断语句"><a href="#3-判断语句" class="headerlink" title="3.判断语句"></a>3.判断语句</h4><p>判断语句必不可少，if … else… 语法如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件 (</span><br><span class="line">	条件成立执行内容</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">	条件不成立执行内容</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="4-回显"><a href="#4-回显" class="headerlink" title="4.回显"></a>4.回显</h4><p>类似于 python 中的 print 函数，即将后方的内容打印输出：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">echo 我就是要回显的内容</span><br></pre></td></tr></table></figure>

<h4 id="5-创建文件夹"><a href="#5-创建文件夹" class="headerlink" title="5.创建文件夹"></a>5.创建文件夹</h4><p>创建目录你还在想 <code>mkdir</code> 的时候，windows 已经考虑简化了：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">md 文件夹路径</span><br></pre></td></tr></table></figure>

<blockquote>
<p>之所以写文件夹路径，是因为可以创建嵌套目录啊！不需要任何参数，简单不简单？</p>
</blockquote>
<h4 id="6-输出内容到文件"><a href="#6-输出内容到文件" class="headerlink" title="6.输出内容到文件"></a>6.输出内容到文件</h4><p>大家如果熟悉 Linux 系统，那么对于重定向命令一定很熟悉了，bat 脚本完全一样，如果是创建一个文件，或者已有文件覆盖内容的话，可以使用 <code>&gt;</code> 命令；如果是要往加过里面追加内容的话，直接使用 <code>&gt;&gt;</code> 即可。示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo test content &gt; C:\test\test.txt</span><br></pre></td></tr></table></figure>

<h4 id="7-关闭系统信息回显"><a href="#7-关闭系统信息回显" class="headerlink" title="7.关闭系统信息回显"></a>7.关闭系统信息回显</h4><p>我们在执行脚本的时候，系统会执行 N 多步可知，不可知的步骤，因此会输出大量的信息，如果只想看自己回显的信息呢？可以使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要再文件的开头书写</p>
</blockquote>
<h4 id="8-标题"><a href="#8-标题" class="headerlink" title="8.标题"></a>8.标题</h4><p>小黑窗口左上角的字该怎么改呢？看下方：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@title monitoring_log by EthanYan</span><br></pre></td></tr></table></figure>

<h4 id="9-其他"><a href="#9-其他" class="headerlink" title="9.其他"></a>9.其他</h4><p>如果你看其他人写的脚本，也许会在文件开头看到这样一句：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mode con lines=5 cols=40</span><br></pre></td></tr></table></figure>

<p>它是设置显示内容的小黑窗口大小的命令。lines 指的是高，cols 指宽度。</p>
]]></content>
      <categories>
        <category>windows</category>
        <category>script</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab定时执行python脚本不成功解决方案</title>
    <url>/crontab%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8Cpython%E8%84%9A%E6%9C%AC%E4%B8%8D%E6%88%90%E5%8A%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
目前有一个需求是定时执行某个 python 脚本，但是在 Linux 上设置 crontab 后，不生效？手动执行生效？于是使用下面的方法执行即可：

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>大体思路为先写一个 <code>shell</code> 脚本，脚本中执行 <code>python</code> 文件，然后定时执行 <code>shell</code> 脚本即可。具体原因不明，正在探索中 …… 目前只提供一种解决方案。</p>
<p>1.使用如下命令创建脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi start.sh</span><br></pre></td></tr></table></figure>

<p>2.然后在 <code>start.sh</code> 脚本中结合本身情况输入内容，示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/bash</span></span><br><span class="line">cd /opt</span><br><span class="line">/usr/bin/python3 /opt/test_mail.py</span><br></pre></td></tr></table></figure>

<p>3.然后使用如下命令，编辑定时任务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<p>4.假如设定每天 8 点执行脚本，设置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 8 * * * /opt/start.sh</span><br></pre></td></tr></table></figure>

<p>5.保存定时任务，几分钟后自动生效。</p>
<blockquote>
<p><strong>注意</strong>：所有的路径都使用<strong>绝对路径</strong>，否则仍然无效。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
        <tag>crontab</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>Pocoo风格</title>
    <url>/Pocoo%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<p>「无规矩不成方圆」<code>Python</code> 官方为所有开发人员制定了一套编码规范 - <code>PEP 8</code>。然而大部分研发团队并没有满足于此，就如同 <code>Flask</code> 框架的开发团队 <code>Pocoo</code> ，基于 <code>PEP 8</code> 进行调整扩充，形成了一套新的编码风格。如果你的项目正好使用了此框架，强烈建议仔细阅读。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-整体布局"><a href="#1-整体布局" class="headerlink" title="1.整体布局"></a>1.整体布局</h2><p>1) 缩进采用4个空格，而非制表符（ <code>Tab</code> 键）</p>
<p>2) 每行代码的长度不应该超过84个字符，最好保持在79个以内</p>
<blockquote>
<p>可以通过 <code>break</code> 、 <code>continue</code> 和 <code>return</code> 等关键字避免层层嵌套，既保持代码的美观，又提升可读性（不必左右拉取进度条）。</p>
</blockquote>
<p>3) 如果代码超过如何续行？可以尝试反斜杠 <code>\</code>  ，如下方的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">this_is_a_very_long(function_call, 'with many parameters') \</span><br><span class="line">    .that_returns_an_object_with_an_attribute</span><br><span class="line"></span><br><span class="line">MyModel.query.filter(MyModel.scalar &gt; 120) \</span><br><span class="line">             .order_by(MyModel.name.desc()) \</span><br><span class="line">             .limit(10)</span><br><span class="line">             </span><br><span class="line">this_is_a_very_long(function_call, 'with many parameters',</span><br><span class="line">                    23, 42, 'and even more')</span><br><span class="line">                    </span><br><span class="line">items = [</span><br><span class="line">    'this is the first', 'set of items', 'with more items',</span><br><span class="line">    'to come in this line', 'like this'</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：为了保持美观，可以将链式调用中每个方法前的点 <code>.</code> 对齐；如果是括号内的换行，请将下一行与上一行的括号对齐，不需要使用续行符号；如果字典、列表、元祖内元素超级多，在起始括号后立即换行。</p>
</blockquote>
<p>4) 顶层函数和类由两个空行分隔，其它一个空行。不要使用过多空行来分隔代码逻辑段。例如:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def hello(name):</span><br><span class="line">    print 'Hello %s!' % name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def goodbye(name):</span><br><span class="line">    print 'See you %s.' % name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyClass(object):</span><br><span class="line">    """This is a simple docstring"""</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def get_annoying_name(self):</span><br><span class="line">        return self.name.upper() + '!!!!111'</span><br></pre></td></tr></table></figure>

<h2 id="2-表达式与代码语句"><a href="#2-表达式与代码语句" class="headerlink" title="2.表达式与代码语句"></a>2.表达式与代码语句</h2><h3 id="2-1-常规空格规则"><a href="#2-1-常规空格规则" class="headerlink" title="2.1 常规空格规则"></a>2.1 常规空格规则</h3><p>1) 不是关键词的一元运算符不使用空格（例如： <code>-</code>、 <code>~</code> 等等），对于圆括号也是这样。</p>
<p>2) 用空格包围二元运算符。</p>
<p>对:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exp = -1.05</span><br><span class="line">value = (item_value / item_count) * offset / exp</span><br><span class="line">value = my_list[index]</span><br><span class="line">value = my_dict['key']</span><br></pre></td></tr></table></figure>

<p>错:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exp = - 1.05</span><br><span class="line">value = ( item_value / item_count ) * offset / exp</span><br><span class="line">value = (item_value/item_count)*offset/exp</span><br><span class="line">value=( item_value/item_count ) * offset/exp</span><br><span class="line">value = my_list[ index ]</span><br><span class="line">value = my_dict ['key']</span><br></pre></td></tr></table></figure>

<h3 id="2-2-禁止-Yoda-语句"><a href="#2-2-禁止-Yoda-语句" class="headerlink" title="2.2 禁止 Yoda 语句"></a>2.2 禁止 <code>Yoda</code> 语句</h3><p>永远不要用变量来比较常量，而是用常量来比较变量：</p>
<p>对:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if method == 'md5':</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>错:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if 'md5' == method:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<h3 id="2-3-比较"><a href="#2-3-比较" class="headerlink" title="2.3 比较"></a>2.3 比较</h3><p>1) 针对任意类型使用 <code>==</code> 和 <code>!=</code></p>
<p>2) 针对单一类型使用 <code>is</code> 和 <code>is not</code>（例如： <code>foo is not None</code> ）</p>
<p>3) 永远不要与 <code>True</code> 或 <code>False</code> 作比较（例如永远不要写 <code>foo == False</code> ，而应当写 <code>not foo</code> ）</p>
<h3 id="2-4-排除检验"><a href="#2-4-排除检验" class="headerlink" title="2.4 排除检验"></a>2.4 排除检验</h3><p>使用 <code>foo not in bar</code> 而不是 <code>not foo in bar</code></p>
<h3 id="2-5-实例检验"><a href="#2-5-实例检验" class="headerlink" title="2.5 实例检验"></a>2.5 实例检验</h3><p>使用 <code>isinstance(a, C)</code> 而不是 <code>type(A) is C</code> ，但是通常应当避免检验实例，而应当检验特性。</p>
<h2 id="3-命名"><a href="#3-命名" class="headerlink" title="3.命名"></a>3.命名</h2><p>1) 类名采用大驼峰： <code>CamelCase</code> ，缩写词大写（ <code>HTTPWriter</code> 而不是 <code>HttpWriter</code>）</p>
<p>2) 变量名采用下划线连接： <code>lowercase_with_underscores</code></p>
<p>3) 方法和函数名采用下划线连接： <code>lowercase_with_underscores</code></p>
<p>4) 常量全部大写并采用下划线连接： <code>UPPERCASE_WITH_UNDERSCORES</code></p>
<p>5) 预编译正则表达式： <code>name_re</code></p>
<p>被保护的成员以单个下划线作为前缀，混合类则使用双下划线。</p>
<p>如果使用关键字作为类的名称，那么在名称末尾添加下划线。与内置构件冲突是允许的，请一定不要用 在变量名后添加下划线 的方式解决冲突。如果函数需要访问一个隐蔽的内置构件，请重新绑定内置构件到一个不同的名字。</p>
<h3 id="3-1-函数和方法参数"><a href="#3-1-函数和方法参数" class="headerlink" title="3.1 函数和方法参数"></a>3.1 函数和方法参数</h3><p>1) 类方法: <code>cls</code> 作为第一个参数</p>
<p>2) 实例方法: <code>self</code> 作为第一个参数</p>
<p>3) 用于属性的 <code>lambda</code> 表达式应该把第一个参数替换为 <code>x</code> ， 像下方代码一样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">display_name = property(lambda x: x.real_name or x.username)</span><br></pre></td></tr></table></figure>

<h2 id="4-文档字符串"><a href="#4-文档字符串" class="headerlink" title="4.文档字符串"></a>4.文档字符串</h2><h3 id="4-1-文档字符串约定"><a href="#4-1-文档字符串约定" class="headerlink" title="4.1 文档字符串约定"></a>4.1 文档字符串约定</h3><p>所有的文档字符串为 <code>Sphinx</code> 可理解的 <code>reStructuredText</code> 格式。它们的形态 因行数不同而不同。如果只有一行，三引号闭合在同一行，否则开头的三引号与文本在同一行，结尾的三引号独立一行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    """This is a simple docstring"""</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def bar():</span><br><span class="line">    """This is a longer docstring with so much information in there</span><br><span class="line">    that it spans three lines.  In this case the closing triple quote</span><br><span class="line">    is on its own line.</span><br><span class="line">    """</span><br></pre></td></tr></table></figure>

<h3 id="4-2-模块首行"><a href="#4-2-模块首行" class="headerlink" title="4.2 模块首行"></a>4.2 模块首行</h3><p>模块首行包含一个 <code>utf-8</code> 编码声明（即使没有使用非 <code>ASCII</code> 字符，也始终推荐这么做）和一个标准的文档字符串:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -*- coding: utf-8 -*-</span></span><br><span class="line">"""</span><br><span class="line">    package.module</span><br><span class="line">    ~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line">    A brief description goes here.</span><br><span class="line"></span><br><span class="line">    :copyright: (c) YEAR by AUTHOR.</span><br><span class="line">    :license: LICENSE_NAME, see LICENSE_FILE for more details.</span><br><span class="line">"""</span><br></pre></td></tr></table></figure>

<p>谨记使用合适的版权和许可证文件以利于通过 <code>Flask</code> 扩展审核。</p>
<h2 id="5-注释"><a href="#5-注释" class="headerlink" title="5.注释"></a>5.注释</h2><p>注释的规则与文档字符串类似。两者都使用 <code>reStructuredText</code> 格式。如果一个 注释被用于一个说明类属性，在起始的井号（ <code>#</code> ）后加一个冒号:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">class User(object):</span><br><span class="line">    #: the name of the user as unicode string</span><br><span class="line">    name = Column(String)</span><br><span class="line">    #: the sha1 hash of the password + inline salt</span><br><span class="line">    pw_hash = Column(String)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>翻译自官方文档 <a href="https://flask.palletsprojects.com/en/1.0.x/styleguide/" target="_blank" rel="noopener">https://flask.palletsprojects.com/en/1.0.x/styleguide/</a></p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>flask</category>
        <category>pocoo</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>pocoo</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch中join类型数据如何进行父子文档查询</title>
    <url>/elasticsearch%E4%B8%ADjoin%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%88%B6%E5%AD%90%E6%96%87%E6%A1%A3%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 

<p>ES 中 join 类型数据如何根据父文档查询全部子文档？又如何根据子文档查询其父文档呢？</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-join-简介"><a href="#1-join-简介" class="headerlink" title="1.join 简介"></a>1.join 简介</h2><p>在 <code>ES</code> 中有一种特殊的数据类型『<code>join</code>』，被形象地称为父子文档。它是一种可以在同一索引中存放两种有关系数据的数据类型，类似于关系数据库中让两张表发生关系的<strong>外键 <code>FOREIGN KEY</code></strong> 。</p>
<p>在官方文档中这样介绍：<code>join</code> 数据类型的字段是一个特殊字段，它可以在同一个索引的文档中创建 <code>父子关系</code> 。通过参数 <code>relations</code> 定义可能存在关系的一组文档，这个关系的参数由 <code>父名</code> 和 <code>子名</code> 构成。下方是原文档描述：</p>
<p>The <code>join</code> datatype is a special field that creates parent/child relation within documents of the same index. The <code>relations</code> section defines a set of possible relations within the documents, each relation being a parent name and a child name. </p>
<h2 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义"></a>2.定义</h2><p>我们需要在设置 <code>mapping</code> 时将其关系定义好，如下示例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT 索引名称</span><br><span class="line">&#123;</span><br><span class="line">  "mappings": &#123;</span><br><span class="line">    "properties": &#123;</span><br><span class="line">      "join类型的字段名称": &#123; </span><br><span class="line">        "type": "join",</span><br><span class="line">        "relations": &#123;</span><br><span class="line">          "父文档标示字段名": "子文档标示字段名" </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-1-父文档"><a href="#2-1-父文档" class="headerlink" title="2.1 父文档"></a>2.1 父文档</h3><p>构建父文档时可以通过如下方法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT 索引名称/类型/文档id?refresh</span><br><span class="line">&#123;</span><br><span class="line">  "text": "EthanYan",</span><br><span class="line">  ...		// 父文档中其他的字段与值</span><br><span class="line">  "join类型的字段名称": &#123;</span><br><span class="line">    "name": "父文档标示字段名" </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式是为了便于理解，与下方子文档中构建方式对应。当你运用熟练后，有一种简便的构建方法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT 索引名称/类型/文档id?refresh</span><br><span class="line">&#123;</span><br><span class="line">  "text": "EthanYan",</span><br><span class="line">  ...		// 父文档中其他的字段与值</span><br><span class="line">  "join类型的字段名称": "父文档标示字段名" </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-子文档"><a href="#2-2-子文档" class="headerlink" title="2.2 子文档"></a>2.2 子文档</h3><p>构建子文档时可以通过如下方法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT 索引名称/类型/文档id?routing=父文档id&amp;refresh </span><br><span class="line">&#123;</span><br><span class="line">  "text": "xiaoyan",</span><br><span class="line">  ...		// 子文档中其他的字段与值</span><br><span class="line">  "join类型的字段名称": &#123;</span><br><span class="line">    "name": "子文档标示字段名", </span><br><span class="line">    "parent": "父文档id" </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>构建子文档时与父文档有些许不同，以下几点需要特别注意：</p>
<p>1.<code>url</code> 中可以看到有一个参数 <code>routing</code> ，<strong>此参数必须设置</strong>，因为我们需要保证父文档与子文档在同一分片中。其原文描述为：The routing value is mandatory because parent and child documents must be indexed on the same shard.</p>
<p>2.我们可以看到子文档在 <code>join</code> 类型字段中除了参数 <code>name</code> 外，还多了一个参数 <code>parent</code> ，故名思义，此字段为了指明父文档的所在，其值填写为父文档的 <code>id</code></p>
<h2 id="3-查询"><a href="#3-查询" class="headerlink" title="3.查询"></a>3.查询</h2><p>此字段类型当然是为了查询而存在，要不然没有灵魂。下面举例进行说明。索引名为 <code>sales_org</code></p>
<p>有一个父文档为下方示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"node_name_cn"</span>: <span class="string">"川渝"</span>,</span><br><span class="line">  <span class="attr">"node_code"</span>: <span class="string">"LP.IIB.RW.CTU"</span>,</span><br><span class="line">  <span class="attr">"node_type"</span>: <span class="string">"办事处"</span>,</span><br><span class="line">  <span class="attr">"node_id_fqdn"</span>: <span class="string">"SI/LP/LP.IIB.RW/LP.IIB.RW.CTU"</span>,</span><br><span class="line">  <span class="attr">"node_name_fqdn"</span>: <span class="string">"SI/LP//川渝"</span>,</span><br><span class="line">  <span class="attr">"node_name_en"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"mgmt_territory"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"node_tree_level"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">"node_name_short"</span>: <span class="string">"LP.IIB.RW.CTU"</span>,</span><br><span class="line">  <span class="attr">"node_info"</span>: <span class="string">"node_parent"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个子文档示例如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;	</span><br><span class="line">  <span class="attr">"empl_id"</span>: <span class="string">"*******"</span>,</span><br><span class="line">  <span class="attr">"email_addr"</span>: <span class="string">"*****@fafa.com"</span>,</span><br><span class="line">  <span class="attr">"dept_id"</span>: <span class="string">"LP.IIB.RW.CTU"</span>,</span><br><span class="line">  <span class="attr">"name_cn"</span>: <span class="string">"Nie Cong"</span>,</span><br><span class="line">  <span class="attr">"node_info"</span>: &#123;</span><br><span class="line">    <span class="attr">"parent"</span>: <span class="string">"LP.IIB.RW.CTU"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"node_child"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>join</code> 类型字段名为 <code>node_info</code> ，父文档标示字段名为 <code>node_parent</code> ，子文档标示字段名为 <code>node_child</code> 。</p>
<h3 id="3-1-基于父文档查询全部子文档"><a href="#3-1-基于父文档查询全部子文档" class="headerlink" title="3.1 基于父文档查询全部子文档"></a>3.1 基于父文档查询全部子文档</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST sales_org/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "has_parent": &#123;</span><br><span class="line">      "parent_type": "node_parent",		// 填写父文档标示字段名</span><br><span class="line">      "query": &#123;		// 填写查询条件，注意填写的查询条件是查询父文档，该查询条件是为定位到要基于的父文档</span><br><span class="line">        "match": &#123;</span><br><span class="line">          "_id": "LP.IIB.RW.CTU"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-基于子文档查询其父文档"><a href="#3-2-基于子文档查询其父文档" class="headerlink" title="3.2 基于子文档查询其父文档"></a>3.2 基于子文档查询其父文档</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "has_child": &#123;</span><br><span class="line">      "type": "node_child",		// 填写子文档标示字段名</span><br><span class="line">      "query": &#123;		// 填写查询条件，注意填写的查询条件是查询子文档，该查询条件是为定位到要基于的子文档</span><br><span class="line">        "match": &#123;</span><br><span class="line">          "dept_id": "LP.IIB.RW.CTU"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>django这些查询技巧你会了吗?</title>
    <url>/django%E8%BF%99%E4%BA%9B%E6%9F%A5%E8%AF%A2%E6%8A%80%E5%B7%A7%E4%BD%A0%E4%BC%9A%E4%BA%86%E5%90%97/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>任何不考虑后果的查询都是耍流氓！</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-select-related"><a href="#1-select-related" class="headerlink" title="1.select_related"></a>1.select_related</h2><blockquote>
<p>关联查询优化，只会进行<strong>一次</strong>查询，然后缓存结果。平时其他方法都是惰性查询，当每次取值时都会查询一次数据库。</p>
<p><strong>建议</strong>：所有关联查询使用此方法。</p>
</blockquote>
<p>假设有两张表，一张表是书籍，一张表是英雄人物：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 书籍表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    btitle = models.CharField(max_length=<span class="number">20</span>, verbose_name=<span class="string">'名称'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'tb_books'</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># 英雄表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    GENDER_CHOICES = (</span><br><span class="line">        (<span class="number">0</span>, <span class="string">'male'</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">'female'</span>)</span><br><span class="line">    )</span><br><span class="line">    hname = models.CharField(max_length=<span class="number">20</span>, verbose_name=<span class="string">'名称'</span>)</span><br><span class="line">    hgender = models.SmallIntegerField(choices=GENDER_CHOICES, default=<span class="number">0</span>, verbose_name=<span class="string">'性别'</span>)</span><br><span class="line">    hbook = models.ForeignKey(BookInfo, on_delete=models.CASCADE, verbose_name=<span class="string">'图书'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'tb_heros'</span></span><br></pre></td></tr></table></figure>

<p>现在要查询所有的英雄以及他们所在的书籍名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heros = HeroInfo.objects.select_related(<span class="string">'hbook'</span>).all()</span><br><span class="line"><span class="comment"># 查询之后构造一个字典</span></span><br><span class="line">heros_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> hero <span class="keyword">in</span> heros:</span><br><span class="line">    heros_dict[hero.hname] = hero.hbook.btitle  <span class="comment"># 关联查询后，直接使用.取值即可，不会再进行数据库查询</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.如上 <code>select_related</code> 中的参数 <code>hbook</code> 为外键名称，它会将所关联的表中所有信息都查询出来。</p>
<p>2.如果书籍表 <code>BookInfo</code> 中还有外键，我们还想再关联查询那张表的信息，可以用如下的方式：<code>hbook__外键名称</code>，外键和外键之间用双下划线连接。如果有三层关系可以：<code>外键名称__外键名称__外键名称</code>，以此类推，快乐就完事儿了。</p>
<p>3.<code>select_related</code> 中还可以通过参数 <code>depth</code> 指定查询的深度。比如示例中可以改为：<code>select_related(depth=1)</code>，它的意思就是往下查询一层。如果书籍表中还有外键，我们都想查询出来，可以：<code>select_related(depth=2)</code>，以此类推。</p>
<p>4.示例中的方式是指定查询的外键，只查询了英雄类中所关联的图书。如果英雄类中有好几个外键，我们都想关联查询，参数 <code>depth</code> 的优势就凸显出来了，不需要详细写出每一个外键的名称。</p>
</blockquote>
<p>最后的结果形如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'迪迦'</span>: <span class="string">'迪迦奥特曼'</span>,</span><br><span class="line">  <span class="string">'武松'</span>: <span class="string">'水浒传'</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-values-list"><a href="#2-values-list" class="headerlink" title="2.values_list"></a>2.values_list</h2><blockquote>
<p>取出指定字段，组成列表</p>
</blockquote>
<p>比如我需要一个所有英雄名称的列表：<code>[&#39;迪迦&#39;, &#39;武松&#39;...]</code>。你可能想到的方法是查询出所有的英雄信息，然后遍历每个对象，将对象的名称放到指定的列表中，完成需求。使用 <code>values_list</code> 可以一步到位：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list(HeroInfo.objects.values_list(<span class="string">'hname'</span>, flat=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>

<h3 id="2-1-详解"><a href="#2-1-详解" class="headerlink" title="2.1 详解"></a>2.1 详解</h3><p>1.<code>values_list</code> 中第一个参数填写的是要查询的字段名称，此处为 <code>hname</code> ；第二个参数 <code>flat</code> 设置为 <code>True</code> 是为了不以元祖的形式展示，而是直接将值取出来，形如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;QuerySet [<span class="string">'迪迦'</span>, <span class="string">'武松'</span>...]&gt;</span><br><span class="line"><span class="comment"># 不设置 flat 结果如下</span></span><br><span class="line">&lt;QuerySet [(<span class="string">'迪迦'</span>,), (<span class="string">'武松'</span>,)...]&gt;</span><br></pre></td></tr></table></figure>

<p>2.有人会问：为什么外面要使用 <code>list</code> 方法呢？如上示例，查询结果是一个 <code>QuerySet</code> 对象，为了使用方便，一般根据需要转换为 <code>python</code> 的列表。</p>
<h2 id="3-annotate"><a href="#3-annotate" class="headerlink" title="3.annotate"></a>3.annotate</h2><blockquote>
<p>聚合函数</p>
</blockquote>
<p><strong>需求</strong>：统计出英雄表中男女的数量，显示聚合结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count</span><br><span class="line"></span><br><span class="line">HeroInfo.objects.values(<span class="string">'hgender'</span>).annotate(number=Count(<span class="string">'hgender'</span>))</span><br></pre></td></tr></table></figure>

<h3 id="3-1-详解"><a href="#3-1-详解" class="headerlink" title="3.1 详解"></a>3.1 详解</h3><p>1.上方的意思是根据字段 <code>hgender</code> 进行分组，然后统计每组的人数，人数一列起名为 <code>number</code></p>
<p>2.查询结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;QuerySet [&#123;<span class="string">'hgender'</span>: <span class="number">0</span>, <span class="string">'number'</span>: <span class="number">10</span>&#125;, &#123;<span class="string">'hgender'</span>: <span class="number">1</span>, <span class="string">'number'</span>: <span class="number">3</span>&#125;]&gt;</span><br></pre></td></tr></table></figure>

<p>3.可以看出英雄表中男性（0）为 10 人；女性（1）为 3 人。</p>
<p>4.<strong>注意</strong>：<code>values</code> 和 <code>annotate</code> 的顺序一定要特别关注！示例中的顺序代表根据性别分组显示聚合结果，但是反过来后就变成了先根据 <code>hgender</code> 统计数量，最后只取字段 <code>hgender</code> 的值。</p>
<blockquote>
<p>也许你会想示例中既然  <code>annotate</code> 可以统计数量，那么直接使用去掉 <code>values</code> 不是好了？不对！它是统计了数量，但只是为查询的每行记录赋予了一个新字段 <code>number</code> ，并没有聚合结果，不如示例中那样清晰，哪个性别有几个，展示的明明白白。</p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器数据持久化</title>
    <url>/docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p><code>docker</code> 容器内的数据是独立于镜像之外的，那么如何将其持久化到宿主机呢？答案便是利用「数据卷」，那什么又是「数据卷」呢？</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><p><strong>数据卷其实就是一个目录或者一个文件</strong>，该目录（或文件）可以存在于宿主机上。将此目录（或文件）映射到容器中，便可以持久化容器内的数据到宿主机。如果目录不存在于宿主机上，而是存在于一个容器内部，那么此容器便可以被称为「<strong>数据卷容器</strong>」</p>
<p>下面讲解一下具体的操作方式。</p>
<h2 id="1-持久化到目录"><a href="#1-持久化到目录" class="headerlink" title="1.持久化到目录"></a>1.持久化到目录</h2><p>数据卷如果是宿主机的一个目录，可以进行如下操作将容器内的数据持久化：</p>
<h3 id="1-1-命令介绍"><a href="#1-1-命令介绍" class="headerlink" title="1.1 命令介绍"></a>1.1 命令介绍</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --name [容器名字] -v [宿主机目录]:[容器目录] [镜像名称] [命令(可选)]</span><br></pre></td></tr></table></figure>

<p>该命令<strong>解读</strong>：通过一个镜像启动一个容器。利用 <code>--name</code> 指定容器的名称；利用 <code>-v</code> 指定宿主机的某目录作为数据卷挂载到容器中，使该容器与宿主机共享此目录 。</p>
<blockquote>
<p><strong>注意</strong>：1.如果本地路径不存在，<code>docker</code> 会贴心的自动创建。2.宿主机的目录请使用<strong>绝对路径</strong>。</p>
</blockquote>
<h3 id="1-2-操作"><a href="#1-2-操作" class="headerlink" title="1.2 操作"></a>1.2 操作</h3><p>1) 执行如下命令，将宿主机的 <code>/Users/ethanyan/dockerdata/</code> 目录映射到新创建的 <code>nginx</code> 容器中的 <code>/data</code> 目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --name nginx -v /Users/ethanyan/dockerdata:/data nginx</span><br></pre></td></tr></table></figure>

<p>2) 接下来验证是否生效，先在本地共享目录下创建一个新目录 <code>NG</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /Users/ethanyan/dockerdata</span><br><span class="line">mkdir NG</span><br></pre></td></tr></table></figure>

<p>3) 进入容器 <code>nginx</code> 中看是否存在 <code>NG</code> 目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it nginx /bin/bash</span><br><span class="line"></span><br><span class="line">root@81bbc2c2bf5c:/# cd /data/</span><br><span class="line">root@81bbc2c2bf5c:/data# ls</span><br><span class="line">NG</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可发现在本地创建目录后，容器内的确实也出现了新建的目录。</p>
</blockquote>
<p>4) 反向进行操作。在容器的 <code>/data/NG</code> 目录中创建一个文件 <code>testdata.txt</code> ，退出容器后发现本地也出现了该文件。从而得出<strong>使用此方法可以让容器和宿主机共享目录，并将容器内的数据持久化到本地</strong>。</p>
<h2 id="2-持久化到文件"><a href="#2-持久化到文件" class="headerlink" title="2.持久化到文件"></a>2.持久化到文件</h2><h3 id="2-1-命令介绍"><a href="#2-1-命令介绍" class="headerlink" title="2.1 命令介绍"></a>2.1 命令介绍</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --name [容器名字] -v [宿主机文件]:[容器文件] [镜像名称] [命令(可选)]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>-d</code> 是创建容器后，使其在后台持续运行。</p>
</blockquote>
<h3 id="2-2-操作"><a href="#2-2-操作" class="headerlink" title="2.2 操作"></a>2.2 操作</h3><p>1) 执行如下命令，将本地的 <code>testdata.txt</code> 文件映射到容器的 <code>testdata.txt</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --name nginx_test -v /Users/ethanyan/dockerdata/NG/testdata.txt:/data/testdata.txt nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同样是创建了一个容器，此容器基于镜像 <code>nginx</code> ，并命名为 <code>nginx_test</code> 。</p>
</blockquote>
<p><strong>注意：</strong>宿主机要映射的文件与容器内的文件名称可以不同，但是文件类型必须相同！</p>
<p>2) 接下来同样验证一下此操作。在本地的文件 <code>/Users/ethanyan/dockerdata/NG/testdata.txt</code> 中写入 <code>hello world</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /Users/ethanyan/dockerdata/NG/</span><br><span class="line">echo 'hello world' &gt; testdata.txt</span><br></pre></td></tr></table></figure>

<p>3) 进入容器内，执行下列操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@8694fd7cba10:/# cd /data</span><br><span class="line">root@8694fd7cba10:/data# ls</span><br><span class="line">testdata.txt</span><br><span class="line">root@8694fd7cba10:/data# cat testdata.txt</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>4) 验证了宿主机修改文件后容器内文件也被修改。接下来我们在容器内修改一下内容，看本地是否也被修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it nginx /bin/bash</span><br><span class="line"></span><br><span class="line">root@8694fd7cba10:/# cd /data</span><br><span class="line">root@8694fd7cba10:/data# ls</span><br><span class="line">testdata.txt</span><br><span class="line">root@8694fd7cba10:/data# echo 'xxx测试用' &gt;&gt; testdata.txt</span><br><span class="line">root@8694fd7cba10:/data# cat testdata.txt</span><br><span class="line">hello world</span><br><span class="line">xxx测试用</span><br><span class="line">root@8694fd7cba10:/data# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>) 然后在本地查看发现内容也被更改。<strong>说明可以使用文件持久化数据</strong>。</p>
<h2 id="3-持久化到容器"><a href="#3-持久化到容器" class="headerlink" title="3.持久化到容器"></a>3.持久化到容器</h2><p>如果不想这些数据直接暴露在宿主机，可以使用数据卷容器的方式。将数据卷容器挂载到其他容器，就可以多个容器之间共享数据了，而且还可以持久化的保存数据（后面会讲解如何备份和恢复数据卷容器）</p>
<p><strong>注意：数据卷容器不启动</strong></p>
<h3 id="3-1-步骤"><a href="#3-1-步骤" class="headerlink" title="3.1 步骤"></a>3.1 步骤</h3><p>1) 创建数据卷容器</p>
<p>2) 将数据卷容器挂载到其他容器 </p>
<p><strong>注意：使用数据卷容器是容器之间共享数据，不涉及宿主机，因此数据没有在宿主机上。</strong></p>
<h3 id="3-2-示例"><a href="#3-2-示例" class="headerlink" title="3.2 示例"></a>3.2 示例</h3><p>1) 创建一个数据卷容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">docker create -v [容器数据卷目录] --name [容器名字] [镜像名称] [命令(可选)]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line">docker create -v /data/ --name data nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>既然需要创建一个数据卷容器，那么就需要使用镜像，因为我电脑只有一个 <code>nginx</code> 镜像，那么使用它即可。一般大家都习惯使用 <code>centos</code> 或者 <code>Ubuntu</code> 作为基础镜像</p>
</blockquote>
<p>2) 创建两个容器（为了测试是否可以在容器间共享数据），并都挂载数据卷容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建容器并挂载数据卷命令</span></span><br><span class="line">docker run --volumes-from [数据卷容器 id/name] -itd --name [容器名字] [镜像名称] [命令(可选)]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例 </span></span><br><span class="line">docker run  --volumes-from db847d3fc055 -itd --name nginx_test1 nginx /bin/bash</span><br><span class="line">docker run  --volumes-from db847d3fc055 -itd --name nginx_test2 nginx /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：db847d3fc055 为数据卷容器id</span></span><br></pre></td></tr></table></figure>

<p>3) <strong>验证操作</strong></p>
<p>先进入容器 <code>nginx_test1</code> 中进行操作，创建一个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it nginx_test1 /bin/bash</span><br><span class="line"></span><br><span class="line">root@72abfcc9e2e9:/# ls /data/</span><br><span class="line">root@72abfcc9e2e9:/# touch /data/file.txt</span><br><span class="line">root@72abfcc9e2e9:/# ls /data/</span><br><span class="line">file.txt</span><br><span class="line">root@72abfcc9e2e9:/# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>进入容器 <code>nginx_test2</code> 验证，并修改文件内容进行反向验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it nginx_test2 /bin/bash</span><br><span class="line"></span><br><span class="line">root@c5f2c2463640:/# ls /data/</span><br><span class="line">file.txt</span><br><span class="line">root@c5f2c2463640:/# echo 'hello world' &gt; /data/file.txt</span><br><span class="line">root@c5f2c2463640:/# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>然后再进入容器 <code>nginx_test1</code> 验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it nginx_test1 /bin/bash</span><br><span class="line"></span><br><span class="line">root@72abfcc9e2e9:/# ls /data/</span><br><span class="line">file.txt</span><br><span class="line">root@72abfcc9e2e9:/# cat /data/file.txt</span><br><span class="line">hello world</span><br><span class="line">root@72abfcc9e2e9:/# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<h3 id="3-3-备份与恢复"><a href="#3-3-备份与恢复" class="headerlink" title="3.3 备份与恢复"></a>3.3 备份与恢复</h3><p><strong>数据卷容器</strong>的备份与恢复并不是<strong>容器</strong>的备份与恢复，实质上是<strong>数据</strong>的备份与恢复。</p>
<blockquote>
<p>这句话你品，你细品！</p>
</blockquote>
<h4 id="3-3-1-备份"><a href="#3-3-1-备份" class="headerlink" title="3.3.1 备份"></a>3.3.1 备份</h4><p>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --volumes-from [数据卷容器id或者name] -v [宿主机存放备份文件的目录]:[容器内存放备份文件目录] [镜像] tar cvf [备份文件路径] [要备份的目录]</span><br></pre></td></tr></table></figure>

<p>我们执行示例命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --volumes-from data -v /Users/ethanyan/dockerdata/:/backup nginx tar cvf /backup/backup.tar /data</span><br><span class="line">tar: Removing leading `/' from member names</span><br><span class="line">/data/</span><br><span class="line">/data/file.txt</span><br></pre></td></tr></table></figure>

<p>该命令是加载数据卷容器并将容器内的 <code>/data</code> 目录打包，然后把压缩包保存到 映射到容器内 的新数据卷，本地目录为 <code>/Users/ethanyan/dockerdata/</code> 。执行完后，会在本地该目录出现压缩包 <code>backup.tar</code>。</p>
<p><strong>注意：</strong></p>
<p>1) 备份的命令执行完后会创建出一个临时容器，删除即可。重要的是压缩包。</p>
<blockquote>
<p>之所以会出现一个临时容器，是因为备份的原理是：创建一个新的容器挂载数据卷容器，而且此容器还与宿主机共享了一个目录（新数据卷），执行打包命令将数据卷容器内的数据打包保存到共享目录中，所以本地会出现一个压缩包。</p>
</blockquote>
<h4 id="3-3-2-恢复"><a href="#3-3-2-恢复" class="headerlink" title="3.3.2 恢复"></a>3.3.2 恢复</h4><p>请保存好备份的压缩包文件，恢复时用得到。</p>
<p><strong>步骤：</strong></p>
<p>1) 创建一个新的数据卷容器 <code>data_new</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker create -v /data/ --name data_new nginx</span><br></pre></td></tr></table></figure>

<p>2) 恢复之前的备份文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">docker run --volumes-from [新创建的数据卷容器id或者name] -v [宿主机存放备份文件的目录]:[容器内存放备份文件目录] [镜像] tar xvf [备份文件]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行示例命令</span></span><br><span class="line">docker run --volumes-from data_new -v /Users/ethanyan/dockerdata/:/backup nginx tar xvf /backup/backup.tar</span><br><span class="line">data/</span><br><span class="line">data/file.txt</span><br></pre></td></tr></table></figure>

<p>3) 为了验证是否恢复，我们可以新创建一个容器并挂载新的数据卷容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run  --volumes-from data_new -itd --name nginx_test6 nginx /bin/bash</span><br><span class="line"></span><br><span class="line">docker exec -it nginx_test6 /bin/bash</span><br><span class="line"></span><br><span class="line">root@2b54f0bfefbe:/# ls /data</span><br><span class="line">file.txt</span><br><span class="line">root@2b54f0bfefbe:/# cat /data/file.txt</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>可看到数据卷容器已经恢复。</p>
<h4 id="3-3-3-备份与恢复的原理"><a href="#3-3-3-备份与恢复的原理" class="headerlink" title="3.3.3 备份与恢复的原理"></a>3.3.3 备份与恢复的原理</h4><p>不管是备份还是恢复，我们都使用了一个中间介质，此介质便是一个容器。因为数据卷容器是不启动的，为了备份数据，我们就需要使用一个挂载了此数据卷容器的中间介质（容器）。此介质不光要能连接数据卷容器，还需要连接本地，因此我们又将本地的一个目录映射到了中间介质中。</p>
<p>备份就是中间介质将数据卷容器的目录打包后，再通过映射的目录共享给本地，所以本地会出现一个压缩包。容器列表多了一个新的容器，此容器便是中间介质。</p>
<p>恢复就是中间介质通过映射到容器的共享目录，读取到本地的备份文件（压缩包），然后在容器内部解压缩，数据就恢复到了挂载的数据卷容器中。</p>
<blockquote>
<p>当然，此中间介质也可以使用 <code>--name</code> 参数命名，便于删除。</p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器网桥连接</title>
    <url>/docker%E5%AE%B9%E5%99%A8%E7%BD%91%E6%A1%A5%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<center>Author：闫玉良</center>
容器之间如何互相通讯？具体的命令有哪些？

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h1 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h1><p>网桥可以简单的理解为「局域网」，使加入网桥的容器之间可以互相通讯、暴露全部链接，同时与外界又保证了相对隔离的运行环境。</p>
<h2 id="1-创建网桥"><a href="#1-创建网桥" class="headerlink" title="1.创建网桥"></a>1.创建网桥</h2><p>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create --driver bridge [网桥名称]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数 <code>--driver bridge</code> 是默认配置，可写可不写</p>
</blockquote>
<h2 id="2-连接网桥"><a href="#2-连接网桥" class="headerlink" title="2.连接网桥"></a>2.连接网桥</h2><p>连接网桥分为两种方式，一种是在创建容器时链接网桥，一种是在容器运行时链接网桥。</p>
<p>1) 创建容器时：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker create --name [容器名称] --network [网桥名称] [镜像名称]</span><br></pre></td></tr></table></figure>
<p>2) 容器运行状态时：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network connect [网桥名称] [容器名称]</span><br></pre></td></tr></table></figure>
<h2 id="3-查看所有网桥"><a href="#3-查看所有网桥" class="headerlink" title="3.查看所有网桥"></a>3.查看所有网桥</h2><p>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure>
<h2 id="4-查看某网桥的配置信息"><a href="#4-查看某网桥的配置信息" class="headerlink" title="4.查看某网桥的配置信息"></a>4.查看某网桥的配置信息</h2><p>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network inspect [网桥id或者名称]</span><br></pre></td></tr></table></figure>
<h2 id="5-删除自定义网桥"><a href="#5-删除自定义网桥" class="headerlink" title="5.删除自定义网桥"></a>5.删除自定义网桥</h2><p>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network rm [网桥id或者名称]</span><br></pre></td></tr></table></figure>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker的一些小知识</title>
    <url>/docker%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>今天玩游戏的时候，突然想到了以前面试被问的一个小问题，特此记录，仅供参考</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-关于docker故障排除"><a href="#1-关于docker故障排除" class="headerlink" title="1.关于docker故障排除"></a>1.关于docker故障排除</h2><p>很久之前在 <code>XX航空</code> 的面试中，面试官曾问过一个问题，大体情况如下（具体描述因为时间关系已经记不清了）：</p>
<p><strong>面试官：当一个容器发生故障导致无法连接</strong>，你会如何操作？</p>
<h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><p><strong>傻小闫：</strong>重启 <code>docker服务</code> 或 <code>容器</code> ？？？</p>
<p><strong>面试官：</strong>说一下重启命令</p>
<p><strong>傻小闫：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启 docker</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启某容器</span></span><br><span class="line">docker restart 容器id或者容器name</span><br></pre></td></tr></table></figure>

<p><strong>面试官：</strong>如果 <code>docker</code> 命令不是通过 <code>systemctl</code> 管理的，怎么办？如果执行重启命令之后仍然无法重启呢？</p>
<p><strong>傻小闫：</strong>无论 <code>docker</code> 怎样进行安装，都会有相关重启命令吧？要是重启一次不管用，那就多重启两次！常言道：没有什么是重启解决不了的问题，如果有，就重启两次～</p>
<p><strong>面试官：</strong>傻小闫，<code>out</code>！</p>
<h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><p><strong>傻小闫：</strong>我会先查看 <code>docker</code> 的 <code>启停状态</code>，然后再排查该容器的相关信息，比如查看该容器的启停状态，查看该容器的 <code>日志</code> 以及 <code>进程</code> 相关信息，最后根据具体情况进行具体分析作出对应相关操作。</p>
<p><strong>面试官：</strong>那么写一下查看 <code>docker</code> 的 <code>启停状态</code> 相关命令，还有查看容器的 <code>日志</code> 以及 <code>进程</code> 的相关命令吧。</p>
<p><strong>傻小闫：</strong>好的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<p>上述命令会显示服务的运行状态以及一些简单的运行信息。接下来是查看所有容器的启停状态命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p>然后是查看容器在 <code>stdout/stderr</code> 的日志相关命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs 容器id或者容器名称</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定容器最后100行日志</span></span><br><span class="line">docker logs --tail=100 容器id或者容器名称</span><br></pre></td></tr></table></figure>

<p>如果容器运行正常，可以查看指定容器中运行的进程信息，进一步判断原因：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker top 容器id或者容器名称</span><br></pre></td></tr></table></figure>

<p>另外还有一个查看容器性能监控的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stats 容器id或者容器名称</span><br></pre></td></tr></table></figure>

<p>对了，最后再说一个查看容器配置信息和运行时状态的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id或者容器名称</span><br></pre></td></tr></table></figure>

<p><strong>面试官微微点头，进行下一轮的问题轰炸…</strong></p>
<h2 id="2-关于docker网络"><a href="#2-关于docker网络" class="headerlink" title="2.关于docker网络"></a>2.关于docker网络</h2><p>docker 中容器如何与外界进行通讯？当然是配置网络了，下面是最常用的一行命令，指定映射：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p [宿主机ip]:[宿主机端口]:[容器端口] --name [容器名字] [镜像名称]</span><br></pre></td></tr></table></figure>

<p>该命令会根据指定镜像创建一个容器，并指定容器的名称、宿主机映射到容器的地址和端口、容器对外绑定的端口。创建完成之后，宿主机就可以通过刚才宿主机指定的地址和端口访问容器指定的服务了（比如容器是一个 <code>nginx</code> ，我们将宿主机的 <code>192.168.0.33:1314</code> 映射到容器的 80 端口，宿主机访问 <code>192.168.0.33:1314</code> 即可访问 <code>nginx</code> 服务）。</p>
<blockquote>
<p>端口的范围：0 ～ 65535</p>
</blockquote>
<h3 id="2-1-网桥"><a href="#2-1-网桥" class="headerlink" title="2.1 网桥"></a>2.1 网桥</h3><p>宿主机与 <code>docker</code> 某容器之间可以进行通讯之后，那么容器之间该如何通讯呢？</p>
<p>1.仍然可以通过上面提到的方式，使用宿主机的地址和端口进行访问。但是这样做有一个弊端，那就是只能访问容器暴露出的端口所提供的服务，十分有限。（<strong>推荐指数：2颗星</strong>）</p>
<p>2.可以使用容器的 <code>ip</code> 进行访问，但是每次重启容器之后，地址的变化该如何是好？（<strong>推荐指数：1颗星</strong>）</p>
<p>3.通过 <code>link</code> 建立连接。首先这种方式官方不推荐，所以也没有选择的必要，大家简单了解即可。我们需要有一个容器A（其他容器想要访问该容器），有一个容器B（该容器要去访问容器A），容器B在创建（启动）时需要使用参数 <code>--link</code> 进行设置。然后进入容器B，直接通过参数 <code>link</code> 指定的名字去访问容器A即可。<strong>注意一点：不可反向操作！</strong>即容器A无法 <code>ping</code> 通容器B。（<strong>推荐指数：1颗星</strong>）</p>
<blockquote>
<p>而且此操作如果希望容器A重启后，容器B的链接仍然生效，还需要额外操作，修改配置文件，十分繁琐，不推荐。</p>
</blockquote>
<p>上述的手段都不推荐，那么直接引出今日主角登场『<strong>桥接网络</strong>』（<strong>推荐指数：5颗星</strong>）</p>
<p>首先需要创建一个网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create 网络名称</span><br></pre></td></tr></table></figure>

<p>然后在启动容器时，使其加入网络中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --network 创建的网络名称 其他参数设置 镜像名称 ...</span><br></pre></td></tr></table></figure>

<p>我们简单来看一下官方提供了其他的什么参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --help</span><br><span class="line">      ...</span><br><span class="line">      --network network                Connect a container to a network</span><br><span class="line">      --network-alias list             Add network-scoped alias for the container</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<p>可以看到有两个参数，按照官方描述，一个参数负责将容器链接到给定的网桥上，一个参数是为该容器添加一个网络访问的别名。</p>
<p><strong>将需要通讯的容器在创建（启动容器）时，通过参数设置都添加到同一网络桥接上即可完成容器之间的通讯。</strong></p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch的一些小知识点</title>
    <url>/elasticsearch%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>这个假期有多少人新添了一份职业「云监工」，又有多少人干起了小区保安的工作（统计着进出小区的车辆），还有一些人无聊到数火龙果的「黑芝麻」…… 实不相瞒，我也一样，只不过无聊之际，偶尔看看书。之前对于 elasticsearch 介绍过一些常用的 API ，今天再做一些额外的补充。</p>
<blockquote>
<p>「云监工」：网络流行词，来源于央视频直播武汉开建的防治传染病医院火神山医院的建设工地，网友们虽然不能到现场出把力，但也给自己加了一个身份：云监工，通过直播镜头去“监督”医院的建设进度。</p>
<p>小区保安工作：很多人在家无聊，自觉统计着出入小区人员车辆数量，以帮助监督是否有人在疫情期间四处乱逛。</p>
<p>数火龙果的籽：这个起源于网友晒出的图片，为一个火龙果所有的籽标上了序号。</p>
</blockquote>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-短语搜索"><a href="#1-短语搜索" class="headerlink" title="1.短语搜索"></a>1.短语搜索</h2><p>之前向大家介绍了模糊搜索 <code>match</code> ，现在又有了很多复杂的需求：确切的匹配若干个单词（同一字段的值中包含多个词）或者短语。这就用到了一个新的方法 <code>match_phrase</code>，官方示例如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match_phrase"</span> : &#123;</span><br><span class="line">            <span class="attr">"about"</span> : <span class="string">"rock climbing"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述语句查询 <code>about</code> 字段中同时包含 <code>rock</code> 和 <code>climbing</code>（并且是相邻的）的员工记录。<code>match_phrase</code> 方法也可以用于匹配<strong>短语(phrases)</strong></p>
<p>有一些新来的小伙伴，可能对于上面的表达不是十分清楚，下面详细介绍一下。<code>GET</code> 表示请求方式，<code>/megacorp/employee/_search</code> 表示访问路径 <code>PATH</code>，大括号中的内容即 <code>DSL</code> 语句。</p>
<h3 id="1-1-API-访问方式"><a href="#1-1-API-访问方式" class="headerlink" title="1.1 API 访问方式"></a>1.1 API 访问方式</h3><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p>与 <code>elasticsearch</code> 进行交互时，可以通过 <code>crul</code> 方式，与其他普通的 <code>HTTP</code> 请求相同：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X&lt;VERB&gt; '&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;' -d '&lt;BODY&gt;'</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>VERB</strong> 表示请求方式：<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>HEAD</code>, <code>DELETE</code></p>
<p><strong>PROTOCOL</strong> 表示访问协议，如 <code>HTTP</code> / <code>HTTPS</code> （只有在 <code>Elasticsearch</code> 前面有 <code>https</code> 代理的时候可用）</p>
<p><strong>HOST</strong> 表示 <code>Elasticsearch</code> 集群中的任何一个节点的主机名，如果是在本地的节点，那么就叫 <code>localhost</code></p>
<p><strong>PORT</strong> 表示 <code>Elasticsearch HTTP</code> 服务所在的端口，默认为 9200</p>
<p><strong>PATH</strong> 表示 <code>API</code> 路径，也就是示例中的 <code>/megacorp/employee/_search</code></p>
<p><strong>QUERY_STRING</strong> 表示一些可选的查询请求参数，例如 <code>?pretty</code> 参数使得返回 <code>JSON</code> 数据更加美观易读。</p>
<p><strong>BODY</strong> 一个 <code>JSON</code> 格式的请求主体（如果请求需要的话）</p>
</blockquote>
<h4 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h4><p>大家经常使用到的工具，通过输入请求 <code>url</code> 以及根据需要填写 <code>DSL</code> 语句做为请求体，进行访问。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>任何其他发送 <code>HTTP</code> 请求的方式</p>
<h2 id="2-搜索结果高亮"><a href="#2-搜索结果高亮" class="headerlink" title="2.搜索结果高亮"></a>2.搜索结果高亮</h2><p>故名思义，我们可以将搜索到的文档中匹配到的关键词进行高亮显示。它最大的作用就是醒目，让你一眼发现这个文档被匹配的原因。语句也很简单，只需要在之前的查询语句上增加 <code>highlight</code>参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"match_phrase"</span> : &#123;</span><br><span class="line">            <span class="string">"about"</span> : <span class="string">"rock climbing"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"highlight"</span>: &#123;</span><br><span class="line">        <span class="string">"fields"</span> : &#123;</span><br><span class="line">            <span class="string">"about"</span> : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们运行这个语句时，会命中与之前相同的结果，但是在返回结果中会有一个新的部分叫做 <code>highlight</code>，这里包含了来自<code>about</code>字段中的文本，并且用 <code>&lt;em&gt;&lt;/em&gt;</code>来标识匹配到的单词。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="string">"hits"</span>: &#123;</span><br><span class="line">      <span class="string">"total"</span>:      <span class="number">1</span>,</span><br><span class="line">      <span class="string">"max_score"</span>:  <span class="number">0.23013961</span>,</span><br><span class="line">      <span class="string">"hits"</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="string">"_score"</span>:         <span class="number">0.23013961</span>,</span><br><span class="line">            <span class="string">"_source"</span>: &#123;</span><br><span class="line">               <span class="string">"first_name"</span>:  <span class="string">"John"</span>,</span><br><span class="line">               <span class="string">"last_name"</span>:   <span class="string">"Smith"</span>,</span><br><span class="line">               <span class="string">"age"</span>:         <span class="number">25</span>,</span><br><span class="line">               <span class="string">"about"</span>:       <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">               <span class="string">"interests"</span>: [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"highlight"</span>: &#123;</span><br><span class="line">               <span class="string">"about"</span>: [</span><br><span class="line">                  <span class="string">"I love to go &lt;em&gt;rock&lt;/em&gt; &lt;em&gt;climbing&lt;/em&gt;"</span> &lt;<span class="number">1</span>&gt;</span><br><span class="line">               ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&lt;1&gt; 原有文本中高亮的片段</p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>git仓库上传了个无法点开的空文件夹是什么鬼？</title>
    <url>/git%E4%BB%93%E5%BA%93%E4%B8%8A%E4%BC%A0%E4%BA%86%E4%B8%AA%E6%97%A0%E6%B3%95%E7%82%B9%E5%BC%80%E7%9A%84%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 

<p>诡异之事年年有，只是今年有点多，在仓库上传到 GitHub 后，偶然在 GitHub 中瞄了一眼，我的天？这个图标不像文件夹啊？这个怎么点不开？git 上传正常啊？本地工作区和暂存区都是干净的了啊？</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>本地仓库提交后，<code>GitHub</code> 中某文件夹无法正常点击，内容无法显示。</p>
<h2 id="二、原因分析"><a href="#二、原因分析" class="headerlink" title="二、原因分析"></a>二、原因分析</h2><p>经排查，定位到原因：之前仓库中包含了一个特殊的文件夹（此文件夹是另外一个 <code>git</code> 仓库），在执行下面语句时：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>提示仓库中包含其他仓库，需要解决此问题。本人操作是删除掉此文件夹中的 <code>.git</code> 配置目录，然后依次执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m 'add the new file'</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>顺利推送仓库到远程，过程中并无报错。这个过程或许是导致问题的原因。</p>
<h2 id="三、解决办法"><a href="#三、解决办法" class="headerlink" title="三、解决办法"></a>三、解决办法</h2><p>现在问题是本地工作区与暂存区干净如新，远程仓库有问题。该如何解决？这时用到了一个命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;dir_name&gt;</span><br></pre></td></tr></table></figure>

<p>我们先来看一下手册：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usage: git rm [&lt;options&gt;] [--] &lt;file&gt;...</span><br><span class="line"></span><br><span class="line">    -n, --dry-run         dry run</span><br><span class="line">    -q, --quiet           do not list removed files</span><br><span class="line">    --cached              only remove from the index</span><br><span class="line">    -f, --force           override the up-to-date check</span><br><span class="line">    -r                    allow recursive removal</span><br><span class="line">    --ignore-unmatch      exit with a zero status even if nothing matched</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>--cached</code> 的作用：将文件仅仅从索引中移除，翻译成人能看懂的话便是 「之前已经提交，现在将此目录释放掉，恢复到工作区，未被追踪的状态，即 <code>git add .</code> 命令之前的状态」</p>
<p>我们执行完此命令之后使用如下命令查看所有改变后的文件状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>发现出问题的目录已经变成了红色未被追踪的状态，此时将出问题的目录中所有包含 <code>git</code> 信息的文件和目录都删除，然后再依次执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m 'add the new file'</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>去远程仓库中查看后发现问题解决。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>当出现未知问题致使远程仓库同预期结果不一致时，本地可以将问题目录恢复到未被追踪状态，核查完问题之后再次提交最新结果，操作步骤如下：</p>
<p>1.删除缓存，释放目录，恢复到未被追踪状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;dir_name&gt;</span><br></pre></td></tr></table></figure>

<p>2.依次执行如下操作再次提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m 'Information you need to submit'</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>3.完美解决问题。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo命令速查小册</title>
    <url>/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
最近都在搭建自己的博客，不断的调整显示效果，以及添加一些初始功能，总算大体框架完成，细枝末节尚待商榷。小闫同学的博客地址为  http://www.pythonnote.cn/  ，希望大家多多捧场 ~ 当然也希望大家多多关注公众号『全栈技术精选』

<p>先来几张效果图压场，deng ~ deng ~ dengdeng</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/blog1.png" alt></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/blog2.png" alt></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/blog3.png" alt></p>
<p>前端超牛逼的效果有没有感动到 ~ 这当然不是我自己做的，还要感谢 Jonathan Klughertz</p>
<p>如果认为这篇文章要教如何搭建个人博客，那就让你失望了，因为百度上面相关教程太多太多，我不认为自己写的比其他人更详细更好。只是给大家指引一下方向即可。</p>
<p>搭建博客的过程中使用到了框架 Node.js、HEXO 以及 GitHub 。</p>
<p>下面就经常使用到的 hexo 的命令做一个总结，方便在使用过程中快速查阅。</p>
<h4 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo n "article name"</span><br><span class="line">或者</span><br><span class="line">hexo new "article name"</span><br></pre></td></tr></table></figure>

<h4 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>其实上述为 3 个命令，为了节省时间，我经常联合使用。</p>
<blockquote>
<p>hexo clean 清除缓存</p>
<p>hexo g 生成静态页面（generate）</p>
<p>hexo d 部署（deploy）</p>
</blockquote>
<h4 id="本地效果预览"><a href="#本地效果预览" class="headerlink" title="本地效果预览"></a>本地效果预览</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<blockquote>
<p>s 为 server 的简写，因此你也可以写成 hexo server。hexo 的命令大多都是如此</p>
</blockquote>
<h4 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h4><p>首页会根据分页效果展示文章，如果不设置摘要，文章会拉长页面篇幅。</p>
<p>我们只需要在文章摘要后添加一行内容即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<p>最后效果图为：</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/blog4.png" alt></p>
<h4 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h4><p>先执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page "tags"</span><br></pre></td></tr></table></figure>

<p>再在目录 <code>source/tags/index.md</code> 中添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-05-27 13:47:40</span><br><span class="line">type: "tags"</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>最后只需要在写文章时添加 <code>tags</code> 属性即可。</p>
<p>如果只添加一个标签：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tags: test</span><br></pre></td></tr></table></figure>

<p>多标签，文章开头添加：（yaml语法）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line">- test1</span><br><span class="line">- test2</span><br><span class="line">- test3</span><br></pre></td></tr></table></figure>

<h4 id="添加文章分类目录"><a href="#添加文章分类目录" class="headerlink" title="添加文章分类目录"></a>添加文章分类目录</h4><p>添加分类如同标签一样，只需要将 <code>tags</code> 换成 <code>categories</code> 即可，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page "categories"</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>如下形式，同篇文章添加多个目录和标签：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">数据结构</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">数据结构</span></span><br></pre></td></tr></table></figure>

<p><strong>同篇文章添加多个目录和标签时，请将与其他文章共同的目录放置在前面，优先级高一些。</strong>比如，文章A归为目录算法和机器学习下，文章B归为目录算法和数据结构下。他们在划分目录时，需如下填写：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章A</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">机器学习</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章B</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">数据结构</span></span><br></pre></td></tr></table></figure>

<p>如果先写各自不同的目录，再写共同目录时，会在前端目录展示页面中出现重复目录。因为框架在创建目录时，会按如下形式创建表示目录的文件夹，以上述例子示范：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">算法</span></span><br><span class="line"><span class="string">├──</span> <span class="string">机器学习</span></span><br><span class="line"><span class="string">└──</span> <span class="string">数据结构</span></span><br><span class="line"><span class="comment"># 框架会先创建一个算法的文件夹，然后在算法文件夹下创建两个其他文件夹，这样避免目录重复</span></span><br></pre></td></tr></table></figure>

<p>如果在目录填写时按如下情况：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章A</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">机器学习</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章B</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">数据结构</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br></pre></td></tr></table></figure>

<p>框架在生成目录时：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">机器学习</span></span><br><span class="line"><span class="string">└──</span> <span class="string">算法</span></span><br><span class="line"></span><br><span class="line"><span class="string">数据结构</span></span><br><span class="line"><span class="string">└──</span> <span class="string">算法</span></span><br><span class="line"><span class="comment"># 框架会先生成每篇文章中各自不同的目录，然后在其下创建算法目录，造成重复</span></span><br></pre></td></tr></table></figure>

<p>框架在生成目录时，会优先创建写在首位的目录，再创建写在后面为止的目录，所以在展示所有的目录时，会出现重复的两个 <code>算法</code> 目录。</p>
<h4 id="文章中插入图片"><a href="#文章中插入图片" class="headerlink" title="文章中插入图片"></a>文章中插入图片</h4><p>如果在 Markdown 中直接插图，再转成静态页面时，路径会找不到，导致图片无法正常显示。解决办法有很多，我最喜欢的便是利用 GitHub 新建一个放置图片的仓库（当然很多人使用七牛云也很方便），然后在文章中使用插入连接的方式插入图片即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">![](https://github.com/EthanYan6/pic/raw/master/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/blog1.png)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>连接地址利用以下步骤获取：打开GitHub图片仓库后，看到 Download 按钮，右键复制链接</p>
</blockquote>
<h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p>大家首先需要去腾讯云或者阿里云购买一个域名，然后备案，再通过解析绑定个人博客地址。百度教程超详细，不过多阐述</p>
<p>命令暂且总结到此，预知后事如何，且听下回分解 ~</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>js中带有参数的函数作为值传入后调用问题</title>
    <url>/js%E4%B8%AD%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%80%BC%E4%BC%A0%E5%85%A5%E5%90%8E%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>每天不是在写 <code>bug</code>，就是在解 <code>bug</code> 的路上~</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-无参数函数作为参数传入调用"><a href="#1-无参数函数作为参数传入调用" class="headerlink" title="1.无参数函数作为参数传入调用"></a>1.无参数函数作为参数传入调用</h2><p>当根据实际情况，函数需要作为参数传入时，一般采用如下方式直接调用即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fuc1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fuc2</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  a();</span><br><span class="line">&#125;</span><br><span class="line">fuc2(fuc1); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="2-有参数函数作为参数传入调用"><a href="#2-有参数函数作为参数传入调用" class="headerlink" title="2.有参数函数作为参数传入调用"></a>2.有参数函数作为参数传入调用</h2><p>一般的函数都有参数，那么这种情况又如何传参呢？可以使用如下方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fuc1</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(param);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fuc2</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  a(b);</span><br><span class="line">&#125;</span><br><span class="line">fuc2(fuc1, <span class="string">"欢迎关注微信公众号：全栈技术精选"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-有参数函数作为事件方法"><a href="#3-有参数函数作为事件方法" class="headerlink" title="3.有参数函数作为事件方法"></a>3.有参数函数作为事件方法</h2><p>现在要将传入的函数作为点击事件的处理程序，你一定想得是这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fuc1</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  alert(param);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"link1"</span>);</span><br><span class="line">link.onclick = fuc1(<span class="string">"我是小闫同学啊"</span>);</span><br></pre></td></tr></table></figure>

<p>但是不好意思，<strong>不需要点击，一刷新页面，直接调用函数</strong>，弹出窗口！</p>
<blockquote>
<p>因为在你写 fuc1(“我是小闫同学啊”) 时，默认就调用了此函数，都不需要点击。</p>
</blockquote>
<p>如何才能达到在点击时才弹出窗口呢？你需要这样做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请关注：全栈技术精选</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fuc1</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  alert(param);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">"link1"</span>);</span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fuc1(<span class="string">"我是小闫同学啊"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js动态绑定事件，无法使用for循环中变量i的问题</title>
    <url>/js%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%EF%BC%8C%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%8F%98%E9%87%8Fi%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>每天不是在写 <code>bug</code>，就是在解 <code>bug</code> 的路上~</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h2><p>在一个 <code>for</code> 循环中，我动态给一堆 <code>a</code> 标签绑定 <code>onclick</code> 事件时，发现点击事件不正确。如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"link"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; link.length; i++) &#123;</span><br><span class="line">  link[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我需要的是，点击第一个链接，弹出 0，点击第二个链接，弹出 1……以此类推。但是上述代码点击每一个链接总是弹出一个值，而且还是个不正常的值。之所以说它不正常，是因为上面我获取到了 5 个标签，正常下标应该到 4 结束，但是总是弹出 5 ？？？？</p>
<p>答：那是因为事件函数是一个匿名函数，此函数会在 <code>for</code> 循环执行之后调用。调用时，发现内部没有定义变量 <code>i</code> ，所以就去外面找一下，发现外层有，就取外层的值了，但是为什么是 5 呢？那是因为 <code>for</code> 循环的结束条件是 <code>i</code> 不满足 <code>i&lt;5</code> ，那么结束后变量 <code>i</code> 的值就是 5，匿名函数到外层取值正好取到了它。</p>
<h2 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h2><p>可以采用自定义属性的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"link"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; link.length; i++) &#123;</span><br><span class="line">  link[i].index = i;</span><br><span class="line">  link[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.index);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//微信公众号：全栈技术精选</span></span><br></pre></td></tr></table></figure>



<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql中保存并操作json对象</title>
    <url>/mysql%E4%B8%AD%E4%BF%9D%E5%AD%98%E5%B9%B6%E6%93%8D%E4%BD%9Cjson%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>对于最常使用的数据格式 <code>json</code> 而言，数据库 <code>mysql</code> 提供了保存及一系列操作方法供大家使用，下面我们就来学习一下吧。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h2><p>在 <code>mysql5.7</code> 版本之前， <code>json</code> 数据一般使用数据类型 <code>LONGBLOB</code> 或者 <code>LONGTEXT</code> 存储。后来大家「千呼万唤」官方才正式引入了数据类型 <code>JSON</code>。</p>
<h2 id="2-创建json类型字段"><a href="#2-创建json类型字段" class="headerlink" title="2.创建json类型字段"></a>2.创建json类型字段</h2><p>1) 创建一个测试数据库 <code>testdb</code></p>
<p>2) 切换到此数据库下</p>
<p>3) 创建一张表 <code>t1</code>，表中包含一个字段 <code>jsondoc</code> ，其字段类型为 <code>JSON</code></p>
<p>4) 查看表的构建信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database testdb;</span><br><span class="line">Query OK, 1 row affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; use testdb;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; create table t1 (jsondoc JSON);</span><br><span class="line">Query OK, 0 rows affected (0.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show create table t1;</span><br><span class="line">+<span class="comment">-------+----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Table | <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                         |</span><br><span class="line">+<span class="comment">-------+----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| t1    | <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line">  <span class="string">`jsondoc`</span> <span class="keyword">json</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci |</span><br><span class="line">+<span class="comment">-------+----------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<h2 id="3-增删改查"><a href="#3-增删改查" class="headerlink" title="3.增删改查"></a>3.增删改查</h2><h3 id="3-1-新增数据"><a href="#3-1-新增数据" class="headerlink" title="3.1 新增数据"></a>3.1 新增数据</h3><p>新增三条测试数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span></span><br><span class="line">    (<span class="string">'&#123;"name":"ethanyan","age":25&#125;'</span>),</span><br><span class="line">    (<span class="string">'&#123;"x": 17, "x": "red"&#125;'</span>),</span><br><span class="line">    (<span class="string">'&#123;"x": 17, "x": "red", "x": [3, 5, 7]&#125;'</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当我们插入的 <code>json</code> 中包含多个相同字段，表中只会保存最后一个值。可以看下方查询结果。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t1;</span><br><span class="line">+<span class="comment">---------------------------------+</span></span><br><span class="line">| jsondoc                         |</span><br><span class="line">+<span class="comment">---------------------------------+</span></span><br><span class="line">| &#123;"age": 25, "name": "ethanyan"&#125; |</span><br><span class="line">| &#123;"x": "red"&#125;                    |</span><br><span class="line">| &#123;"x": [3, 5, 7]&#125;                |</span><br><span class="line">+<span class="comment">---------------------------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>官方文档提示在 8.0.3 版本中有bug，上述同一 <code>json</code> 中相同字段情况，会保存第一个值。小闫使用的版本为8.0.19，此bug已修复，最终效果为保存最后一个值。（按书写的先后顺序确定）</p>
</blockquote>
<h3 id="3-2-修改数据"><a href="#3-2-修改数据" class="headerlink" title="3.2 修改数据"></a>3.2 修改数据</h3><h4 id="3-2-1-案例一"><a href="#3-2-1-案例一" class="headerlink" title="3.2.1 案例一"></a>3.2.1 案例一</h4><p>将数据 <code>{&quot;x&quot;: &quot;red&quot;}</code> 修改为 <code>{&quot;name&quot;: &quot;hanhan&quot;, &quot;age&quot;: 12}</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> t1 </span><br><span class="line">    <span class="keyword">set</span> jsondoc=<span class="string">'&#123;"name": "hanhan", "age": 12&#125;'</span> </span><br><span class="line">    <span class="keyword">where</span> json_extract(jsondoc,<span class="string">"$.x"</span>)=<span class="string">"red"</span>;</span><br></pre></td></tr></table></figure>

<p>1） <code>json_extract()</code> 函数可以根据 <code>JSON Path Syntax</code> 提取<code>json</code> 字符串中所需的键值。第一个参数 <code>jsondoc</code> 为 <code>json</code> 字符串（此处为字段名）；第二个参数 <code>$.x</code> 是  <code>JSON Path Syntax</code> （此处的意思为提取键 <code>x</code> 的值）。</p>
<p>2) 整体解读：将表 <code>t1</code>  满足条件的记录中，字段 <code>jsondoc</code> 的值更改为 <code>{&quot;name&quot;: &quot;hanhan&quot;, &quot;age&quot;: 12}</code>。条件：提取 <code>json_doc</code> 中 <code>x</code> 值等于 <code>red</code> 的记录。</p>
<h4 id="3-2-2-案例二"><a href="#3-2-2-案例二" class="headerlink" title="3.2.2 案例二"></a>3.2.2 案例二</h4><p>将数据 <code>{&quot;x&quot;: [3, 5, 7]}</code> 修改为 <code>{&quot;name&quot;: &quot;rose&quot;, &quot;age&quot;: 18}</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> t1 </span><br><span class="line">    <span class="keyword">set</span> jsondoc=<span class="string">'&#123;"name": "rose", "age": 18&#125;'</span> </span><br><span class="line">    <span class="keyword">where</span> json_extract(jsondoc,<span class="string">"$.x[0]"</span>)=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出使用的函数、语法与案例一中大致相同，不同的是  <code>JSON Path Syntax</code>。</p>
<p>1) 如果 <code>json</code> 字符串中某一键值为数组，我们可以通过下标索引 <code>[n]</code> 的方式提取元素。</p>
<blockquote>
<p><code>n</code> 为下标</p>
</blockquote>
<p>2) 整体解读：将表 <code>t1</code>  满足条件的记录中，字段 <code>jsondoc</code> 的值更改为 <code>{&quot;name&quot;: &quot;rose&quot;, &quot;age&quot;: 18}</code>。条件：提取 <code>json_doc</code> 中 <code>x</code> 所指向数组下标为0的元素值等于3的记录。</p>
<h3 id="3-3-查询数据"><a href="#3-3-查询数据" class="headerlink" title="3.3 查询数据"></a>3.3 查询数据</h3><h4 id="3-3-1-查询全部"><a href="#3-3-1-查询全部" class="headerlink" title="3.3.1 查询全部"></a>3.3.1 查询全部</h4><p>我们可以查询全部数据，看上述操作是否已经修改数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t1;</span><br><span class="line">+<span class="comment">---------------------------------+</span></span><br><span class="line">| jsondoc                         |</span><br><span class="line">+<span class="comment">---------------------------------+</span></span><br><span class="line">| &#123;"age": 25, "name": "ethanyan"&#125; |</span><br><span class="line">| &#123;"age": 12, "name": "hanhan"&#125;   |</span><br><span class="line">| &#123;"age": 18, "name": "rose"&#125;     |</span><br><span class="line">+<span class="comment">---------------------------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-查询json中键值对"><a href="#3-3-2-查询json中键值对" class="headerlink" title="3.3.2 查询json中键值对"></a>3.3.2 查询json中键值对</h4><p>需求：查询表中字段 <code>jsondoc</code> 中 <code>name</code> 的值。</p>
<p><strong>方式一：</strong> 使用操作符 <code>-&gt;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select jsondoc-&gt;"$.name" from t1;</span><br><span class="line">+<span class="comment">-------------------+</span></span><br><span class="line">| jsondoc-&gt;"$.name" |</span><br><span class="line">+<span class="comment">-------------------+</span></span><br><span class="line">| "ethanyan"        |</span><br><span class="line">| "hanhan"          |</span><br><span class="line">| "rose"            |</span><br><span class="line">+<span class="comment">-------------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p><strong>方式二：</strong>使用操作符 <code>-&gt;&gt;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select jsondoc-&gt;&gt;"$.name" from t1;</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| jsondoc-&gt;&gt;"$.name" |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| ethanyan           |</span><br><span class="line">| hanhan             |</span><br><span class="line">| rose               |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p><strong>方式三：</strong>使用函数 <code>json_extract()</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select json_extract(jsondoc,'$.name') from t1;</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| json_extract(jsondoc,'$.name') |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| "ethanyan"                     |</span><br><span class="line">| "hanhan"                       |</span><br><span class="line">| "rose"                         |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>1) 可以看出方式一与方式三效果完全一致，方式二结果中没有双引号</p>
<p>2) 操作符 <code>-&gt;</code> 和 <code>-&gt;&gt;</code> 的左侧为字段名，右侧为  <code>JSON Path Syntax</code> </p>
<h3 id="3-4-删除数据"><a href="#3-4-删除数据" class="headerlink" title="3.4 删除数据"></a>3.4 删除数据</h3><p>最后我们删除一条记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> json_extract(jsondoc,<span class="string">"$.name"</span>)=<span class="string">"rose"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-有关函数"><a href="#4-有关函数" class="headerlink" title="4.有关函数"></a>4.有关函数</h2><p>大家应该发现增删改查其实最大的不同在于：有很多函数的使用。除了函数 <code>json_extract()</code> 外，还有哪些呢？一起来看看。</p>
<h3 id="4-1-JSON-TYPE"><a href="#4-1-JSON-TYPE" class="headerlink" title="4.1 JSON_TYPE"></a>4.1 JSON_TYPE</h3><p><code>JSON_TYPE</code>函数需要一个 <code>JSON</code> 参数，并尝试将其解析为 <code>JSON</code> 值。如果有效，则返回值的 <code>JSON</code> 类型，否则返回错误。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select json_type('&#123;"name":"ethanyan"&#125;');</span><br><span class="line">+<span class="comment">----------------------------------+</span></span><br><span class="line">| json_type('&#123;"name":"ethanyan"&#125;') |</span><br><span class="line">+<span class="comment">----------------------------------+</span></span><br><span class="line">| OBJECT                           |</span><br><span class="line">+<span class="comment">----------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> json_type(<span class="string">'[1,"2"]'</span>);</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| json_type('[1,"2"]') |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| ARRAY                |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> json_type(<span class="string">'"hello"'</span>);</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| json_type('"hello"') |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| STRING               |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> json_type(<span class="string">'hello world'</span>);</span><br><span class="line">ERROR 3141 (22032): Invalid JSON text in argument 1 to function json_type: "Invalid value." at position 0.</span><br></pre></td></tr></table></figure>

<h3 id="4-2-JSON-ARRAY"><a href="#4-2-JSON-ARRAY" class="headerlink" title="4.2 JSON_ARRAY"></a>4.2 JSON_ARRAY</h3><p>此函数会将给定的参数，生成一个数组。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select json_array('a',1,now());</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line">| json_array('a',1,now())                |</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line">| ["a", 1, "2020-03-21 11:50:11.000000"] |</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="4-3-JSON-OBJECT"><a href="#4-3-JSON-OBJECT" class="headerlink" title="4.3 JSON_OBJECT"></a>4.3 JSON_OBJECT</h3><p>此函数会将给定的参数，按照顺序组合为键值对，打包成 <code>json</code> 对象。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select json_object('name','ethanyan','age',20);</span><br><span class="line">+<span class="comment">-----------------------------------------+</span></span><br><span class="line">| json_object('name','ethanyan','age',20) |</span><br><span class="line">+<span class="comment">-----------------------------------------+</span></span><br><span class="line">| &#123;"age": 20, "name": "ethanyan"&#125;         |</span><br><span class="line">+<span class="comment">-----------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="4-4-JSON-MERGE-PRESERVE"><a href="#4-4-JSON-MERGE-PRESERVE" class="headerlink" title="4.4 JSON_MERGE_PRESERVE"></a>4.4 JSON_MERGE_PRESERVE</h3><p>该函数会将多个 <code>json</code> 对象进行合并。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select json_merge_preserve('[1,2]','&#123;"school":"Qinghua"&#125;');</span><br><span class="line">+<span class="comment">-----------------------------------------------------+</span></span><br><span class="line">| json_merge_preserve('[1,2]','&#123;"school":"Qinghua"&#125;') |</span><br><span class="line">+<span class="comment">-----------------------------------------------------+</span></span><br><span class="line">| [1, 2, &#123;"school": "Qinghua"&#125;]                       |</span><br><span class="line">+<span class="comment">-----------------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="4-5-JSON-MERGE-PATCH"><a href="#4-5-JSON-MERGE-PATCH" class="headerlink" title="4.5 JSON_MERGE_PATCH"></a>4.5 JSON_MERGE_PATCH</h3><p>该函数会将多个 <code>json</code> 对象合并，并去重。我们与函数 4.4 进行比对直观感受一下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select</span><br><span class="line">    -&gt;     json_merge_preserve('&#123;"a": 1, "b": 2&#125;', '&#123;"c": 3, "a": 4&#125;', '&#123;"c": 5, "d": 3&#125;') as preserve,</span><br><span class="line">    -&gt;     json_merge_patch('&#123;"a": 3, "b": 2&#125;', '&#123;"c": 3, "a": 4&#125;', '&#123;"c": 5, "d": 3&#125;') as patch\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">preserve: &#123;"a": [1, 4], "b": 2, "c": [3, 5], "d": 3&#125;</span><br><span class="line">   patch: &#123;"a": 4, "b": 2, "c": 5, "d": 3&#125;</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>


<h3 id="4-6-JSON-VALID"><a href="#4-6-JSON-VALID" class="headerlink" title="4.6 JSON_VALID"></a>4.6 JSON_VALID</h3><p>验证是否为有效的 <code>json</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select json_valid('&#123;"name":1&#125;');</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">| json_valid('&#123;"name":1&#125;') |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">|                        1 |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> json_valid(<span class="string">'null'</span>);</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| json_valid('null') |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">|                  1 |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> json_valid(<span class="string">'NULL'</span>);</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| json_valid('NULL') |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">|                  0 |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>json</code> 中如果为空，可以表示为 <code>&quot;&quot;</code> 或者 <code>null</code> 。请不要写 <code>NULL</code> 或者 <code>Null</code> ，虽然在 <code>sql</code> 语法中可以，但是此数据类型中不行。</p>
</blockquote>
<h3 id="4-7-JSON-SET"><a href="#4-7-JSON-SET" class="headerlink" title="4.7 JSON_SET"></a>4.7 JSON_SET</h3><p>此函数可以替换现有路径的值，并添加不存在的路径的值。</p>
<p>比如有一个变量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @j = <span class="string">'["a", &#123;"b": [true, false]&#125;, [10, 20]]'</span>;</span><br></pre></td></tr></table></figure>

<p>然后我们使用函数进行操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select json_set(@j, '$[1].b[0]', 1, '$[2][2]', 2);</span><br><span class="line">+<span class="comment">--------------------------------------------+</span></span><br><span class="line">| json_set(@j, '$[1].b[0]', 1, '$[2][2]', 2) |</span><br><span class="line">+<span class="comment">--------------------------------------------+</span></span><br><span class="line">| ["a", &#123;"b": [1, false]&#125;, [10, 20, 2]]      |</span><br><span class="line">+<span class="comment">--------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="4-8-JSON-INSERT"><a href="#4-8-JSON-INSERT" class="headerlink" title="4.8 JSON_INSERT"></a>4.8 JSON_INSERT</h3><p>添加一个新的键值对，不会更改已经存在的键值对。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select json_insert(@j, '$[1].b[0]', 1, '$[2][2]', 2);</span><br><span class="line">+<span class="comment">-----------------------------------------------+</span></span><br><span class="line">| json_insert(@j, '$[1].b[0]', 1, '$[2][2]', 2) |</span><br><span class="line">+<span class="comment">-----------------------------------------------+</span></span><br><span class="line">| ["a", &#123;"b": [true, false]&#125;, [10, 20, 2]]      |</span><br><span class="line">+<span class="comment">-----------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="4-9-JSON-REPLACE"><a href="#4-9-JSON-REPLACE" class="headerlink" title="4.9 JSON_REPLACE"></a>4.9 JSON_REPLACE</h3><p>替换已有的键值对，不会添加新的键值对。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select json_replace(@j, '$[1].b[0]', 1, '$[2][2]', 2);</span><br><span class="line">+<span class="comment">------------------------------------------------+</span></span><br><span class="line">| json_replace(@j, '$[1].b[0]', 1, '$[2][2]', 2) |</span><br><span class="line">+<span class="comment">------------------------------------------------+</span></span><br><span class="line">| ["a", &#123;"b": [1, false]&#125;, [10, 20]]             |</span><br><span class="line">+<span class="comment">------------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="4-10-JSON-REMOVE"><a href="#4-10-JSON-REMOVE" class="headerlink" title="4.10 JSON_REMOVE"></a>4.10 JSON_REMOVE</h3><p>接收 <code>JSON</code> 文档和一个或多个指定要从文档中删除的值的路径。返回值是原始文档减去该文档内存在的路径所选择的值。也就是删除指定键值对。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select json_remove(@j, '$[2]', '$[1].b[1]', '$[1].b[1]');</span><br><span class="line">+<span class="comment">---------------------------------------------------+</span></span><br><span class="line">| json_remove(@j, '$[2]', '$[1].b[1]', '$[1].b[1]') |</span><br><span class="line">+<span class="comment">---------------------------------------------------+</span></span><br><span class="line">| ["a", &#123;"b": [true]&#125;]                              |</span><br><span class="line">+<span class="comment">---------------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h2 id="5-注意"><a href="#5-注意" class="headerlink" title="5.注意"></a>5.注意</h2><p>1) 通过 <code>JSON_OBJECT</code> 转换的值字符集为 <code>utf8mb4</code>，<code>collation</code> 为 <code>utf8mb4_bin</code></p>
<p>2) <code>utf8mb4</code> 是现在最新版本 <code>mysql</code> 默认的编码格式。</p>
<p>3) 原来 <code>mysql</code> 支持的 <code>UTF-8</code> 编码最大字符长度为 3 字节，如果遇到 4 字节的宽字符就会插入异常了。最著名的错误便是 <code>Emoji</code>表情插入报错，还有很多不常用的汉字，以及任何新增的 <code>Unicode</code> 字符报错等等。</p>
<blockquote>
<p><code>Emoji</code> 是一种特殊的 <code>Unicode</code> 编码，常见于 <code>ios</code> 和 <code>android</code> 手机上</p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>python 字符串前面的那些特殊字符</title>
    <url>/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E9%9D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<center>Author：闫玉良</center>
对于 Python 的字符串大家并不陌生，引号引用即为字符串。那么字符串前面经常加的一些特殊字母就让初学者懵逼了，今天我们就来详细讲一下 ......

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-u"><a href="#1-u" class="headerlink" title="1.u"></a>1.u</h2><p>作为程序员，看到 <code>u</code> 字符，首先想到的便是 <code>Unicode</code> 这个单词。没错，它确实也代表此含义。目的是告知后面字符串采用 <code>Unicode</code> 编码格式，应用对象自然是容易出现问题的<strong>中文字符串</strong>。</p>
<p>有时我们存储完成后，再次取用发现格式不一致，或者显示乱码等问题，使用 <code>u</code> 便很好解决了。</p>
<h2 id="2-f"><a href="#2-f" class="headerlink" title="2.f"></a>2.f</h2><p>这个字符经常看到，不知你是否还注意到一个现象，那便是出现此字符的字符串，字符串中必定会有大括号。哈哈，忘记也没有关系，要不然我讲什么呢？</p>
<p>此字符代表的是在后面字符串中可以使用大括号（大括号中可以使用 <code>python</code> 表达式）。如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">f"testfile-<span class="subst">&#123;str(time.time()).replace(<span class="string">'.'</span>,<span class="string">''</span>)&#125;</span>.txt"</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">testfile<span class="number">-15728489624240513.</span>txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样我们在字符串中就可以随心所欲的使用任何表达式，不再通过 <code>+</code> 拼接各种字符串了。</p>
</blockquote>
<h2 id="3-r"><a href="#3-r" class="headerlink" title="3.r"></a>3.r</h2><p><code>r</code> 这个字符是否更眼熟了？没错，在学习正则表达式时，大家都见过。此字符含义与其相同，代表将字符串中各种特殊符号进行转义，字符串中内容 <code>所见即所得</code> 。比如 ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">r'你好：\n您的快递'</span></span><br></pre></td></tr></table></figure>

<p>其中的 <code>\n</code> 不再表示换行符，而是反斜杠加字母 <code>\n</code></p>
<h2 id="4-b"><a href="#4-b" class="headerlink" title="4.b"></a>4.b</h2><p>这个字符就更常见了，它表示 <code>bytes</code> 类型。它可以与字符串类型相互转换，使用 <code>encode</code> 与 <code>decode</code>。</p>
<h3 id="bytes-gt-string"><a href="#bytes-gt-string" class="headerlink" title="bytes -&gt; string"></a>bytes -&gt; string</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">by = <span class="string">b'test'</span></span><br><span class="line">by.decode(<span class="string">'utf8'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="string-gt-bytes"><a href="#string-gt-bytes" class="headerlink" title="string -&gt; bytes"></a>string -&gt; bytes</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">'test'</span></span><br><span class="line">str.encode(<span class="string">'utf8'</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>python导入导出pip环境中所有模块</title>
    <url>/python%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BApip%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%89%80%E6%9C%89%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
刚入职接手项目，python 环境如何搭建？项目依赖模块如何安装？备份环境时如何将所有 pip 安装的模块导出？请看下文

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>导出所有模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip freeze &gt;requirements.txt</span><br></pre></td></tr></table></figure>

<p>导入所有模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：执行此命令时<strong>需要联网</strong>，其原理还是依次对文件中每一个模块进行 <code>pip install</code></p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python的这些小知识你注意到了吗？</title>
    <url>/python%E7%9A%84%E8%BF%99%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86%E4%BD%A0%E6%B3%A8%E6%84%8F%E5%88%B0%E4%BA%86%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>本文将对一些小知识进行汇总，这些知识也许你用了 <code>python</code> 很久，但仍然没注意到。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-操作文件的-x-模式"><a href="#1-操作文件的-x-模式" class="headerlink" title="1.操作文件的 x 模式"></a>1.操作文件的 x 模式</h2><p>对文件进行操作的 <code>opend</code> 函数大家都很熟悉，但是你注意到它还有一种模式为 <code>x</code> 吗？</p>
<p>今天闲的无聊，翻了翻 <code>python</code> 的文档（小闫电脑保存的 <code>python</code> 文档为3.8.2版本），然后发现：不光有 <code>a</code> 、<code>w</code>、<code>b</code> 、<code>r</code> 、<code>+</code> 模式，竟然还有一种模式为 <code>x</code>，下面讲一下吧。</p>
<p>官方文档称：在 3.3 版本中，增加了 <code>x</code> 模式，它表示创建一个文件，如果文件已经存在，会报错 <code>FileExistsError</code> 。还需要注意一点，在 3.3 版本以后，曾经的 <code>IOError</code> 被别名为 <code>OSError</code>。</p>
<h2 id="2-协程库-asyncio"><a href="#2-协程库-asyncio" class="headerlink" title="2.协程库 asyncio"></a>2.协程库 asyncio</h2><p>之前常用第三方库 <code>greentlet</code> 和 <code>gevent</code> 来创建协程，后来在 3.4 版本后，<code>python</code> 自身引入了一个协程库 <code>asyncio</code> 。它用来实现异步 <code>I/O</code>。下面看一下示例代码： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main_one</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello ...'</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'... main_one!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main_two</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello ...'</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'... main_two!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 task 列表。ensure_future() 函数会返回 task 对象</span></span><br><span class="line">tasks = [asyncio.ensure_future(main_one()),asyncio.ensure_future(main_two())]</span><br><span class="line"><span class="comment"># 使用 get_event_loop() 方法创建一个事件循环</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 多个任务（即 task 列表）使用 wait() 方法执行</span></span><br><span class="line"><span class="comment"># 然后再调用 run_until_complete() 函数将协程注册到事件循环中</span></span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hello ...</span><br><span class="line">hello ...</span><br><span class="line"><span class="meta">... </span>main_one!</span><br><span class="line"><span class="meta">... </span>main_two!</span><br></pre></td></tr></table></figure>

<h2 id="3-装饰器-wraps"><a href="#3-装饰器-wraps" class="headerlink" title="3.装饰器 wraps"></a>3.装饰器 wraps</h2><p>模块 <code>functools</code> 中的 <code>wraps</code> ，会让使用了装饰器的函数伪装的更像原函数，也就是将原函数的属性赋值给使用了装饰器后的原函数。这句话可能比较难理解，我们先来回顾一下什么是装饰器？<strong>装饰器就是在不改变现有函数基础上，为函数增加功能的一个函数，它使用闭包来实现。闭包的规则为在函数内部定义了一个函数，内部函数使用了外部函数的变量，外部函数返回了内部函数的引用。</strong>有一点需要注意：虽然被装饰器装饰的函数仍然可以使用原名称调用，但是其实质上指向了装饰器的内函数。通过以下示例进行说明：</p>
<p>1) 先来一个普通的装饰器使用示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eg_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwds)</span>:</span></span><br><span class="line">        print(<span class="string">'我是装饰器啊...'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwds)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用定义的装饰器装饰函数</span></span><br><span class="line"><span class="meta">@eg_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">noname</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'我是示例函数噻...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">noname()</span><br><span class="line"><span class="comment"># 打印函数的 __name__ 属性</span></span><br><span class="line">print(noname.__name__)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">结果是：</span></span><br><span class="line"><span class="string">我是装饰器啊...</span></span><br><span class="line"><span class="string">我是示例函数噻...</span></span><br><span class="line"><span class="string">wrapper</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>可以看到函数 <code>noname()</code> 的属性 <code>__name__</code> 的值为 <code>wrapper</code> ，即函数 <code>noname()</code> 指向的是装饰器的内函数。</p>
<p>2) 接下来请出今天的主角 <code>wraps</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps  <span class="comment"># &lt;-- 导入模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eg_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)    # &lt;-- 使用装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwds)</span>:</span></span><br><span class="line">        print(<span class="string">'我是装饰器啊...'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwds)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用定义的装饰器装饰函数</span></span><br><span class="line"><span class="meta">@eg_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">noname</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'我是示例函数噻...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">noname()</span><br><span class="line"><span class="comment"># 打印函数的 __name__ 属性</span></span><br><span class="line">print(noname.__name__)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">结果是：</span></span><br><span class="line"><span class="string">我是装饰器啊...</span></span><br><span class="line"><span class="string">我是示例函数噻...</span></span><br><span class="line"><span class="string">noname</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>可以看到 <code>__name__</code> 属性的值被修改为函数 <code>noname</code> 自己。</p>
<p>也许大家会问这有什么用？很久很久以前，在一个 <code>Flask</code> 项目中曾经出现过一个 <code>bug</code> ：给视图函数添加了自定义的装饰器之后（该装饰器会验证用户是否登录），再用 <code>@app.route(&quot;/index&quot;)</code> 绑定路径，会报错「你添加路径的视图函数已经绑定了其他路径」。这是因为路径会绑定自定义装饰器的内函数，之前其他视图绑定的其实并不是视图本身，而是自定义装饰器的内函数，这次实质上也去绑定内函数，所以会报错。通过查看底层代码是因为 <code>Flask</code> 的路由地址根据属性 <code>__name__</code> 绑定视图名称。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>videos</title>
    <url>/videos/</url>
    <content><![CDATA[<center>小闫邀您观看</center>

<a id="more"></a>

<blockquote>
<p>以下内容均为个人录制，发表于微信公众号「全栈技术精选」与微信视频号「小闫同学啊」</p>
</blockquote>
<ul>
<li><a href="https://mp.weixin.qq.com/s/1IlcLNCa442kJ_mv-4TD4Q" target="_blank" rel="noopener">MacBook如何创建python虚拟环境</a></li>
<li><a href="https://mp.weixin.qq.com/s/z8x_0trtt-O-DiJYLSSNVw" target="_blank" rel="noopener">2分钟快速搭建个人专属网站</a></li>
</ul>
<center> > 扫描下方二维码关注微信公众号 < </center>

<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/Pythonnote.png" alt="全栈技术精选"></p>
]]></content>
      <categories>
        <category>website</category>
      </categories>
      <tags>
        <tag>website</tag>
      </tags>
  </entry>
  <entry>
    <title>redis延伸</title>
    <url>/redis%E5%BB%B6%E4%BC%B8/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>在掌握了 <code>redis</code> 常用的五种类型以及适用场景后，快来学习更多高级操作吧 ~</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-Redis-事务"><a href="#1-Redis-事务" class="headerlink" title="1.Redis 事务"></a>1.Redis 事务</h2><p><code>redis</code> 中有类似于事务的东西，保证事务执行时不被其他客户端发来的请求中断。但是和关系数据库并不相同。它的事务<strong>不支持回滚操作</strong>，因此在统一执行事务中所有命令时，即使有一条失败，之前执行过的命令仍然生效。</p>
<blockquote>
<p>事务执行过程：开启事务，进行相关操作（所有操作按顺序添加到队列中），执行。</p>
</blockquote>
<p>此处可能有人会问：既然不支持回滚，那么在事务执行的过程中，所处理的数据被其他人修改了，怎么办？<code>redis</code> 提供了一个监视器 <code>watch</code> 命令，它的执行过程如下：</p>
<p>1) 使用监视器监控一个变量</p>
<p>2) 使用 <code>multi</code> 开启事务</p>
<p>3) 向队列中添加一系列命令</p>
<p>4) 在使用 <code>exec</code> 统一执行队列中所有操作前，监视器会去查看监控的变量是否被更改过，如果有变化直接报错，没有则正常执行</p>
<p>看到上述执行过程后，会发现它类似于「乐观锁」</p>
<blockquote>
<p>单机支持事务，集群不支持。</p>
<p>可以使用命令 <code>info Replication</code> 查看所属角色（主 <code>Master</code> 从 <code>Slave</code> 信息）</p>
</blockquote>
<h3 id="1-1-相关命令"><a href="#1-1-相关命令" class="headerlink" title="1.1 相关命令"></a>1.1 相关命令</h3><p><code>multi</code> 开启事务</p>
<p><code>exec</code> 统一执行</p>
<p><code>watch</code> 监视器「乐观锁」</p>
<h3 id="1-2-模块化操作"><a href="#1-2-模块化操作" class="headerlink" title="1.2 模块化操作"></a>1.2 模块化操作</h3><p>我们在使用 <code>python</code> 第三方库操作 <code>redis</code> 时，一般通过 <code>pipeline</code> 管道进行接收命令，然后 <code>execute</code> 顺序执行管道中所有操作。</p>
<p><strong>优点：</strong>可以在客户端统一收集指令；会隐式的执行 <code>multi</code> 与 <code>exec</code> 命令。</p>
<h2 id="2-Redis-持久化"><a href="#2-Redis-持久化" class="headerlink" title="2.Redis 持久化"></a>2.Redis 持久化</h2><p><code>redis</code> 是内存型的数据库，为保证发生宕机时可以恢复数据，所以需要持久化。共有下方两种方式：</p>
<h3 id="2-1-RDB"><a href="#2-1-RDB" class="headerlink" title="2.1 RDB"></a>2.1 RDB</h3><p>快照持久化（把当前内存状态刷入硬盘）</p>
<p>1) 创建子进程执行，停顿时长（随着数据量的增大，创建子进程所耗费的时间会越来越长。比如使用了40G内存后，创建一个子进程可能耗费4s多，这4s数据库会处于停服状态）</p>
<p>2) 定期触发（默认开启）</p>
<p>3) 手动执行 <code>BGSAVE</code> 命令（<code>background save</code> 后台保存）时触发</p>
<p>4) 执行 <code>SHUTDOWN</code> 关闭数据库时触发</p>
<h3 id="2-2-AOF"><a href="#2-2-AOF" class="headerlink" title="2.2 AOF"></a>2.2 AOF</h3><p>追加文件的方式进行持久化</p>
<p>1) 保存的是操作指令</p>
<p>2) 默认关闭</p>
<p>3) 可以选择 <code>appendsync always</code> / <code>everysec</code> / <code>no</code> 三种方式，一般选择每秒记录一次</p>
<p>4) 占用磁盘一定量时会进行压缩，可手动开启配置项</p>
<p><strong>在实际使用时一般两种方式都开启。</strong></p>
<h2 id="3-Redis-复制集"><a href="#3-Redis-复制集" class="headerlink" title="3.Redis 复制集"></a>3.Redis 复制集</h2><p>为了在部分节点无法通讯时，保证服务仍然可用。</p>
<h3 id="3-1-设置方式"><a href="#3-1-设置方式" class="headerlink" title="3.1 设置方式"></a>3.1 设置方式</h3><p>1) 服务运行时执行命令 <code>slaveof</code></p>
<p>2) 服务启动前在 <code>redis.conf</code> 配置文件中填写以下代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-注意事项"><a href="#3-2-注意事项" class="headerlink" title="3.2 注意事项"></a>3.2 注意事项</h3><p>只能一主多从（不允许存在互为备份的两个 <code>master</code>），但是可以层级化，如下图所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">            master</span><br><span class="line">           /     \</span><br><span class="line">     slave1        slave2</span><br><span class="line">    /      \</span><br><span class="line">slave3   slave4       ......</span><br></pre></td></tr></table></figure>

<p>使用如下命令查看当前 <code>redis</code> 服务器所扮演角色：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">info Replication</span><br></pre></td></tr></table></figure>

<h2 id="4-Sentinel-哨兵"><a href="#4-Sentinel-哨兵" class="headerlink" title="4.Sentinel 哨兵"></a>4.Sentinel 哨兵</h2><p>1) 是一个独立的进程，安装之后默认存在，可以通过源码文件<code>sentinel.conf</code> 查看。</p>
<p>2) 哨兵独立于 <code>redis</code> 之外运行。</p>
<h3 id="4-1-作用"><a href="#4-1-作用" class="headerlink" title="4.1 作用"></a>4.1 作用</h3><p>看管 <code>redis</code> 主从角色关系，进行故障转移（<code>failover</code>） ，从而实现高可用。它的功能简单来说就是 <code>master</code> 死掉了，可以自动将 <code>slave</code> 上升为 <code>master</code> 。</p>
<h3 id="4-2-注意"><a href="#4-2-注意" class="headerlink" title="4.2 注意"></a>4.2 注意</h3><p>至少运行3个实例，因为决定 <code>redis</code> 是否挂掉需要选举，超过半数投票才可以使 <code>master</code> 客观下线。还会在哨兵中选举出一个 <code>leader</code> 去故障转移，在 <code>slave</code> 中选出哪台被上升为 <code>master</code></p>
<h2 id="5-redis-用途"><a href="#5-redis-用途" class="headerlink" title="5.redis 用途"></a>5.redis 用途</h2><p>1) 缓存</p>
<p>2) 持久存储：比如数据库的冗余字段存放到 <code>redis</code> 中</p>
<p>3) 队列：消息平台，比如 <code>celery</code> 的消息队列实现</p>
<p>4) 排行榜/计数器</p>
<p>5) 发布订阅</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>vim实现python函数跳转</title>
    <url>/vim%E5%AE%9E%E7%8E%B0python%E5%87%BD%E6%95%B0%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>网上很多帖子都是说通过 <code>ctags</code> 或者 <code>ExuberantCtags</code> 来实现函数跳转，如果你是 <code>C</code> 语言开发者，无可厚非，<code>Python</code> 怎么办？快来看下面操作吧！</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1.步骤"></a>1.步骤</h2><p>1.下载一个文件</p>
<p>2.使用下载的文件为项目生成 <code>tags</code> 文件（里面记录了所有函数、类等位置，做了对应关系）</p>
<p>3.将生成的 <code>tags</code> 文件让 <code>vim</code> 读取</p>
<p>4.使用快捷键跳转</p>
<h2 id="2-详细操作"><a href="#2-详细操作" class="headerlink" title="2.详细操作"></a>2.详细操作</h2><p>1.复制然后利用浏览器打开网址：<a href="http://svn.python.org/projects/python/trunk/Tools/scripts/ptags.py" target="_blank" rel="noopener">http://svn.python.org/projects/python/trunk/Tools/scripts/ptags.py</a></p>
<p>2.本地新建一个文件 <code>ptags.py</code> ，然后把打开网址后看到的内容拷贝进文件中。</p>
<p>3.然后使用如下命令生成 <code>tags</code> 文件：</p>
<p>3.1 为当前目录下所有 <code>python</code> 程序生成 <code>tags</code> 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ptags.py *.py</span><br></pre></td></tr></table></figure>

<p>3.2 为整个项目生成 <code>tags</code> 文件：1.进入项目根目录；2.执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find  . -name \*.py -print | xargs /xxx/xxx/ptags.py</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据 <code>ptags.py</code> 文件的位置填写绝对路径</p>
</blockquote>
<p><strong>备注</strong>：如果上述命令执行提示没有权限，不要着急使用 <code>sudo</code> ，大概率是你没有给新建的文件 <code>ptags.py</code> 赋予执行权限。<code>chmod 777 文件路径</code> 暴力赋予一下就好了</p>
<p>4.让 <code>vim</code> 找到路径。</p>
<p>4.1 打开配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.vimrc</span><br></pre></td></tr></table></figure>

<p>4.2 添加如下内容，然后保存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set tags+=tags</span><br></pre></td></tr></table></figure>

<p>4.3 在命令模式下输入如下命令，重新加载一下 <code>vim</code> 配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:source $MYVIMRC</span><br></pre></td></tr></table></figure>

<p>5.跳转方式：</p>
<p>5.1 移动光标到某函数名下，然后使用快捷键 <code>ctrl + ]</code></p>
<p>5.2 跳转回去：<code>ctrl + t</code></p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>一起来看看火爆的手机号码一键登录</title>
    <url>/%E4%B8%80%E8%B5%B7%E6%9D%A5%E7%9C%8B%E7%9C%8B%E7%81%AB%E7%88%86%E7%9A%84%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E4%B8%80%E9%94%AE%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>不知你是否发现：大批手机 <code>app</code> 登录页面，突然之间变成了一键登录。之前大火的 <code>通过手机号码获取短信验证码</code> 登录模式正悄悄退去。这神奇的操作是如何实现的呢？</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>之前所有的登录页面千篇一律为「手机号」「验证码」（暂且忽略账号密码以及第三方登录模式），这是因为想要验证「你就是你」，在手机号实名认证的时代，通过向号主本人发送验证码来验证登录是较为稳妥的方式，事实证明也的确如此。但是受网络延迟以及操作繁琐等影响，对于用户留存以及用户新增有着不小的挑战。</p>
<p>也许你会想 <code>APP</code> 直接读取手机号验证号主身份不就好了嘛？对不起，如果哪家公司公开窃取手机号，离监狱就是负距离。这时三家通讯公司瞄准了这一市场，开放了相关能力，即通过调用运营商的接口，判断用户输入的手机号与本机号码是否一致。但细细一想，用户还是需要填写手机号，如果运营商直接把手机号返回给我们，那该多棒啊！这么一来「一键登录」就诞生了。</p>
<blockquote>
<p>运营商是具备通过 <code>sim</code> 卡数据查询到手机号码的权限以及能力的。</p>
</blockquote>
<p>刚才说到三家运营商开放了相关接口，但是他们毕竟是竞争关系，彼此之间互不兼容，而且提供的优惠以及方式也是不同的。好比移动出了一款4G套餐100分钟500M；联通出了同价位套餐200分钟10G；电信一看不行，出了不限流量。作为用户的我们肯定会根据自身情况选择最合适的，但是一般也是只选其一。不要说你办了三家的卡，而且为了同时使用甚至买了三个手机，如果你是如此土豪，请收下我的膝盖。因此，对于我们应用，集成三家通讯商的 <code>SDK</code> 是不是有点不那么方便以及划算呢？第三方平台便应运而生，比如某蓝（因为他们公司至少有3个推广添加了我的微信，所以我印象颇深）。</p>
<h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><p>作为技术人员，其实最关心的还是实现方式。结合网上各个平台的调用方式，绘制了此图：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E5%B0%8F%E9%97%AB%E6%8F%AD%E7%A7%98%E4%B8%80%E9%94%AE%E7%99%BB%E5%BD%95.png" alt="小闫揭秘一键登录"></p>
<p>1) 用户打开 <code>app</code> 请求登录</p>
<p>2) 显示登录， <code>app</code> 通过内置的认证 <code>SDK</code> 向运营商获取手机号码</p>
<p>3) 获取成功时，为用户展示授权页面（就是是否一键登录）</p>
<p>4) 等待用户进行点击授权</p>
<p>5) 用户同意授权</p>
<p>6) <code>SKD</code> 得到授权之后，获取 <code>token</code> ，然后向 <code>app</code> 返回接口调用 <code>token</code></p>
<p>7) <code>app</code> 向 <code>app服务器</code> 传递获取到的 <code>token</code></p>
<p>8) <code>app服务器</code> 拿着客户端传过来的 <code>token</code> 请求 <code>认证服务器</code> 获取手机号码接口</p>
<p>9) <code>认证服务器</code> 返回手机号码给应用服务器</p>
<p>10) 登录成功</p>
<h2 id="3-后话"><a href="#3-后话" class="headerlink" title="3.后话"></a>3.后话</h2><p>虽然一键登录比短信验证码收取的费用便宜不了多少，但是其节省的时间以及简化的操作不止一点半点。对于注册时，更是省时省力，拉新超赞。</p>
<p>对了，还有一点你需要知道，那就是这一操作必须建立在拥有顺畅的网络基础之上。</p>
<blockquote>
<p>三大运营商提供的接口操作对网络要求各不相同，但都不支持 <code>WiFi</code> 无线网络，最好是 <code>4G</code> +</p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>手机号一键登录</category>
      </categories>
      <tags>
        <tag>手机号一键登录</tag>
      </tags>
  </entry>
  <entry>
    <title>vim操作有这一篇就足够了</title>
    <url>/vim%E6%93%8D%E4%BD%9C%E6%9C%89%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E8%B6%B3%E5%A4%9F%E4%BA%86/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p><code>vi/vim</code> 的重要性不言而喻，比如登录服务器操作。那么如何掌握呢？看这一篇足矣。</p>
<blockquote>
<p>因为小闫同学最近迷上了 <code>vim</code>，正在使用并打算以后也用其彻底替代 <code>Pycharm</code> 等编辑工具，所以才有了此文。</p>
</blockquote>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><code>vi/vim</code> 是 <code>Linux</code> 上内置的一款文本编辑器，就如同 <code>Windows</code> 上的笔记本工具一样。</p>
<p>要想使用它，先要了解它的三种模式：<strong>命令模式</strong>、<strong>输入模式</strong>、<strong>末行模式</strong>（也被称为底线命令模式 <code>Last line mode</code>）。命令模式可以操作一些快捷键，比如滚屏操作，定位操作等；输入模式就是编辑模式，可以自由的打字输入；末行模式可以输入一些命令，来达到预期效果。</p>
<p>使用 <code>vi/vim</code> 打开一个文件时，默认就是<strong>命令模式</strong>；在命令模式下输入 <code>i</code> 时，便进入了<strong>输入模式</strong>；在输入模式下按 <code>esc</code> 键时，又会返回命令模式。在命令模式下，按 <code>:</code> （也就是按<code>shift</code> + <code>;</code>）时，会看到光标在窗口底部，此时进入了<strong>末行模式</strong>，在 <code>:</code> 后便可以输入命令。</p>
<blockquote>
<p><code>vi</code> 是老版本文本编辑器，<code>vim</code> 现在成为了主流，他俩命令一样，只是 <code>vim</code> 扩展插件丰富，支持的功能更多而已。本文以常用的 <code>vim</code> 为例进行说明。</p>
</blockquote>
<h2 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h2><p>打开一个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim test.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输入上述命令会在当前目录下寻找并打开 <code>test.txt</code> 文件，如果没有，则在当前目录下新建一个 <code>test.txt</code> 文件。</p>
</blockquote>
<h3 id="2-1-命令模式"><a href="#2-1-命令模式" class="headerlink" title="2.1 命令模式"></a>2.1 命令模式</h3><blockquote>
<p>以下内容全为快捷键，直接按即可，不会有什么显示。</p>
<p>2.注意区分大小写。</p>
<p>3.打开文件默认进入的就是命令模式，输入模式或者末行模式下按 <code>esc</code> 键进入命令模式</p>
</blockquote>
<p>1) <strong>控制光标</strong>：<code>H</code>是左； <code>J</code> 是下；<code>K</code> 是上；<code>L</code> 是右。</p>
<blockquote>
<p>可以使用方向键 (←↓↑→)控制，但是通常不这么做，因为程序员的双手一般都放在字母区域，去按方向键，再回到字母区域所需时间太长。使用 <code>hjkl</code> ，标准打字姿势中右手完全可以操作，方便快捷。</p>
</blockquote>
<p>2) <strong>滚屏操作</strong>：需要与 <code>Ctrl</code> 键配合使用，向上滚动半屏是 <code>Ctrl + u</code> ，向下滚动半屏是 <code>Ctrl + d</code>。当然为了快速操作，还有滚动一屏：向上滚动一屏 <code>Ctrl + b</code> ，向下滚动一屏 <code>Ctrl + f</code>。</p>
<blockquote>
<p>为了记忆，滚动半屏可以看做是 <code>up/down</code> ，分别是 <code>u/d</code>；滚动全屏可以看做 <code>back/forword</code>，分别是 <code>b/f</code></p>
</blockquote>
<p>3) <strong>移动到行首或行尾</strong>：这个快捷键一定要记忆，超级方便。</p>
<p><code>0</code> ：它是数字0。可以快速移动光标到所在行的行首。</p>
<p><code>$</code> ：英文输入下，按 <code>shift</code> 和数字键 4 即可。可以快速移动光标到所在行行尾第一个不是非空字符下。</p>
<p><code>^</code> ：英文输入下，按 <code>shift</code> 和数字键 6 即可。可以快速移动光标到所在行，<strong>第一个非空字符</strong>处。因为敲代码时总有缩进，当然希望到这一行代码的第一个字母，而不是这一行行首的空格了。</p>
<p>4) <strong>其他移动光标的操作</strong>：</p>
<p><code>G</code> ：到文件最后一行。如果想要到指定的哪一行可以输入行号，再输入 <code>G</code> 。（注意：是大写的 <code>G</code>）比如到 67 行，输入 <code>67 + G</code></p>
<blockquote>
<p>到指定行是我最喜欢的功能。当然需要配合显示行号使用，显示行号会在末行模式处讲。</p>
</blockquote>
<p><code>gg</code> ：到文件第一行。</p>
<p><code>&gt;&gt;</code> ：文本向右移动</p>
<p><code>&lt;&lt;</code> ：文本左移</p>
<p>5) <strong>删除操作</strong>：</p>
<p><code>x</code> ：删除光标后一个字符</p>
<p><code>X</code> ：（大写）删除光标前一个字符</p>
<p><code>d</code> ：删除键</p>
<p><code>dd</code> ：删除光标所在行。如果想要删除指定多少行，先输入数字，再输入 <code>dd</code> 即可，比如删除往下的 37 行内容（包含光标所在行），输入 <code>37 dd</code> 。</p>
<p><code>d0</code> ：删除光标前所有内容</p>
<p><code>D</code> ：删除光标后所有内容</p>
<p><code>daw</code> ：删除光标所在单词（<strong>超级常用</strong>）</p>
<p>配合可视模式选中一些内容，再按 <code>d</code> 就可以删除这些内容了。</p>
<p>6) <strong>可视模式</strong>：<code>v</code> 按字符移动光标选择内容，<code>V</code> (大写) 按行上下移动选择内容。</p>
<p>7) <strong>撤销</strong>：<code>u</code> 撤销一步操作，<code>Ctrl + r</code> 反撤销。</p>
<p>8) <strong>复制粘贴</strong>：<code>y</code> 是复制，<code>p</code> 是粘贴。配合可视模式，选中内容后，按 <code>y</code> 即可复制，按 <code>p</code> 粘贴。<code>yy</code> 是复制光标所在行。</p>
<blockquote>
<p>注意：如果是复制一行内容，粘贴时会向下粘贴一行；如果是复制几个字符，会向光标后粘贴。<strong>只针对当前文件有效</strong>，也就是退出当前文件后，复制的内容不在了。</p>
</blockquote>
<p>9) <strong>重复操作</strong>：<code>.</code> 重复上一步操作</p>
<p>10) <strong>替换操作</strong>：</p>
<p>按 <code>r</code> 后再按要替换的字母。如将 <code>n</code> 替换为 <code>m</code> ：将光标移动到字母 <code>n</code> 下，然后按 <code>r</code> ，再按 <code>m</code> 即可。</p>
<p>按 <code>R</code> 后，再按要替换的字母，替换后，光标会移动到后一个字符，可以再次执行替换操作，不必一直按 <code>r</code>。</p>
<p>11) <strong>进入输入模式</strong>：</p>
<p><code>i</code>：插入光标前一个字符</p>
<p><code>a</code>：插入光标后一个字符</p>
<p><code>I</code>：插入行首</p>
<p><code>A</code>：插入行尾</p>
<p><code>o</code>：向下新开一行,插入行首</p>
<p><code>O</code>：（大写）向上新开一行,插入行首</p>
<h3 id="2-2-输入模式"><a href="#2-2-输入模式" class="headerlink" title="2.2 输入模式"></a>2.2 输入模式</h3><p>输入模式下，不能使用快捷键，可以正常打字或者使用方向键控制光标。按 <code>Esc</code> 键进入命令模式。</p>
<h3 id="2-3-末行模式"><a href="#2-3-末行模式" class="headerlink" title="2.3 末行模式"></a>2.3 末行模式</h3><p>在命令模式下，按 <code>:</code> 进入末行模式。退出末行模式按 <code>esc</code> 键，即可进入命令模式。</p>
<p>1) 显示行号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:set nu</span><br></pre></td></tr></table></figure>

<p>2) 查找</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:/要查找的内容</span><br></pre></td></tr></table></figure>

<p>按 <code>n</code> 查找下一个；按 <code>N</code> 查找上一个。</p>
<p>3) 高亮显示查找内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:set hlsearch</span><br></pre></td></tr></table></figure>

<p>4) 替换</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 末行模式下，将当前文件中的所有abc替换成123</span></span><br><span class="line">:%s/abc/123/g</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 末行模式下，将第一行至第10行之间的abc替换成123</span></span><br><span class="line">:1, 10s/abc/123/g</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.%表示整个文件；1, 10表示1到10行范围内</p>
<p>2.<code>s</code> 表示替换</p>
<p>3.<code>g</code> 表示全局</p>
</blockquote>
<p>5) 退出文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 保存并退出</span></span><br><span class="line">:wq</span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接退出</span></span><br><span class="line">:q</span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制退出</span></span><br><span class="line">:q!</span><br></pre></td></tr></table></figure>

<h2 id="3-总结的一些骚操作"><a href="#3-总结的一些骚操作" class="headerlink" title="3.总结的一些骚操作"></a>3.总结的一些骚操作</h2><p>1.要查找光标所在单词，直接按下面的快捷键：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也就是按 <code>shift</code> + 键盘字母区上方数字键8</p>
</blockquote>
<p>2.如何快速选中一个单词：先把光标移动到该单词下方，然后按 <code>b</code> 移动光标到单词首字母，按 <code>v</code> 进入可视模式，再按 <code>e</code> 选中当前单词，即 <code>bve</code>。选中之后就可以按 <code>y</code> 复制，或者按 <code>d</code> 删除了。</p>
<p>3.我想把内容复制后，其他文件也使用，就好像 <code>ctrl c</code> 那样。可以使用如下快捷键：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"+y</span><br></pre></td></tr></table></figure>

<p>先选中所有复制内容，然后按上述快捷键（注意<strong>上述快捷键是三个字符</strong>）即可复制到系统的剪切板中。</p>
<p>4.如果我想在新打开的文件中粘贴上一个文件中复制的内容呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"+p</span><br></pre></td></tr></table></figure>

<h2 id="4-插件"><a href="#4-插件" class="headerlink" title="4.插件"></a>4.插件</h2><p><code>vim</code> 优秀就优秀在它可以使用插件，然后打造出一款类似 <code>Pycharm</code> 的 <code>IDE</code> 工具。本文列举一些常用插件，具体安装对应 GitHub 上操作，自己 <code>google</code> 一下。</p>
<p><strong>插件管理工具</strong> ：<code>Vundle</code></p>
<p><strong>目录树</strong>：<code>NERDTree</code></p>
<p><strong>搜索文件</strong>：<code>CtrlP</code></p>
<p><strong>基于内容搜索文件</strong>：<code>ack</code></p>
<p><strong>python函数跳转功能</strong>：<code>ptags</code> 可以查看我的文章『<a href="https://www.pythonnote.cn/vim实现python函数跳转/">vim 实现 python 函数跳转</a>』</p>
<p><strong>代码折叠</strong>：这个不是插件，而是修改 <code>.vimrc</code> 配置文件，<code>Google</code> 一下</p>
<p><strong>代码补全</strong>：<code>YCM</code> (<code>YouCompleteMe</code>)</p>
<blockquote>
<p>暂时就想起这么多，以后再扩展吧。</p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>关系数据库之存储过程</title>
    <url>/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<center>Editor：闫玉良</center>

<p>很多人在上学期间，也许并未学习过关系数据库中「存储过程」的相关内容，但在工作上是绕不开的，那今天就来学习一下吧。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>无论是 <code>MySQL</code> 还是 <code>SQL Server</code> 数据库，最新版本都已支持『存储过程』。但是为了通用性，本文章以 <code>MySQL</code> 为例。</p>
<blockquote>
<p>因为 <code>SQL Server</code> 数据库为商业软件，所以其使用率较开源的 <code>MySQL</code> 来说要低一些。对于大数据处理来说， <code>MySQL</code> 更有优势，这就更使得很多中型、大型网站都使用 <code>MySQL</code> 。二者语法上也有些许差别，考虑到学习之后的应用情况，特选 <code>MySQL</code>。</p>
</blockquote>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>存储过程『<code>Stored Procedure</code>』是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象，即面向对象的思想。它通过编译后存储在数据库中，用户可以像调用函数一样通过特定的方式执行存储过程。</p>
<p>简单来讲，存储过程就是封装了一堆 <code>SQL</code> 语句，方便复用。如此直白，应该不会不理解了。</p>
<h3 id="1-1-优点"><a href="#1-1-优点" class="headerlink" title="1.1 优点"></a>1.1 优点</h3><p>1) 通过封装，隐藏执行的 <code>SQL</code> 语句，以及逻辑操作。</p>
<p>2) 可以像函数一样传递参数，并回传值。</p>
<h3 id="1-2-缺点"><a href="#1-2-缺点" class="headerlink" title="1.2 缺点"></a>1.2 缺点</h3><p>1) 存储过程根据数据库的不同而不同，<strong>移植性弱</strong>。比如切换不同厂商的数据库，由于编程语言的差别，需要重新编译。</p>
<p>2) 无法使用 <code>select</code> 指令来执行，它属于子程序，区别于用户定义的函数。</p>
<h2 id="2-创建和调用"><a href="#2-创建和调用" class="headerlink" title="2.创建和调用"></a>2.创建和调用</h2><p>1) 自定义结束符号。一般在 <code>mysql</code> 中，我们使用封号来结束语句，可以临时修改为其他符号：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将语句的结束符号从分号;临时改为两个$$或//(可以是自定义)</span></span><br><span class="line">DELIMITER $$</span><br><span class="line">或</span><br><span class="line">DELIMITER //</span><br></pre></td></tr></table></figure>

<p>2) 创建存储过程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称(参数...)</span><br></pre></td></tr></table></figure>

<p>3) 一个存储过程开始与结束符号</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> .... <span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>4) 创建存储函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 存储函数名称(参数)</span><br></pre></td></tr></table></figure>

<p>5) 调用存储过程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> 存储过程名称(参数);</span><br></pre></td></tr></table></figure>

<p>6) 存储过程体以 <code>begin</code> 开始，以 <code>end</code> 结束，当然，这是可以嵌套的。</p>
<blockquote>
<p>注意：每个嵌套块以及其中的每条语句，都必须以封号结尾，最外层（表示过程体结束的 <code>begin-end</code> 块不需要写）</p>
</blockquote>
<p>7) 为每一个语句块打标签，可以增强可读性，并不易丢掉过多嵌套块中的某个结尾。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">label1: <span class="keyword">BEGIN</span></span><br><span class="line">　　label2: <span class="keyword">BEGIN</span></span><br><span class="line">　　　　label3: <span class="keyword">BEGIN</span></span><br><span class="line">　　　　　　statements; </span><br><span class="line">　　　　<span class="keyword">END</span> label3 ;</span><br><span class="line">　　<span class="keyword">END</span> label2;</span><br><span class="line"><span class="keyword">END</span> label1</span><br></pre></td></tr></table></figure>

<h3 id="2-1-示例"><a href="#2-1-示例" class="headerlink" title="2.1 示例"></a>2.1 示例</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; delimiter $$　　-- 将语句的结束符号从分号;临时改为两个$$(可以是自定义)</span><br><span class="line">mysql&gt; CREATE PROCEDURE delete_matches(IN p_playerno INTEGER)</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; 　　DELETE FROM MATCHES</span><br><span class="line">    -&gt;    WHERE playerno = p_playerno;</span><br><span class="line">    -&gt; END$$</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; delimiter;　　-- 将语句的结束符号恢复为分号</span><br></pre></td></tr></table></figure>

<p>上面的存储过程解读：存储过程名为「<code>delete_matches</code>」；存储过程需要传入的参数为 <code>INTEGER</code> 类型的 <code>p_playerno</code> （球员编号）；由 <code>BEGIN</code> 表示过程体开始，执行的语句为删除 <code>MATCHES</code> 表中字段 <code>playerno</code> 的值等于传入参数值的记录。以 <code>END</code> 表示过程体结束。</p>
<p>调用这一存储过程时：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; call delete_matches(57);</span><br><span class="line">Query OK, 1 row affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<h2 id="3-参数"><a href="#3-参数" class="headerlink" title="3.参数"></a>3.参数</h2><p>从示例中我们可以看到传入参数表示为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> delete_matches(<span class="keyword">IN</span> p_playerno <span class="built_in">INTEGER</span>)</span><br></pre></td></tr></table></figure>

<p>已知参数名称与参数类型，那么括号中 <code>IN</code> 代表什么意思呢？</p>
<p>答： <code>IN</code> 代表传入参数，也就是调用存储过程时，向存储过程内传入值。</p>
<p>除此之外还有另外两个参数：<code>OUT</code> 和 <code>INOUT</code></p>
<p><code>OUT</code> ：传出参数，也就是存储过程向调用者传出值。类似于程序中的 <code>return</code></p>
<p><code>INOUT</code>：传入传出参数，比如传入一个值，存储过程中引用后再修改，向调用者传出新值。</p>
<p><strong>变量赋值：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @变量=值</span><br></pre></td></tr></table></figure>

<h3 id="3-1-in"><a href="#3-1-in" class="headerlink" title="3.1 in"></a>3.1 in</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; delimiter $$ -- 将语句的结束符号从分号;临时改为两个$$(可以是自定义)</span><br><span class="line">mysql&gt; create procedure in_param(in p_in int)</span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt; 　　select p_in; -- 查询传入的变量</span><br><span class="line">    -&gt; 　　set p_in=2; -- 重新设置变量</span><br><span class="line">    -&gt;    select P_in; -- 查询修改后的变量</span><br><span class="line">    -&gt; end$$</span><br><span class="line">mysql&gt; delimiter ;</span><br><span class="line"> </span><br><span class="line">mysql&gt; set @p_in=1; --设置全局变量</span><br><span class="line"> </span><br><span class="line">mysql&gt; call in_param(@p_in); -- 调用存储过程，传入设置的变量值</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| p_in |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    1 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line"> </span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| P_in |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    2 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line"> </span><br><span class="line">mysql&gt; select @p_in; -- 查询全局变量</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| @p_in |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|     1 |</span><br><span class="line">+<span class="comment">-------+</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上可以看出，<code>p_in</code> 在存储过程中被修改，但并不影响 <code>@p_in</code> 的值，因为前者为局部变量、后者为全局变量。</p>
</blockquote>
<h3 id="3-2-out"><a href="#3-2-out" class="headerlink" title="3.2 out"></a>3.2 out</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; delimiter //</span><br><span class="line">mysql&gt; create procedure out_param(out p_out int)</span><br><span class="line">    -&gt;   begin</span><br><span class="line">    -&gt;     select p_out;</span><br><span class="line">    -&gt;     set p_out=2;</span><br><span class="line">    -&gt;     select p_out;</span><br><span class="line">    -&gt;   end</span><br><span class="line">    -&gt; //</span><br><span class="line">mysql&gt; delimiter ;</span><br><span class="line"> </span><br><span class="line">mysql&gt; set @p_out=1;</span><br><span class="line"> </span><br><span class="line">mysql&gt; call out_param(@p_out);</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| p_out |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|  NULL |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line"><span class="comment">-- 因为out是向调用者输出参数，不接收输入的参数，所以存储过程里的p_out为null</span></span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| p_out |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|     2 |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line"> </span><br><span class="line">mysql&gt; select @p_out;</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| @p_out |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">|      2 |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line"><span class="comment">-- 调用了out_param存储过程，输出参数，改变了p_out变量的值</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-inout"><a href="#3-3-inout" class="headerlink" title="3.3 inout"></a>3.3 inout</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; delimiter $$</span><br><span class="line">mysql&gt; create procedure inout_param(inout p_inout int)</span><br><span class="line">    -&gt;   begin</span><br><span class="line">    -&gt;     select p_inout;</span><br><span class="line">    -&gt;     set p_inout=2;</span><br><span class="line">    -&gt;     select p_inout;</span><br><span class="line">    -&gt;   end</span><br><span class="line">    -&gt; $$</span><br><span class="line">mysql&gt; delimiter ;</span><br><span class="line"> </span><br><span class="line">mysql&gt; set @p_inout=1;</span><br><span class="line"> </span><br><span class="line">mysql&gt; call inout_param(@p_inout);</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| p_inout |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|       1 |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line"> </span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| p_inout |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|       2 |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line"> </span><br><span class="line">mysql&gt; select @p_inout;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| @p_inout |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|        2 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line"><span class="comment">-- 调用了inout_param存储过程，接受了输入的参数，也输出参数，改变了变量</span></span><br></pre></td></tr></table></figure>

<h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4.变量"></a>4.变量</h2><h3 id="4-1-变量声明"><a href="#4-1-变量声明" class="headerlink" title="4.1 变量声明"></a>4.1 变量声明</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> variable_name [,variable_name...] datatype [<span class="keyword">DEFAULT</span> <span class="keyword">value</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：局部变量声明一定要放置在存储过程体的开始。</p>
<p><code>datatype</code> 为 <code>MySQL</code> 的数据类型，如： <code>int</code>，<code>float</code>， <code>date</code>，<code>varchar(length)</code></p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> l_int <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">default</span> <span class="number">4000000</span>;  </span><br><span class="line"><span class="keyword">DECLARE</span> l_numeric <span class="built_in">number</span>(<span class="number">8</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="number">9.95</span>;  </span><br><span class="line"><span class="keyword">DECLARE</span> l_date <span class="built_in">date</span> <span class="keyword">DEFAULT</span> <span class="string">'1999-12-31'</span>;  </span><br><span class="line"><span class="keyword">DECLARE</span> l_datetime datetime <span class="keyword">DEFAULT</span> <span class="string">'1999-12-31 23:59:59'</span>;  </span><br><span class="line"><span class="keyword">DECLARE</span> l_varchar <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">'This will not be padded'</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>unsigned</code> 就是将数字类型无符号化</p>
</blockquote>
<h3 id="4-2-变量赋值"><a href="#4-2-变量赋值" class="headerlink" title="4.2 变量赋值"></a>4.2 变量赋值</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> 变量名 = 表达式值 [,variable_name = expression ...]</span><br></pre></td></tr></table></figure>

<h3 id="4-3-用户变量"><a href="#4-3-用户变量" class="headerlink" title="4.3 用户变量"></a>4.3 用户变量</h3><p>大家一定会有些迷惑，为什么有些变量是直接为变量名赋值，而有些变量则需要在变量名前加 <code>@</code> 呢？那是因为添加后，变为了用户变量名。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql &gt; SET @name='Ethan Yan';  </span><br><span class="line">mysql &gt; SELECT @name;  </span><br><span class="line">+<span class="comment">---------------------+  </span></span><br><span class="line">|      @name          |  </span><br><span class="line">+<span class="comment">---------------------+  </span></span><br><span class="line">|      Ethan Yan      |  </span><br><span class="line">+<span class="comment">---------------------+</span></span><br></pre></td></tr></table></figure>

<p>在存储过程中使用用户变量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql &gt; CREATE PROCEDURE GreetWorld( ) SELECT CONCAT(@greeting,' World');  </span><br><span class="line">mysql &gt; SET @greeting='Hello';  </span><br><span class="line">mysql &gt; CALL GreetWorld( );  </span><br><span class="line">+<span class="comment">----------------------------+  </span></span><br><span class="line">| CONCAT(@greeting,' World') |  </span><br><span class="line">+<span class="comment">----------------------------+  </span></span><br><span class="line">|  Hello World               |  </span><br><span class="line">+<span class="comment">----------------------------+</span></span><br></pre></td></tr></table></figure>

<h2 id="5-注释"><a href="#5-注释" class="headerlink" title="5.注释"></a>5.注释</h2><p>单行注视：<code>--</code></p>
<p>多行注视：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">此处为多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="6-常用操作"><a href="#6-常用操作" class="headerlink" title="6.常用操作"></a>6.常用操作</h2><h3 id="6-1-MySQL-存储过程的查询"><a href="#6-1-MySQL-存储过程的查询" class="headerlink" title="6.1 MySQL 存储过程的查询"></a>6.1 MySQL 存储过程的查询</h3><p>1) 查询数据库中的所有存储过程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> mysql.proc <span class="keyword">where</span> db=<span class="string">'数据库名'</span>;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> routine_name <span class="keyword">from</span> information_schema.routines <span class="keyword">where</span> routine_schema=<span class="string">'数据库名'</span>;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> <span class="keyword">status</span> <span class="keyword">where</span> db=<span class="string">'数据库名'</span>;</span><br></pre></td></tr></table></figure>

<p>2) 查询某个存储过程详细内容</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 数据库.存储过程名;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-MySQL-存储过程的修改"><a href="#6-2-MySQL-存储过程的修改" class="headerlink" title="6.2 MySQL 存储过程的修改"></a>6.2 MySQL 存储过程的修改</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">PROCEDURE</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-MySQL-存储过程的删除"><a href="#6-3-MySQL-存储过程的删除" class="headerlink" title="6.3 MySQL 存储过程的删除"></a>6.3 MySQL 存储过程的删除</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4-MySQL-存储过程的控制语句"><a href="#6-4-MySQL-存储过程的控制语句" class="headerlink" title="6.4 MySQL 存储过程的控制语句"></a>6.4 MySQL 存储过程的控制语句</h3><p>1) <strong>变量作用域：</strong>局部变量在存储过程内优先级高，当执行到 <code>END</code> 时，局部变量消失。如果不想消失，可以通过参数 <code>OUT</code> 将其传出给调用者。</p>
<p>2) <strong>条件语句1：</strong> <code>if-then-else</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">if ... then</span><br><span class="line">... ;</span><br><span class="line">else</span><br><span class="line">...;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br></pre></td></tr></table></figure>

<p>3) <strong>条件语句2：</strong> <code>case</code> </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql &gt; DELIMITER //  </span><br><span class="line">mysql &gt; CREATE PROCEDURE proc3 (in parameter int)  </span><br><span class="line">     -&gt; begin </span><br><span class="line">     -&gt; declare var int;  </span><br><span class="line">     -&gt; set var=parameter+1;  </span><br><span class="line">     -&gt; case var  </span><br><span class="line">     -&gt; when 0 then   </span><br><span class="line">     -&gt; insert into t values(17);  </span><br><span class="line">     -&gt; when 1 then   </span><br><span class="line">     -&gt; insert into t values(18);  </span><br><span class="line">     -&gt; else   </span><br><span class="line">     -&gt; insert into t values(19);  </span><br><span class="line">     -&gt; end case;  </span><br><span class="line">     -&gt; end;  </span><br><span class="line">     -&gt; //  </span><br><span class="line">mysql &gt; DELIMITER ; </span><br><span class="line">case</span><br><span class="line">    when var=0 then</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">30</span>);</span><br><span class="line">    when var&gt;0 then</span><br><span class="line">    when var&lt;0 then</span><br><span class="line">    else</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span></span><br></pre></td></tr></table></figure>

<p>4) 循环语句1 <code>while ···· end while</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">while 条件 <span class="keyword">do</span></span><br><span class="line">    <span class="comment">--循环体</span></span><br><span class="line">endwhile</span><br></pre></td></tr></table></figure>

<p>5) 循环语句2 <code>repeat···· end repea</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">repeat</span><br><span class="line">    <span class="comment">--循环体</span></span><br><span class="line">until 循环条件  </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br></pre></td></tr></table></figure>

<p>6) 循环语句3 <code>loop ·····endloop</code></p>
<p><code>loop</code> 循环不需要初始条件，这点和 <code>while</code> 循环相似，同时和 <code>repeat</code>循环一样不需要结束条件,<code>leave</code> 语句的意义是离开循环。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql &gt; DELIMITER //  </span><br><span class="line">mysql &gt; CREATE PROCEDURE proc6 ()  </span><br><span class="line">     -&gt; begin </span><br><span class="line">     -&gt; declare v int;  </span><br><span class="line">     -&gt; set v=0;  </span><br><span class="line">     -&gt; LOOP_LABLE:loop  </span><br><span class="line">     -&gt; insert into t values(v);  </span><br><span class="line">     -&gt; set v=v+1;  </span><br><span class="line">     -&gt; if v &gt;=5 then </span><br><span class="line">     -&gt; leave LOOP_LABLE;  </span><br><span class="line">     -&gt; end if;  </span><br><span class="line">     -&gt; end loop;  </span><br><span class="line">     -&gt; end;  </span><br><span class="line">     -&gt; //  </span><br><span class="line">mysql &gt; DELIMITER ;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>LABLES</code> 标号：标号可以用在<code>begin</code> <code>repeat</code> <code>while</code> 或者 <code>loop</code> 语句前，语句标号只能在合法的语句前面使用。可以跳出循环，使运行指令达到复合语句的最后一步。</p>
</blockquote>
<p>7) 迭代</p>
<p><code>ITERATE</code> 通过引用复合语句的标号，来从新开始复合语句：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql &gt; DELIMITER //  </span><br><span class="line">mysql &gt; CREATE PROCEDURE proc10 ()  </span><br><span class="line">     -&gt; begin </span><br><span class="line">     -&gt; declare v int;  </span><br><span class="line">     -&gt; set v=0;  </span><br><span class="line">     -&gt; LOOP_LABLE:loop  </span><br><span class="line">     -&gt; if v=3 then   </span><br><span class="line">     -&gt; set v=v+1;  </span><br><span class="line">     -&gt; ITERATE LOOP_LABLE;  </span><br><span class="line">     -&gt; end if;  </span><br><span class="line">     -&gt; insert into t values(v);  </span><br><span class="line">     -&gt; set v=v+1;  </span><br><span class="line">     -&gt; if v&gt;=5 then </span><br><span class="line">     -&gt; leave LOOP_LABLE;  </span><br><span class="line">     -&gt; end if;  </span><br><span class="line">     -&gt; end loop;  </span><br><span class="line">     -&gt; end;  </span><br><span class="line">     -&gt; //  </span><br><span class="line">mysql &gt; DELIMITER ;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考文章：</p>
<p><a href="https://www.cnblogs.com/geaozhang/p/6797357.html" target="_blank" rel="noopener">https://www.cnblogs.com/geaozhang/p/6797357.html</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_86fe5b440100wdyt.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_86fe5b440100wdyt.html</a></p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>关系数据库之视图</title>
    <url>/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>请问视图是什么？视图相关语句有哪些？视图在什么场景下使用？夺命三连</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>对于关系数据库来说，绕不开的一个概念便是『视图』，带着篇首的几个问题，我们来认真学习一下。</p>
<h2 id="视图是什么"><a href="#视图是什么" class="headerlink" title="视图是什么"></a>视图是什么</h2><p>官方文档中如此描述视图：A view is a stored SELECT statement（视图是存储的 <code>SELECT</code> 语句）。我们需要注意，<strong>视图实质上是一组查询语句，是一张虚拟表（可视化的表）而非真正的表</strong>。它将单张表或者多张表中的某些字段或全部字段使用一些特定的查询组合成一张可见的表，如同一张真实的表一样。</p>
<h2 id="视图相关语法"><a href="#视图相关语法" class="headerlink" title="视图相关语法"></a>视图相关语法</h2><h3 id="1-创建视图"><a href="#1-创建视图" class="headerlink" title="1. 创建视图"></a>1. 创建视图</h3><p>执行以下语句创建一个非常简单的视图，该视图执行 <code>SELECT</code> 语句，并将产品的名称和价格返回给用户。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vw_Names  </span><br><span class="line">   <span class="keyword">AS</span>  </span><br><span class="line">   <span class="keyword">SELECT</span> ProductName, Price <span class="keyword">FROM</span> Products;  </span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<h3 id="2-删除视图"><a href="#2-删除视图" class="headerlink" title="2. 删除视图"></a>2. 删除视图</h3><p>使用 <code>DROP</code> 语句删除视图 <code>vw_Names</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> vw_Names;  </span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<h3 id="3-查询视图"><a href="#3-查询视图" class="headerlink" title="3. 查询视图"></a>3. 查询视图</h3><p>如同查询表一样，可以做一些查询操作，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> vw_Names</span><br></pre></td></tr></table></figure>

<p>当然也可以添加一些条件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> vw_Names <span class="keyword">WHERE</span> ProductName=<span class="string">'武汉热干面'</span></span><br></pre></td></tr></table></figure>

<h3 id="4-更新视图"><a href="#4-更新视图" class="headerlink" title="4.更新视图"></a>4.更新视图</h3><p>使用 <code>SQL CREATE OR REPLACE VIEW</code> 语法来进行更新。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> 视图名称 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名称(s)</span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure>

<p><strong>注意：此处的更新实质上是更新视图的查询语句，看到的效果便是展示的数据发生了变化</strong></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>比如我们要在视图 <code>vw_Names</code> 中添加一个字段 <code>Counts</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vw_Names  </span><br><span class="line">   <span class="keyword">AS</span>  </span><br><span class="line">   <span class="keyword">SELECT</span> ProductName, Price, Counts <span class="keyword">FROM</span> Products;  </span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<h2 id="视图适用场景"><a href="#视图适用场景" class="headerlink" title="视图适用场景"></a>视图适用场景</h2><ol>
<li>因权限问题或者数据敏感，不能向外透露全部字段信息</li>
<li>查询逻辑复杂，再与其他表进行关联使得语句更复杂，使用视图后，可简单的将其理解为一个变量</li>
</ol>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>我们在使用视图的时候，相当于执行了视图中的查询语句。更直白的讲<strong>视图是实时更新的</strong>。</p>
<blockquote>
<p>每当用户查询视图时，数据库引擎通过使用 SQL 语句来重建数据。</p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>前端攻坚战</title>
    <url>/%E5%89%8D%E7%AB%AF%E6%94%BB%E5%9D%9A%E6%88%98/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
前端三大新框架：Angular.js、React.js、Vue.js。今天我们来磕这个最常用，影响极广的框架：Vue.js。

<p>Vue.js可以作为一个js库来使用，也可以用它全套的工具来构建系统界面，这些可以根据项目的需要灵活选择，所以说，Vue.js是一套构建用户界面的渐进式框架。</p>
<blockquote>
<p>Vue的核心库只关注视图层，Vue的目标是通过尽可能简单的 API 实现响应的数据绑定，在这一点上Vue.js类似于后台的模板语言。</p>
<p>Vue也可以将界面拆分成一个个的组件，通过组件来构建界面，然后用自动化工具来生成单页面(SPA - single page application)系统。</p>
</blockquote>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-快速上手"><a href="#1-快速上手" class="headerlink" title="1.快速上手"></a>1.快速上手</h2><p>还是从最基本的使用开始回顾。</p>
<p>第一步，需要实例化一个 Vue 对象，像下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;<span class="attr">message</span>:<span class="string">'hello world!'</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>html 页面中 id 为 app 的标签就可以通过模版语法接收到此消息：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>是不是很眼熟？没错，和我们 python 后端的模版语法一样，所以就不要抵触，开开心心使用吧。</p>
<p>当然，我们还可以在 Vue 实例化过程中定义方法，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;<span class="attr">message</span>: <span class="string">'hello world!'</span>&#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    fnChangeMsg:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.message = <span class="string">'hello Vue.js!'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们可以使用下面的页面感受它的 <code>响应式</code> ：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fnChangeMsg"</span>&gt;</span></span><br><span class="line">    点击即可改变数据</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面我们分析一下这个阶段发生了什么：</p>
<p>首先，当创建一个 Vue 实例时，它会把 data 对象中所有属性添加到 Vue 的响应式系统中。当这些属性的值发生变化，视图将会匹配到更新之后的值。上面的例子，通过一个方法，改变 data 对象中的属性，使视图中的值随之变化，演示了响应式。</p>
<h2 id="2-模版语法"><a href="#2-模版语法" class="headerlink" title="2.模版语法"></a>2.模版语法</h2><p>模版语法的作用就是获取数据，并在 HTML 页面中进行展示。</p>
<blockquote>
<p>所有 Vue.js的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。</p>
</blockquote>
<h3 id="2-1-插入值"><a href="#2-1-插入值" class="headerlink" title="2.1 插入值"></a>2.1 插入值</h3><p>1.最最常见的一种是胡子语法，即双大括号，也就是上面示例中的样式。除了可以获取值，大括号中还支持写表达式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? 'YES' : 'No' &#125;&#125;</span><br><span class="line">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>2.还有一种情况，标签的属性需要获取值，这时就不能再次使用胡子语法了，可以改写为 <code>v-bind</code> 指令：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span> <span class="attr">vbind:title</span>=<span class="string">"tip"</span>&gt;</span>小闫劝你多喝热水<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-指令"><a href="#2-2-指令" class="headerlink" title="2.2 指令"></a>2.2 指令</h3><p>Vue 中指令就是带有前缀 <code>v-</code> 前缀的特殊属性。</p>
<blockquote>
<p>指令属性的值预期是单个JavaScript表达式，指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM。</p>
</blockquote>
<p>常见的指令有 <code>v-bind</code>、<code>v-if</code>、<code>v-on</code> 和 <code>v-for</code>。下面举两个例子进行演示即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据 ok 的布尔值来插入/移除 &lt;p&gt; 元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line">  是否显示这一段</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 监听按钮的 click 事件来执行 fnChangeMsg 方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"fnChangeMsg"</span>&gt;</span></span><br><span class="line">  按钮</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-缩写"><a href="#2-3-缩写" class="headerlink" title="2.3 缩写"></a>2.3 缩写</h3><p>v-bind 和 v-on 事件这两个指令因为经常的使用，所以提供了简写的方式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整的语法形式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 完整的语法形式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"fnChangeMsg"</span>&gt;</span></span><br><span class="line">  按钮</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fnChangeMsg"</span>&gt;</span></span><br><span class="line">  按钮</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-Class-属性设置"><a href="#2-4-Class-属性设置" class="headerlink" title="2.4 Class 属性设置"></a>2.4 Class 属性设置</h3><p>设置元素的 class 属性可以使用 v-bind 指令。因为它们的属性值可以是表达式，vue.js在这一块做了增强。表达式结果除了是字符串之外，还可以是对象或者数组。</p>
<h4 id="2-4-1-对象的情况"><a href="#2-4-1-对象的情况" class="headerlink" title="2.4.1 对象的情况"></a>2.4.1 对象的情况</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static"</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123;active:isActive,'text-danger':hasError &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>data 的属性值是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  hasError: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终渲染的效果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static active"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以给 v-bind:class 传一个对象引用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>data 属性值可以写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: true,</span><br><span class="line">    &#39;text-danger&#39;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-数组的情况"><a href="#2-4-2-数组的情况" class="headerlink" title="2.4.2 数组的情况"></a>2.4.2 数组的情况</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[activeClass, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: 'active',</span><br><span class="line">  errorClass: 'text-danger'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终渲染为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"active text-danger"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你也想根据条件切换列表中的 class，可以用三元表达式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>即当 isActive 值为 ture 时，属性为 activeClass，否则属性值为 <code>&#39;&#39;</code></p>
<blockquote>
<p>Js 的三元表达式：<code>条件 ? 为真时的结果 : 为假时的结果</code></p>
</blockquote>
<h3 id="2-5-条件"><a href="#2-5-条件" class="headerlink" title="2.5 条件"></a>2.5 条件</h3><p>一般通过条件指令来控制元素是显示还是隐藏，是创建还是销毁。</p>
<p>虽然语法有些许陌生，但是永远逃不了 if 、else if 、else 这三个东西，所有语言都是如此。那么我们来分情况看一下这三种情况如何书写：</p>
<h4 id="2-5-1-v-if"><a href="#2-5-1-v-if" class="headerlink" title="2.5.1 v-if"></a>2.5.1 v-if</h4><p>v-if 可以控制元素的创建或者销毁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1 v-if&#x3D;&quot;ok&quot;&gt;Yes&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-v-else"><a href="#2-5-2-v-else" class="headerlink" title="2.5.2 v-else"></a>2.5.2 v-else</h4><p>v-else 指令来表示 v-if 的 <code>else 块</code>，v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-if&#x3D;&quot;Math.random() &gt; 0.5&quot;&gt;</span><br><span class="line">  Now you see me</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Now you don&#39;t</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-v-else-if"><a href="#2-5-3-v-else-if" class="headerlink" title="2.5.3 v-else-if"></a>2.5.3 v-else-if</h4><p>v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;A&#39;&quot;&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;B&#39;&quot;&gt;</span><br><span class="line">  B</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;C&#39;&quot;&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Not A&#x2F;B&#x2F;C</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-4-v-show"><a href="#2-5-4-v-show" class="headerlink" title="2.5.4 v-show"></a>2.5.4 v-show</h4><p>另一个用于根据条件展示元素的选项是 v-show 指令。用法和 v-if 大致一样，但是它不支持 v-else ,它和 v-if 的区别是，它制作元素样式的显示和隐藏，元素一直是存在的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1 v-show&#x3D;&quot;ok&quot;&gt;Hello!&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-列表循环"><a href="#2-6-列表循环" class="headerlink" title="2.6 列表循环"></a>2.6 列表循环</h3><p>数一数，常用的指令还有俩，那快解决吧。</p>
<p>一种常用的情况–列表渲染，即通过遍历数组或者对象，渲染到页面中。这时就需要用到一个指令 v-for。同样我们通过数组和对象两种情况进行演示：</p>
<h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">    &#123;&#123; item &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>vue对象创建如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [<span class="string">'foo'</span>,<span class="string">'bar'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果想加上索引值，可以加上第二个参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span>&gt;</span></span><br><span class="line">    &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h4><p>也可以用 v-for 通过一个对象的属性来迭代</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"v-for-object"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"value in object"</span>&gt;</span></span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果想加上对象属性名，可以加上第二个参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"v-for-object"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(value,key) in object"</span>&gt;</span></span><br><span class="line">    &#123;&#123; key &#125;&#125;-&#123;&#123; value &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-7-事件相关"><a href="#2-7-事件相关" class="headerlink" title="2.7 事件相关"></a>2.7 事件相关</h3><h4 id="2-7-1-事件绑定方法"><a href="#2-7-1-事件绑定方法" class="headerlink" title="2.7.1 事件绑定方法"></a>2.7.1 事件绑定方法</h4><p>可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。</p>
<p>事件的处理，简单的逻辑可以写在指令中，复杂的就需要在 vue 对象的 methods 属性中指定处理函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-1&quot;&gt;</span><br><span class="line">  &lt;!-- 在指令中写处理逻辑 --&gt;</span><br><span class="line">  &lt;button v-on:click&#x3D;&quot;counter +&#x3D; 1&quot;&gt;Add 1&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">......</span><br><span class="line">var example1 &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#example-1&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>methods 属性中指定处理函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-2&quot;&gt;</span><br><span class="line">  &lt;!-- greet 是在下面定义的方法名 --&gt;</span><br><span class="line">  &lt;button v-on:click&#x3D;&quot;greet&quot;&gt;Greet&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">var example2 &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#example-2&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: &#39;Vue.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 在 &#96;methods&#96; 对象中定义方法</span><br><span class="line">  methods: &#123;</span><br><span class="line">    greet: function () &#123;</span><br><span class="line">      &#x2F;&#x2F; &#96;this&#96; 在方法里指向当前 Vue 实例</span><br><span class="line">      alert(&#39;Hello &#39; + this.name + &#39;!&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-7-2-事件修饰符"><a href="#2-7-2-事件修饰符" class="headerlink" title="2.7.2 事件修饰符"></a>2.7.2 事件修饰符</h4><p>实际开发中，事件绑定有时候牵涉到阻止事件冒泡以及阻止默认行为，在 vue.js 可以加上事件修饰符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>分享一份全国行政区划sql数据库表</title>
    <url>/%E5%88%86%E4%BA%AB%E4%B8%80%E4%BB%BD%E5%85%A8%E5%9B%BD%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%88%92sql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>还在为寻找全国行政区划的数据而烦恼吗？还在因为一个 <code>Excel</code> 表格无法确定信息是否全面而惆怅吗？快来看看为你准备好的东西吧！</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>在软件开发的过程中，最基础最重要但是又最不容易寻找的一份数据便是「全国行政区划信息」。为了解决大家的烦恼，此处提供一份 <code>sql</code> 数据库文件，直接导入即可使用，省时省力，快来实践一下吧。</p>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><p>关系数据库（本人使用的数据库为 <code>MySQL8.0.19</code>）</p>
<h2 id="2-文件"><a href="#2-文件" class="headerlink" title="2.文件"></a>2.文件</h2><p>数据库文件为 <code>AREAS.sql</code>，数据条数为 3487 ，十分全面的涵盖了全国的省市县等信息。</p>
<blockquote>
<p> 此文件包括建表以及准备的数据</p>
</blockquote>
<p><strong>获取方式：</strong>关注公众号「全栈技术精选」，后台回复关键字「全国行政区划信息」即可获取。</p>
<h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h2><p>1) 先将获取到的文件 <code>AREAS.sql</code> 放到任意目录下（比如目录 <code>sqlfile</code> ），然后进入此目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd sqlfile</span><br></pre></td></tr></table></figure>

<p>2) 先进入数据库（以 <code>mysql</code> 为例）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>3) 创建数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> area;</span><br></pre></td></tr></table></figure>

<p>4) 使用此数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> area;</span><br></pre></td></tr></table></figure>

<p>5) 导入行政区划数据表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">source AREAS.sql;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-注意"><a href="#3-1-注意" class="headerlink" title="3.1 注意"></a>3.1 注意</h3><p>1) 获取到的数据库文件 <code>AREAS.sql</code> 为表结构以及表数据，因此需要先有一个数据库（此数据库可以新建或者使用已存在的数据库）</p>
<p>2) 导入数据库文件时，如果没有执行刚开始切换到 <code>AREAS.sql</code> 文件所在目录的步骤，可以通过写文件的绝对路径方式解决</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/%E5%9B%BE/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
此图非彼图，今天来学习一种十分重要，在生活中也经常使用的数据结构「图」

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="一、图"><a href="#一、图" class="headerlink" title="一、图"></a>一、图</h2><p>图就是由一些点与边组成，点之间是边，边两头有点，类似于我们所画的思维导图。根据点之间连接的边是否有具体指向区分为『有向图』和『无向图』。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9C%89%E5%90%91%E5%9B%BE.png" alt="图"></p>
<p>图可以做什么呢？它可以解决最经典的问题『寻找最短路径』。类似于地图，如想知道从别墅到公司走哪条路最短，可以通过图来建立模型，将十字路口（三叉路口等连接几条路的路口）看作是点，每条路就是边，别墅是起点，公司是终点。</p>
<p>上面只完成了第一步，有了图之后，该如何寻找最短路径呢？下面就需要再介绍一种图算法『广度优先搜索』</p>
<h2 id="二、广度优先搜索算法"><a href="#二、广度优先搜索算法" class="headerlink" title="二、广度优先搜索算法"></a>二、广度优先搜索算法</h2><p><strong>广度优先搜索算法</strong>可以通过一个例子进行描述：小明想通过走动，帮助儿子进入县一中（当地最好的学校）。于是他开始回忆自己的朋友是否有县一中的领导或者认识其领导，思考之后发现并没有，然后让朋友询问朋友的朋友是否有关系。像这样，为了在社交网络中寻找到关系，先看自己（自己肯定不是，要不然直接安排了），然后将所有朋友加入到搜索名单中，看朋友中是否有关系，如果没有，再将朋友的朋友纳入范围继续寻找 …… 直到找到需要的人，这就是广度优先搜索算法。</p>
<blockquote>
<p>因为同朋友的亲密度比同朋友的朋友之间的亲密度要高，所以先从朋友之间寻找。如果将朋友比做是第一层关系，朋友的朋友为第二层，这样一层一层下去的就是广度优先搜索。如果找到一个朋友，就寻找他的朋友中是否有这样的人，如此以深度挖掘的方式搜索下去，就是深度优先搜索。</p>
</blockquote>
<p>它常用于寻找两地点或者两样物体之间的最短距离。总结为下面两种问题：</p>
<ul>
<li>从一点可以到另一点吗？</li>
<li>从一点到另一点哪条路径最短？</li>
</ul>
<p>现实生活中的例子有：</p>
<ul>
<li>各种智能机器，比如跳棋最少走几步可以获胜</li>
<li>到目的地的最短路线</li>
</ul>
<p>在搜索的过程中，大家可能注意到，先检查朋友，后检查朋友的朋友，是有顺序的，那么如何保持顺序呢？那就需要使用到另外一种数据结构『队列』</p>
<h2 id="三、队列"><a href="#三、队列" class="headerlink" title="三、队列"></a>三、队列</h2><p>队列很简单，和生活中的排队一样，比如购票，结账时，先排队的人先买到票或者结账完成。就是有顺序，先进先出（<code>First In First Out</code>）的一种数据结构，它只有两种行为，入队和出队。类比生活中排队，有素质的人不能出现插队吧？</p>
<blockquote>
<p>队列常常与栈进行对比，栈是一种先进后出的数据结构，或描述为后进先出（<code>Last In First Out</code>）</p>
<p>深度优先搜索就常使用栈。</p>
</blockquote>
<h2 id="四、实现图"><a href="#四、实现图" class="headerlink" title="四、实现图"></a>四、实现图</h2><p>代码如何实现图呢？首先图由多个节点构成，每个节点与邻近节点相连，要表示这种关系，可以联想到『散列表』，其映射关系可以将键映射到一个值或多个值。在 <code>Python</code> 中则使用字典表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">"小明"</span>] = [<span class="string">"小花"</span>, <span class="string">"小玉"</span>, ...]</span><br><span class="line">graph[<span class="string">"小玉"</span>] = [<span class="string">"小帆"</span>, ...]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>散列表是无序的</p>
</blockquote>
<h2 id="五、实现图算法"><a href="#五、实现图算法" class="headerlink" title="五、实现图算法"></a>五、实现图算法</h2><p>还是沿用小明为儿子学校找关系的示例，实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该字典表示图，其中将小明与朋友，小明朋友与朋友的朋友之间的关系</span></span><br><span class="line">graph = &#123;......&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person_is_seller</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># 具体判断过程省略，该函数返回 true 或 false，即是或者不是</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个队列</span></span><br><span class="line">    search_queue = deque() </span><br><span class="line">    <span class="comment"># 为队列中不断添加朋友或者朋友的朋友，即要搜索的人</span></span><br><span class="line">    search_queue += graph[name] </span><br><span class="line">    <span class="comment"># 这个列表用于记录检查过的人</span></span><br><span class="line">    searched = []</span><br><span class="line">    <span class="comment"># 只要队列不为空就一直搜索下去</span></span><br><span class="line">    <span class="keyword">while</span> search_queue:</span><br><span class="line">        <span class="comment"># 取出队列中左面第一个人</span></span><br><span class="line">        person = search_queue.popleft() </span><br><span class="line">        <span class="comment"># 仅当这个人没检查过时才检查</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> person <span class="keyword">in</span> searched:</span><br><span class="line">            <span class="comment"># 看这个人是否是小明需要找的关系</span></span><br><span class="line">            <span class="keyword">if</span> person_is_seller(person):</span><br><span class="line">              	<span class="comment"># 是的话输出是要找的关系</span></span><br><span class="line">                print(person + <span class="string">" is the one you are looking for!"</span>)</span><br><span class="line">                <span class="comment"># 结束循环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              	<span class="comment"># 把这个人的朋友添加到队列中</span></span><br><span class="line">              	search_queue += graph[person] </span><br><span class="line">                <span class="comment"># 将这个人标记为检查过</span></span><br><span class="line">                searched.append(person)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">search(<span class="string">"小明"</span>)</span><br></pre></td></tr></table></figure>



<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式id</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8Fid/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>当产品使用人数达到一定量级，一般会采用分库分表等优化操作，但是分布式 <code>id</code> 如何保证全局唯一呢？</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-UUID"><a href="#1-UUID" class="headerlink" title="1.UUID"></a>1.UUID</h2><p><code>UUID</code> 全称是 <code>Universally Unique Identifier</code> ，翻译为通用唯一识别码。此码由网卡 <code>MAC</code> 地址、时间戳、时序、随机数等等一系列元素组合而成，从而保证唯一。碰撞几率几乎为零，大可不必考虑重复问题，放心使用即可。其被广泛应用于各种场景，如图片验证码编号，分布式 <code>id</code> 等。</p>
<p><code>UUID</code> 是由128位二进制组成，一般转换为十六进制，然后使用 <code>String</code> 表示。</p>
<h3 id="1-1-优点"><a href="#1-1-优点" class="headerlink" title="1.1 优点"></a>1.1 优点</h3><p>1) 通过本地生成，没有经过网络 <code>I/O</code>，性能较优</p>
<p>2) 无序，无法预测其生成顺序</p>
<blockquote>
<p>但是无序也变成了它的缺点之一</p>
</blockquote>
<h3 id="1-2-缺点"><a href="#1-2-缺点" class="headerlink" title="1.2 缺点"></a>1.2 缺点</h3><p>1) 128位二进制一般转换成36位的十六进制，因为过于长只能使用 <code>String</code> 存储，空间占用较多</p>
<p>2) 不能生成递增有序的数字。这就导致作为数据库表主键之后效率远不及自增主键</p>
<blockquote>
<p>由于不规则，每向数据库插入一条数据就需要重新排列，因此效率不及自增主键</p>
</blockquote>
<h2 id="2-数据库表自身主键"><a href="#2-数据库表自身主键" class="headerlink" title="2.数据库表自身主键"></a>2.数据库表自身主键</h2><p>在使用唯一标识符时，下意识会考虑到主键自增，因为经常使用，似乎并没有什么问题。但是不要忘记，一般公司产品并未达到分库分表的使用场景，所以不会有任何问题，但并不代表其一直有效。那么它就无法使用了吗？当然不是，可以使用特殊方式：</p>
<p>1) 单独维护一张表，用来生成 <code>id</code> 供分库分表之后共同使用，保证唯一。但是由于所有数据库依赖这张表，其一旦发生意外将导致服务直接崩掉无法使用，所以需要三思而后行。</p>
<p>2) 使用主键的另外一种方式，设置起始值与步长。比如分了两张表，第一张表的主键从1开始，步长为2，表现为：1，3，5 … 第二张表的主键从2开始，步长为2，表现为：2,4,6 … </p>
<h3 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 优点</h3><p>1) 简单方便</p>
<p>2) 有序递增</p>
<p>3) 方便排序和分页</p>
<h3 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h3><p>1) 分库分表会带来问题，需要进行特殊处理</p>
<p>2) 并发性能不高，受限于数据库的性能</p>
<p>3) 简单递增容易被其他人猜测利用。比如你有一个用户服务的递增，那么其他人可以根据分析注册的用户 <code>id</code> 来得到当天你的服务有多少人注册，从而描绘出此服务当前整体状况。</p>
<p>4) 数据库宕机后服务不可用</p>
<h2 id="3-Redis"><a href="#3-Redis" class="headerlink" title="3.Redis"></a>3.Redis</h2><p>不要认为 <code>redis</code> 只可以用来做缓存，它的使用场景超多。此处利用命令 <code>lncr</code> 即可生成分布式 <code>id</code>。</p>
<blockquote>
<p><code>lncr</code> 命令是将 <code>key</code> 中存储的数字值进行加一操作。如果 <code>key</code> 不存在，那么其值会被初始化为0.</p>
</blockquote>
<p>注意：因为 <code>Redis</code> 是单线程的，所以可以保证原子性。就不要再担忧并发数据出错问题了 ~</p>
<h3 id="3-1-优点"><a href="#3-1-优点" class="headerlink" title="3.1 优点"></a>3.1 优点</h3><p>1) 性能比数据库高得多</p>
<p>2) 能满足有序递增的要求</p>
<h3 id="3-2-缺点"><a href="#3-2-缺点" class="headerlink" title="3.2 缺点"></a>3.2 缺点</h3><p>1) <code>redis</code> 是基于内存的键值数据库，虽然有 <code>AOF</code> 和 <code>RDB</code> 等持久化操作，但是依然会存在数据丢失问题，从而导致 <code>id</code> 不唯一。</p>
<blockquote>
<p>有人会问，数据丢失和不唯一有什么关联？比如数据库生成的主键到111113了，但是发生宕机，有一秒的数据丢失，恢复后从111111开始计算，因此重复了两个值111112和111113。</p>
</blockquote>
<p>2) 依赖于 <code>redis</code> ，如果其不稳定，那么也会影响 <code>id</code> 的生成。</p>
<h2 id="4-雪花算法"><a href="#4-雪花算法" class="headerlink" title="4.雪花算法"></a>4.雪花算法</h2><p>雪花算法由 <code>Twitter</code> 提出，英文名为 <code>Snowflake</code> ，它的目的是生成一个 <code>64bit</code> 的整数（<code>1bit</code>符号位 + <code>41bit</code>时间戳 + <code>10bit</code>工作机器<code>id</code> +  <code>12bit</code>序列号 ）。由于其保持增长有序并能通过处理保证唯一而被各大厂商广泛应用于分布式，比如头条。</p>
<p>1) <code>1bit</code> 是符号位，不做任何处理</p>
<p>2) <code>41bit</code> 用来记录时间戳，这里可以记录69年，如果设置好起始时间，比如今年是2020年，那么可以用到2089年。有人会问，到时候怎么办？放心吧，一般产品的生命周期不到69年，即使它活过了69年，此系统一定重构过好多次，因此不是问题</p>
<p>3) <code>10bit</code> 用来记录机器的 <code>id</code> ，总共可以记录1024台。一般前5位代表数据中心，后面5位是某个数据中心的机器 <code>id</code></p>
<p>4) <code>12bit</code> 是循环位，用来解决同一个毫秒之内产生不同的 <code>id</code> 。12位最多可以记录4095个，也就是在同一个机器同一毫秒最多记录4095个，多余的需要进行等待下一毫秒</p>
<p>上述规范适用于 <code>64bit</code> 划分标准，其他情况可以根据实际场景划分。比如：服务目前 <code>QPS</code> 10万，预计几年之内会发展到百万；当前机器三地部署（上海、北京和贵州）；机器共有10台左右，预计未来增加到百台以上。</p>
<p>这个时候我们根据上面的场景可以再次合理划分 <code>62bit</code> 。<code>QPS</code> 几年之内到百万，那么每毫秒就是千级请求，目前10台机器每台承担百万级的请求，为了保证扩展，后面的循环位可以限制到1024，也就是2的10次方，循环位10位足矣。机器三地部署，我们可以用 <code>3bit</code> 总共8来表示机房位置，当前的机器10台，为了保证扩展到百台，可以使用 <code>7bit</code> 也就是128来表示，时间位依然是 <code>41bit</code> ，那么还剩下 64-10-3-7-41-1，也就是 <code>2bit</code>。剩下的 <code>2bit</code> 可以用来进行扩展。</p>
<blockquote>
<p><code>QPS</code> 是每秒查询率</p>
</blockquote>
<h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h3><p>1) 由于时间戳是不断增大的，再加上循环位不断增加，其他位置相对固定，所以可以保证生成有序的 <code>id</code>，提高数据库的性能。</p>
<h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h3><p>1) 时间回拨问题可能导致重复 <code>id</code></p>
<blockquote>
<p>雪花算法强依赖时间，而我们的机器可能因为各种原因发生时间回拨（与时间服务器校准，发现机器时间快了，往回调一下），这就导致有可能生成重复 <code>id</code>。</p>
<p>解决方案一：用当前时间和上一次时间进行判断，如果发生回拨，算法抛出错误，保证不重复（用户看到提示界面，再次进行操作时，肯定已经过了几秒，所以我们毫秒级的处理丝毫不慌，用户体验也并不会降低）。</p>
<p>解决方案二：关闭机器与 <code>ntp</code> 同步</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>四种方案各有优缺点，可以根据产品体量自行选择。不过推荐雪花算法。你懂得 ~</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写出优秀的代码</title>
    <url>/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%BC%98%E7%A7%80%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>写了太多屎一样的代码，终于不臭了！</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-第一坨屎-变量"><a href="#1-第一坨屎-变量" class="headerlink" title="1.第一坨屎-变量"></a>1.第一坨屎-变量</h2><p>为了不让下任『接盘侠』看到代码骂娘，我劝你善良。请不要使用如下方式命名变量：</p>
<p>1.拼音命名（不会英文就去下载个某道词典，翻译一下嘛。<code>name</code> 总比 <code>mingzi</code> 好辨认吧？字数还少，还能国际通用）</p>
<p>2.使用简单字母命名（<code>a</code>/<code>b</code>等等，别说其他人，过两天自己都不晓得写了个什么鬼）</p>
<p>3.异想天开（不要随便拍脑袋起名，要做到见名知义。总不能一个 <code>id</code> 的列表，你叫个 <code>item</code> 吧？<code>xxx_id_list</code> 稍微强一些吧？）</p>
<p>4.不要命名冲突（最起码在一个函数内，不能重复。 <code>project</code> 既是生产项目又是测试项目？变量不断被覆盖，奇奇怪怪的 <code>bug</code> 就够你喝一壶的了）</p>
<blockquote>
<p>这种病的病根儿一般是词汇量匮乏，治疗建议某道翻译。</p>
</blockquote>
<p>5.查询数据库时，变量与字段名、模型类或者表名不一致（查的 <code>Product</code> 就不要叫 <code>Mobiles</code>；查的 <code>name</code> ，就不要叫 <code>leader</code> ）</p>
<h2 id="2-第二坨屎-注释"><a href="#2-第二坨屎-注释" class="headerlink" title="2.第二坨屎-注释"></a>2.第二坨屎-注释</h2><p>为了第二天代码还认识你，请你添加注释。</p>
<p>1.一定要添加注释，最起码重要的逻辑部分覆盖到。</p>
<p>2.注释要清晰、易懂、简单明了。</p>
<p>3.注释不是流水账，不是每一行代码的解释，而是某一块逻辑的说明。</p>
<p>4.对于复杂的数据结构请举例说明。</p>
<p>5.每个函数的说明文档起码要有。</p>
<h2 id="3-第三坨屎-嵌套"><a href="#3-第三坨屎-嵌套" class="headerlink" title="3.第三坨屎-嵌套"></a>3.第三坨屎-嵌套</h2><p>1.不要里三层外三层的 <code>if-else</code>，逻辑判断可以有，但是一定有更加简明的表示方法。嵌套的层级太多，不仅难理解，还影响美观。</p>
<p>2.简单的一层 <code>if-else</code> ，有时三元运算符会更加方便。</p>
<p>3.若想你的程序执行效率高一些，就不要循环套循环。</p>
<p>4.无论何时何地都不要在循环里面有查询数据库的语句。也许一次访问，只需要查询几次数据库，但是用户量大时，能把你数据库搞瘫。多使用一些 <code>bulk_create</code> 或者 <code>bulk_update</code> 等等类似的批量操作方法，一次访问远比多次访问数据库效率高。</p>
<h2 id="4-第四坨屎-逻辑"><a href="#4-第四坨屎-逻辑" class="headerlink" title="4.第四坨屎-逻辑"></a>4.第四坨屎-逻辑</h2><p>1.请将复杂的逻辑单独抽出来做成函数或者类，不要让你的接口内部过于复杂。否则即使有注释，也太晦涩难懂。</p>
<blockquote>
<p>将复杂逻辑抽调后，不光能被其他地方调用，还能使你的接口清晰明了。</p>
</blockquote>
<p>2.实现一个功能，肯定不止一种方法，要不断的去优化，去寻找一条最快最简单的路径。</p>
<blockquote>
<p>当然优化的前提是存在，即使用笨办法也得先实现再说。</p>
</blockquote>
<h2 id="5-第五坨屎-校验"><a href="#5-第五坨屎-校验" class="headerlink" title="5.第五坨屎-校验"></a>5.第五坨屎-校验</h2><p>1.一定要添加必要的校验操作！一定要添加必要的校验操作！一定要添加必要的校验操作！重要的事情说三遍，想要保证程序的健壮性，永远不要相信用户的任何操作！（用户不是开发人员，一定会做出你想不到的操作。为了保证程序安全、数据安全，请添加校验）</p>
<p>2.常用的校验有：为空校验、长度校验、规则校验、常识性校验（最起码上限不能低于下限）、业务校验、边界情况校验等。</p>
<h2 id="6-第六坨屎-单元测试"><a href="#6-第六坨屎-单元测试" class="headerlink" title="6.第六坨屎-单元测试"></a>6.第六坨屎-单元测试</h2><p>1.自动化远比人工可靠。</p>
<blockquote>
<p>不是说人工偷懒，而是重复的点点点难免会有遗漏的情况。添加单元测试，就要可靠的多。</p>
</blockquote>
<p>2.单元测试并不是负担，当你重构代码时，你会发现它的重要作用！</p>
<blockquote>
<p>有单元测试做保障，测试通过就代表重构成功。不需要重复界面点点点，太浪费时间。当然前提是：你的单元测试是可靠的。</p>
</blockquote>
<p>3.重要的方法、逻辑，单元测试一定要覆盖到，它会保证你的程序安全上线！</p>
<p>4.<code>code_review</code> 只能是看规范，看逻辑，肉眼能核对运行结果吗？提交代码先跑一遍单元测试，是否可靠的多？</p>
<blockquote>
<p>这就体现出来自动化测试的好处了，最简单的方法，在 <code>GitLab</code> 上集成单元测试，这样提交代码后自动运行单元测试，不通过肯定不会合并到 <code>master</code>  分支，保证线上环境安全。</p>
</blockquote>
<h2 id="7-第七坨屎-重用"><a href="#7-第七坨屎-重用" class="headerlink" title="7.第七坨屎-重用"></a>7.第七坨屎-重用</h2><p>1.将公共的代码抽调出来，做成公共模块、通用组件。<strong>减少程序代码量</strong>，让程序起飞。</p>
<p>2.重用的优点不光是省代码这么简单，如果相同的代码这也有，那也有，出错怎么办？改几遍？<strong>便于维护</strong></p>
<p>3.将常用的数字抽出一个常数文件，其他地方调用变量的形式使用，这样维护一个常数文件比维护分散在各个角落的代码要好的多。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>复用Django应用，使其可以通过pip安装</title>
    <url>/%E5%A4%8D%E7%94%A8Django%E5%BA%94%E7%94%A8%EF%BC%8C%E4%BD%BF%E5%85%B6%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87pip%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>想自己打包一个应用，可以像其他模块一样通过 <code>pip install</code> 安装吗？在 <code>Django</code> 项目中，一个应用如果通过此方式随用随安装是不是很帅气？快来看一下如何操作吧！</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h1 id="1-前提"><a href="#1-前提" class="headerlink" title="1.前提"></a>1.前提</h1><h2 id="1-1应用规范"><a href="#1-1应用规范" class="headerlink" title="1.1应用规范"></a>1.1应用规范</h2><p>为了方便打包，你的应用应该解耦合，并且所有文件都规范放置。其中需要注意：按照 <code>Django3.0</code> 官方文档描述，每个应用中的模板文件 <code>templates</code> 应与主项目中通用模板文件 <code>templates</code> 分离，最主要目的是为了创建可复用应用。</p>
<blockquote>
<p>官方文档原文：Just like the static files, we could have all our templates together, in one big templates directory, and it would work perfectly well. However, templates that belong to a particular application should be placed in that application’s template directory.</p>
</blockquote>
<p><strong>保证应用所需文件全部包含在应用目录中</strong>即可开始操作。</p>
<h2 id="1-2-环境"><a href="#1-2-环境" class="headerlink" title="1.2 环境"></a>1.2 环境</h2><p>安装模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install setuptools </span><br><span class="line">pip install wheel</span><br></pre></td></tr></table></figure>



<h1 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h1><h2 id="2-1-准备文件"><a href="#2-1-准备文件" class="headerlink" title="2.1 准备文件"></a>2.1 准备文件</h2><p>比如我要打包应用 <code>polls</code> ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">polls</span><br><span class="line">├── __init__.py</span><br><span class="line">├── __pycache__</span><br><span class="line">│   ├── __init__.cpython-37.pyc</span><br><span class="line">│   ├── admin.cpython-37.pyc</span><br><span class="line">│   ├── apps.cpython-37.pyc</span><br><span class="line">│   ├── models.cpython-37.pyc</span><br><span class="line">│   ├── tests.cpython-37.pyc</span><br><span class="line">│   ├── urls.cpython-37.pyc</span><br><span class="line">│   ├── views.cpython-37.pyc</span><br><span class="line">│   └── views_bak.cpython-37.pyc</span><br><span class="line">├── admin.py</span><br><span class="line">├── apps.py</span><br><span class="line">├── migrations</span><br><span class="line">│   ├── 0001_initial.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── __pycache__</span><br><span class="line">│       ├── 0001_initial.cpython-37.pyc</span><br><span class="line">│       └── __init__.cpython-37.pyc</span><br><span class="line">├── models.py</span><br><span class="line">├── static</span><br><span class="line">│   └── polls</span><br><span class="line">│       ├── images</span><br><span class="line">│       │   └── 1574779118421.jpg</span><br><span class="line">│       └── style.css</span><br><span class="line">├── templates</span><br><span class="line">│   └── polls</span><br><span class="line">│       ├── details.html</span><br><span class="line">│       ├── index.html</span><br><span class="line">│       └── results.html</span><br><span class="line">├── tests.py</span><br><span class="line">├── urls.py</span><br><span class="line">├── views.py</span><br><span class="line">└── views_bak.py # 视图备份文件</span><br></pre></td></tr></table></figure>

<h3 id="2-1-1-步骤"><a href="#2-1-1-步骤" class="headerlink" title="2.1.1 步骤"></a>2.1.1 步骤</h3><h4 id="2-1-1-1-创建总目录"><a href="#2-1-1-1-创建总目录" class="headerlink" title="2.1.1.1 创建总目录"></a>2.1.1.1 创建总目录</h4><p>1) 创建总目录，比如创建目录 <code>django-polls</code></p>
<p>2) 然后将应用 <code>polls</code> 移入上方总目录，此时它的目录结构应该是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">django-polls/polls</span><br></pre></td></tr></table></figure>



<h4 id="2-1-1-2-创建说明文档"><a href="#2-1-1-2-创建说明文档" class="headerlink" title="2.1.1.2 创建说明文档"></a>2.1.1.2 创建说明文档</h4><p>创建说明文档 <code>django-polls/README.rst</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Polls</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Polls is a Django app to conduct Web-based polls. For each question,</span><br><span class="line">visitors can choose between a fixed number of answers.</span><br><span class="line"></span><br><span class="line">Detailed documentation is in the &quot;docs&quot; directory.</span><br><span class="line"></span><br><span class="line">Quick start</span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">1. Add &quot;polls&quot; to your INSTALLED_APPS setting like this::</span><br><span class="line"></span><br><span class="line">    INSTALLED_APPS &#x3D; [</span><br><span class="line">        ...</span><br><span class="line">        &#39;polls&#39;,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">2. Include the polls URLconf in your project urls.py like this::</span><br><span class="line"></span><br><span class="line">    path(&#39;polls&#x2F;&#39;, include(&#39;polls.urls&#39;)),</span><br><span class="line"></span><br><span class="line">3. Run &#96;&#96;python manage.py migrate&#96;&#96; to create the polls models.</span><br><span class="line"></span><br><span class="line">4. Start the development server and visit http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;admin&#x2F;</span><br><span class="line">   to create a poll (you&#39;ll need the Admin app enabled).</span><br><span class="line"></span><br><span class="line">5. Visit http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;polls&#x2F; to participate in the poll.</span><br></pre></td></tr></table></figure>



<h4 id="2-1-1-3-创建授权协议文件"><a href="#2-1-1-3-创建授权协议文件" class="headerlink" title="2.1.1.3 创建授权协议文件"></a>2.1.1.3 创建授权协议文件</h4><p>创建一个 <code>django-polls/LICENSE</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Copyright (c) 2018 The Python Packaging Authority</span><br><span class="line"></span><br><span class="line">Permission is hereby granted, free of charge, to any person obtaining a copy</span><br><span class="line">of this software and associated documentation files (the &quot;Software&quot;), to deal</span><br><span class="line">in the Software without restriction, including without limitation the rights</span><br><span class="line">to use, copy, modify, merge, publish, distribute, sublicense, and&#x2F;or sell</span><br><span class="line">copies of the Software, and to permit persons to whom the Software is</span><br><span class="line">furnished to do so, subject to the following conditions:</span><br><span class="line"></span><br><span class="line">The above copyright notice and this permission notice shall be included in all</span><br><span class="line">copies or substantial portions of the Software.</span><br><span class="line"></span><br><span class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span><br><span class="line">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span><br><span class="line">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span><br><span class="line">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span><br><span class="line">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span><br><span class="line">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span><br><span class="line">SOFTWARE.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>协议文件自己可以从网上寻找生成方式</p>
</blockquote>
<h4 id="2-1-1-4-创建安装文件"><a href="#2-1-1-4-创建安装文件" class="headerlink" title="2.1.1.4 创建安装文件"></a>2.1.1.4 创建安装文件</h4><p>1) 创建文件 <code>django-polls/setup.cfg</code> （此文件为模块的配置信息，比如作者的姓名、联系方式等）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[metadata]</span><br><span class="line">name &#x3D; django-polls</span><br><span class="line">version &#x3D; 0.1</span><br><span class="line">description &#x3D; A Django app to conduct Web-based polls.</span><br><span class="line">long_description &#x3D; file: README.rst</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;www.pythonnote.cn</span><br><span class="line">author &#x3D; Ethan Yan</span><br><span class="line">author_email &#x3D; yanyuliang6@163.com</span><br><span class="line">license &#x3D; MIT  # Example license</span><br><span class="line">classifiers &#x3D;</span><br><span class="line">    Environment :: Web Environment</span><br><span class="line">    Framework :: Django</span><br><span class="line">    Framework :: Django :: X.Y  # Replace &quot;X.Y&quot; as appropriate</span><br><span class="line">    Intended Audience :: Developers</span><br><span class="line">    License :: OSI Approved :: BSD License</span><br><span class="line">    Operating System :: OS Independent</span><br><span class="line">    Programming Language :: Python</span><br><span class="line">    Programming Language :: Python :: 3</span><br><span class="line">    Programming Language :: Python :: 3 :: Only</span><br><span class="line">    Programming Language :: Python :: 3.6</span><br><span class="line">    Programming Language :: Python :: 3.7</span><br><span class="line">    Programming Language :: Python :: 3.8</span><br><span class="line">    Topic :: Internet :: WWW&#x2F;HTTP</span><br><span class="line">    Topic :: Internet :: WWW&#x2F;HTTP :: Dynamic Content</span><br><span class="line"></span><br><span class="line">[options]</span><br><span class="line">include_package_data &#x3D; true</span><br><span class="line">packages &#x3D; find:</span><br></pre></td></tr></table></figure>

<p>2) 创建文件 <code>django-polls/setup.py</code> （此文件是为了构建和安装应用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from setuptools import setup</span><br><span class="line"></span><br><span class="line">setup()</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-5-创建引用文件"><a href="#2-1-1-5-创建引用文件" class="headerlink" title="2.1.1.5 创建引用文件"></a>2.1.1.5 创建引用文件</h4><p>默认包中只包含 <code>Python</code> 模块和包。为了包含额外文件，我们需要创建一个名为 <code>MANIFEST.in</code> 的文件。为了包含模板、<code>README.rst</code> 和我们的 <code>LICENSE</code> 文件，创建文件 <code>django-polls/MANIFEST.in</code> 包含以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">include LICENSE</span><br><span class="line">include README.rst</span><br><span class="line">recursive-include polls/static *</span><br><span class="line">recursive-include polls/templates *</span><br><span class="line">recursive-include docs *</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>docs</code> 目录为文档存放目录，可有可无，视情况而定。如果需要引入其他文件，按照格式在上述文件中补充即可。</p>
</blockquote>
<p>最终的目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">django-polls</span><br><span class="line">├── LICENSE</span><br><span class="line">├── MANIFEST.in</span><br><span class="line">├── README.rst</span><br><span class="line">├── doc</span><br><span class="line">├── polls</span><br><span class="line">├── setup.cfg</span><br><span class="line">└── setup.py</span><br></pre></td></tr></table></figure>



<h2 id="2-2-打包"><a href="#2-2-打包" class="headerlink" title="2.2 打包"></a>2.2 打包</h2><p>接下来快看一下如何打包吧！</p>
<p>1) 进入总目录 <code>django-polls</code> 中</p>
<p>2) 执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python setup.py sdist bdist_wheel</span><br></pre></td></tr></table></figure>

<p>3) 最终的模块在如下位置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dist</span><br><span class="line">├── django-polls-0.1.tar.gz</span><br><span class="line">└── django_polls-0.1-py3-none-any.whl</span><br></pre></td></tr></table></figure>

<p><code>django-polls-0.1.tar.gz</code> 即打包好的应用。</p>
<h2 id="2-3-安装使用"><a href="#2-3-安装使用" class="headerlink" title="2.3 安装使用"></a>2.3 安装使用</h2><p>在应用包所在目录执行如下命令即可安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m pip install django-polls-0.1.tar.gz</span><br></pre></td></tr></table></figure>

<p>安装后如何在 <code>Django</code> 项目中使用呢？</p>
<p>1) 在 <code>settings</code> 文件中添加如下应用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">        ...</span><br><span class="line">        'polls',</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>2) 在 <code>urls</code> 文件中添加如下代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">path('polls/', include('polls.urls')),</span><br></pre></td></tr></table></figure>

<p>3) 迁移数据库文件，创建 <code>models</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p>然后即可使用。如果想要使用我打包好的应用体验一把，可以在微信公众号「全栈技术精选」后台回复关键字「polls应用包」获取模块。</p>
<h2 id="2-4-卸载"><a href="#2-4-卸载" class="headerlink" title="2.4 卸载"></a>2.4 卸载</h2><p>卸载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m pip uninstall django-polls</span><br></pre></td></tr></table></figure>



<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>如果你是mac用户，这个问题不信你没遇到！</title>
    <url>/%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%98%AFmac%E7%94%A8%E6%88%B7%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E4%B8%8D%E4%BF%A1%E4%BD%A0%E6%B2%A1%E9%81%87%E5%88%B0%EF%BC%81/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 

<p>Mac 用户在使用 python 的虚拟环境时，你现在或者将来一定会遇到此问题，早发现早治疗 ～</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>在虚拟环境中执行 <code>python</code> 等相关命令时，报如下所示错误：</p>
<img src="https://github.com/EthanYan6/pic/raw/master/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%8A%A5%E9%94%99-2.png" alt="报错2" style="zoom:50%;">

<p>使用 <code>pip</code> 命令报错依旧：</p>
<img src="https://github.com/EthanYan6/pic/raw/master/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%8A%A5%E9%94%99-1.png" alt="报错1" style="zoom:50%;">

<p>是不是很诡异？</p>
<h3 id="2-原因分析"><a href="#2-原因分析" class="headerlink" title="2.原因分析"></a>2.原因分析</h3><p>出现上述问题，在查询过 <code>Google</code> 和 <code>stackoverflow</code> 等之后，发现了共性：都是使用 <code>MAC</code> 的用户，而且使用了  <code>brew</code> 包管理工具。</p>
<p>在执行 <code>brew update</code> 命令之后会升级所有管理的模块，比如 <code>Python</code> 。因此遇到 <code>Python</code> 有版本更新时，嘻嘻，恭喜你中奖了。</p>
<p><code>Mac</code> 在创建虚拟环境后，会发现文件夹下有一些链接文件，各种软链接其实指向了系统的 <code>Python</code> （节省空间所致），所以当你更新了 <code>Python</code> 之后，它所在的路径中包含的版本号也会更新，路径立即失效（软链接其实就保存的就是绝对路径），你的虚拟环境也就无法正常启动了。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h3 id="3-解决办法"><a href="#3-解决办法" class="headerlink" title="3.解决办法"></a>3.解决办法</h3><p>网上有一些解决办法，如下：</p>
<p>1.既然知道原因，那么重新修复这些软链接不就好了？于是，开始了 <code>删除创建</code> 之旅。</p>
<blockquote>
<p>我滴个乖乖！你知道哪个犄角旮旯里还藏着一个不怀好意的软链接嘛？然后网友提供了各种命令：</p>
<p><code>find ~/.virtualenvs/my-virtual-env/ -type l</code> 别闹了好吗？几十个文件，我怎么弄？放弃放弃，如果你愿意，那么请查看这篇帖子仔细研究即可：<a href="https://stackoverflow.com/questions/23233252/broken-references-in-virtualenvs" target="_blank" rel="noopener">https://stackoverflow.com/questions/23233252/broken-references-in-virtualenvs</a></p>
</blockquote>
<p>2.重新装系统</p>
<blockquote>
<p>这个。。。不至于吧，杀鸡焉用宰牛刀？既然知道问题，解决就好了嘛</p>
</blockquote>
<p>3.删除虚拟环境</p>
<blockquote>
<p>这个听起来不错，这也正是我想讲的方法。前提是你有 <code>requirements.txt</code> 文件，要不然还是麻烦点使用办法 1 吧。</p>
</blockquote>
<h3 id="4-实操"><a href="#4-实操" class="headerlink" title="4.实操"></a>4.实操</h3><p>删除重建虚拟环境即可，但如果这么简单，还用往下讲解吗？笑话！以后再出现，难不成还在删除吗？且听我的骚操作。</p>
<p>删除虚拟环境后，再创建时，请使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtualenv --no-site-packages --always-copy 虚拟环境名称 -p python3</span><br></pre></td></tr></table></figure>

<p>1.<code>--no-site-packages</code> ：创建虚拟环境时，不会安装系统环境中的任何模块（也就是创建一个全新的环境）</p>
<p>2.<code>-p python3</code> 指定创建的虚拟环境为 <code>python3.x</code> 版本</p>
<p>3.<code>--always-copy</code> 可以跟踪系统 <code>python</code> 信息，即使你升级了系统的 <code>python</code> ，虚拟环境仍然可以使用。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>python</tag>
        <tag>virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程如何获取结果</title>
    <url>/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>下午的综合面试，技术方面只询问了项目，剩下时间全是背景调查，双方提问、互相了解情况。所以今天的文章就没有面试题了，总结一位老哥教我的一个知识点：多线程如何获取结果。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-场景"><a href="#1-场景" class="headerlink" title="1.场景"></a>1.场景</h2><p>大家一般都会开启多线程去处理任务，如果需要获取线程处理结果怎么办？</p>
<p>有人会说『全局变量』，但是又会引出共享全局变量后资源竞争导致数据错误的问题。只能通过添加互斥锁进行解决，互斥锁又不能发挥多线程的优势，很是头大。</p>
<p>那么该如何解决呢？</p>
<h2 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2.解决办法"></a>2.解决办法</h2><p>老哥教我可以自定义一个类解决：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args)</span>:</span></span><br><span class="line">        super(MyThread, self).__init__()</span><br><span class="line">        self.func = func</span><br><span class="line">        self.args = args</span><br><span class="line">        self.result = self.func(*self.args)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_result</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading.Thread.join(self)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.result</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p><strong>使用方式</strong>：直接创建一个对象 <code>thread</code>，在使用方法 <code>thread.start()</code> 后，再调用 <code>get_result()</code> 方法即可获取。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab 执行python脚本不生效？（续）</title>
    <url>/%E6%89%A7%E8%A1%8Cpython%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
Linux 设置定时任务，crontab 执行 python 脚本不生效的问题：
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>尝试方法：</p>
<p>1.给 python 脚本第一行添加如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然 python 解释器的路径要按照自己情况进行填写。</p>
</blockquote>
<p>2.如果 python 脚本报错，模块未找到等等，尝试如下方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">'xxx&lt;第三方模块的路径&gt;'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是虚拟环境，有可能此路径不同，可以通过下列命令查看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> elasticsearch</span><br><span class="line">&gt;elasticsearch.__file__</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后将路径复制到 <code>sys.path.append(&#39;&#39;)</code> 中的引号即可，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D:\\E\\python_virtual\\fbl5n\\lib\\site-packages</span><br></pre></td></tr></table></figure>
<p>3.python 脚本中不涉及复杂的逻辑，简单的函数即函数调用即可，如果出现下列代码，请去掉：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br></pre></td></tr></table></figure>
<p>它会将 crontab 在调用的时候搞晕。</p>
<p>4.可以写一个 shell 脚本去调用 python 脚本，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/bash</span></span><br><span class="line">cd /opt</span><br><span class="line">/usr/bin/python3 mail_reminder.py &gt;&gt; log.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>0 表示stdin标准输入<br>1 表示stdout标准输出<br>2 表示stderr标准错误<br>&amp; 表示等同于的意思<br>2&gt;&amp;1 表示2的输出重定向等同于1</p>
</blockquote>
<p>5.当报错编码问题时可以尝试使用如下方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/bash </span></span><br><span class="line">cd /opt </span><br><span class="line">PYTHONIOENCODING=utf-8 /usr/bin/python3 mail_reminder.py &gt;&gt; log.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
        <tag>crontab</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>常用 es 查询盘点</title>
    <url>/%E5%B8%B8%E7%94%A8-es-%E6%9F%A5%E8%AF%A2%E7%9B%98%E7%82%B9/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
熟悉了关系型数据库的结构概念以及查询，再去使用属于非关系型数据库的 Elasticsearch 时，简直是噩梦。第一道难关便是概念上的转换。索引？类型？文档？what？

 <a id="more"></a> 

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<blockquote>
<p>下面是概念上的对应，大家可以类比了解</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns</span><br><span class="line">Elasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields</span><br></pre></td></tr></table></figure>

<p>熟悉了各种概念后，下一道难关便是增删改查，而最最常用的是<strong>查询</strong>！如同 SQL 一样，它有一套自己的查询语句，称为 DSL。所以，下面为大家总结一下常用的查询，然后你就可以像翻字典一样，用时瞄两眼了 ~ 嘿嘿，真他娘的是个天才 … </p>
<h3 id="1-基础的不能再基础查询"><a href="#1-基础的不能再基础查询" class="headerlink" title="1.基础的不能再基础查询"></a>1.基础的不能再基础查询</h3><p><strong>查询所有的索引及容量：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _cat/indices</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>GET</code> 代表请求方式；<code>_cat/indices</code> 代表查询部分。访问的 <code>url</code> 写全为：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">localhost:9200/_cat/indices</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>查询某一索引的映射结构：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET 索引名/_mapping</span><br></pre></td></tr></table></figure>

<p><strong>查询所有的相同前缀索引：（如以 yan 开头）</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET yan*/_search</span><br></pre></td></tr></table></figure>

<p><strong>查询所有索引模板：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _template</span><br></pre></td></tr></table></figure>

<p><strong>查询具体索引模板：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _template/模板名</span><br></pre></td></tr></table></figure>

<p><strong>查询集群健康状态：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _cluster/health</span><br></pre></td></tr></table></figure>

<p><strong>查询所有节点：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _cat/nodes</span><br></pre></td></tr></table></figure>

<p><strong>查询索引及分片的分布：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _cat/shards</span><br></pre></td></tr></table></figure>

<p><strong>查询所有插件:</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _cat/plugins</span><br></pre></td></tr></table></figure>

<h3 id="2-有点难度的查询"><a href="#2-有点难度的查询" class="headerlink" title="2.有点难度的查询"></a>2.有点难度的查询</h3><p><strong>查询某个索引的全部数据：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "match_all": &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然你也可以直接写 URL 查询（默认返回 10 条文档）：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">localhost:9200/索引名/_search?pretty</span></span><br></pre></td></tr></table></figure>
<p>pretty参数是为了浏览器显示的美观一些。</p>
</blockquote>
<p><strong>根据某一字段精确查询：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "term": &#123; "字段名" : "值" &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据某一字段模糊匹配：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "match": &#123; "字段名" : "值" &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据某一字段值进行范围查找：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "range": &#123;</span><br><span class="line">    	# 字段名: 条件</span><br><span class="line">        "age":&#123; "gte" : 15 , "lte" : 25 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>gte 是大于等于；lte 是小于等于</p>
</blockquote>
<p><strong>根据条件进行过滤查询：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "filter": &#123;</span><br><span class="line">        "term":&#123;"字段":"值"&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多条件”或”关系：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">	"query": &#123;</span><br><span class="line">		"bool": &#123;</span><br><span class="line">			"should": [&#123;</span><br><span class="line">				"term": &#123;</span><br><span class="line">					"字段": "值"</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, &#123;</span><br><span class="line">				"match": &#123;</span><br><span class="line">					"字段": "值"</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多条件”与”关系：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must" : [&#123;</span><br><span class="line">        "match" : &#123;</span><br><span class="line">          "name" : "Ethanyan"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        "range":&#123;</span><br><span class="line">        "age":&#123;</span><br><span class="line">          "from" : 18 , "to" : 26</span><br><span class="line">        &#125; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>严格匹配：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must" : &#123;</span><br><span class="line">        "range" : &#123;</span><br><span class="line">          "age" : &#123; "from" : 18, "to" : 26 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>严格不匹配：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must_not" : &#123;</span><br><span class="line">        "term" : &#123;</span><br><span class="line">          "name" : "Ethanyan"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复合查询：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">	"query": &#123;</span><br><span class="line">		"bool": &#123;</span><br><span class="line">			"should": [&#123;</span><br><span class="line">					"match": &#123;</span><br><span class="line">						"age": 18</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,  </span><br><span class="line">				&#123;</span><br><span class="line">					"match": &#123;</span><br><span class="line">						"age": 26</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			],</span><br><span class="line">			"filter": &#123; </span><br><span class="line">				"match": &#123;  </span><br><span class="line">					"name": "Ethanyan" </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h3><p>1.索引名、模板名之类的名称不能出现字母大写</p>
<p>2.在查询时，需要写 DSL 语句，所以需要携带请求体，那么为什么还是 get 请求？</p>
<p>答：原则上 get 请求不能携带请求体，但凡事有例外，试验后确实可以，我也不晓得为什么。下方为官方文档，全为 get 请求：</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E5%B8%B8%E7%94%A8-es-%E6%9F%A5%E8%AF%A2%E7%9B%98%E7%82%B9/esquery.png" alt="esquery"></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手教你配置vim，小白也可以</title>
    <url>/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%85%8D%E7%BD%AEvim%EF%BC%8C%E5%B0%8F%E7%99%BD%E4%B9%9F%E5%8F%AF%E4%BB%A5/</url>
    <content><![CDATA[<center>Author: 闫玉良</center>

<p>想使用 <code>vim</code> ，但被各种配置项搞得头晕眼花？想让 <code>vim</code> 与众不同，奈何手残搞得系统崩溃？这篇文章就是你的福音！快来看看吧！</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/vim%E5%B1%95%E7%A4%BA.png" alt="vim展示"></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-安装包管理工具"><a href="#1-安装包管理工具" class="headerlink" title="1.安装包管理工具"></a>1.安装包管理工具</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</span><br></pre></td></tr></table></figure>

<h3 id="2-下载最经典的vim配色方案"><a href="#2-下载最经典的vim配色方案" class="headerlink" title="2.下载最经典的vim配色方案"></a>2.下载最经典的vim配色方案</h3><p>1.克隆所需仓库文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/tomasr/molokai.git ~/.vim/colors</span><br></pre></td></tr></table></figure>

<p>2.移动文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv ~/.vim/colors/colors/molokai.vim ~/.vim/colors</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将克隆下来的代码中 <code>molokai.vim</code> 放到 <code>vim</code> 可读取配置的目录内（<code>~/.vim/colors</code>）。</p>
</blockquote>
<p>3.删除无用文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.vim/colors</span><br><span class="line">rm -rf colors README.md LICENSE.md</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>colors</code> 中有用的文件我们已经移除，这个空目录可以删除；<code>README.md</code> 是说明文件；<code>LICENSE.md</code> 是授权说明文件。</p>
</blockquote>
<h3 id="3-安装搜索命令ag"><a href="#3-安装搜索命令ag" class="headerlink" title="3.安装搜索命令ag"></a>3.安装搜索命令ag</h3><h4 id="3-1-Ubuntu"><a href="#3-1-Ubuntu" class="headerlink" title="3.1 Ubuntu"></a>3.1 Ubuntu</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install silversearcher-ag</span><br></pre></td></tr></table></figure>

<h4 id="3-2-CentOS"><a href="#3-2-CentOS" class="headerlink" title="3.2 CentOS"></a>3.2 CentOS</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum -y install the_silver_searcher</span><br></pre></td></tr></table></figure>

<h4 id="3-3-Mac"><a href="#3-3-Mac" class="headerlink" title="3.3 Mac"></a>3.3 Mac</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install the_silver_searcher</span><br></pre></td></tr></table></figure>

<h3 id="4-使用提供的-vimrc文件替换掉电脑中的同名配置文件"><a href="#4-使用提供的-vimrc文件替换掉电脑中的同名配置文件" class="headerlink" title="4.使用提供的.vimrc文件替换掉电脑中的同名配置文件"></a>4.使用提供的.vimrc文件替换掉电脑中的同名配置文件</h3><p><strong><code>.vimrc</code> 获取方式：关注微信公众号「全栈技术精选」，回复「vimrc」即可获取</strong></p>
<p>1.将 <code>.vimrc</code> 放到家目录 <code>~/</code> 下</p>
<p>2.使用 <code>vim</code> 打开 <code>.vimrc</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.vimrc</span><br></pre></td></tr></table></figure>

<p>3.使用包管理器安装配置文件中的插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:PluginInstall</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述命令在 <code>vim</code> 的命令模式下输入。输入完后回车，耐心等待下载，插件比较多耗时比较长。如果下载完成后，底部状态行会显示 <code>Done!</code></p>
</blockquote>
<h3 id="5-注意"><a href="#5-注意" class="headerlink" title="5.注意"></a>5.注意</h3><p>1.如果报错：The ycmd server SHUT DOWN (restart with …low the instructions in the documen</p>
<p><strong>解决方法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.vim/bundle/YouCompleteMe</span><br><span class="line">./install.py</span><br></pre></td></tr></table></figure>

<p>2.如果报错：ERROR: Unable to find executable ‘cmake’. CMake is required to build ycmd</p>
<p><strong>解决办法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line">sudo apt install cmake</span><br><span class="line"><span class="meta">#</span><span class="bash"> Mac</span></span><br><span class="line">brew install cmake</span><br></pre></td></tr></table></figure>

<p>3.如果安装完后颜色显示与图片中不一致，状态栏颜色也是黑色，那么可以考虑使用如下方法解决。</p>
<p><strong>解决方法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.vimrc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加如下信息</span></span><br><span class="line">set t_Co=256</span><br></pre></td></tr></table></figure>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>扶我起来,我还可以学～</title>
    <url>/%E6%89%B6%E6%88%91%E8%B5%B7%E6%9D%A5-%E6%88%91%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%AD%A6%EF%BD%9E/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
长路漫漫，唯夜作伴。虽然一天的工作头昏脑胀，但是仍然放不下我心心念念的前端啊，扶我起来，我还可以学～

<p>学习喜欢的事情，也是一种放松，come on！</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>上篇文章讲了 Vue 的一些基础概念，语法。今天上些难度。</p>
<h2 id="1-实例生命周期"><a href="#1-实例生命周期" class="headerlink" title="1.实例生命周期"></a>1.实例生命周期</h2><p>如同人的生老病死，实力对象也有其本身的生命周期。当我们深入了解每一个阶段之后，才会在合适的阶段添加合适的功能。那么如何在合适的阶段完成所需需求呢？那就用到了<strong>生命周期钩子</strong>。类比 Flask 中的请求钩子，Django 中的中间件，不知这样说你是否更好理解。下面我们就来看看有哪些钩子：</p>
<h3 id="1-1-beforeCreate"><a href="#1-1-beforeCreate" class="headerlink" title="1.1 beforeCreate"></a>1.1 beforeCreate</h3><p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p>
<h3 id="1-2-created"><a href="#1-2-created" class="headerlink" title="1.2 created"></a>1.2 created</h3><p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始</p>
<h3 id="1-3-beforeMount"><a href="#1-3-beforeMount" class="headerlink" title="1.3 beforeMount"></a>1.3 beforeMount</h3><p>在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<h3 id="1-4-mounted"><a href="#1-4-mounted" class="headerlink" title="1.4 mounted"></a>1.4 mounted</h3><p>实例挂载到 dom 之后被调用，可以当成是 vue 对象的 ready 方法来使用，一般用它来做 dom 的初始化操作。</p>
<h3 id="1-5-beforeUpdate"><a href="#1-5-beforeUpdate" class="headerlink" title="1.5 beforeUpdate"></a>1.5 beforeUpdate</h3><p>数据发生变化前调用</p>
<h3 id="1-6-updated"><a href="#1-6-updated" class="headerlink" title="1.6 updated"></a>1.6 updated</h3><p>数据发生变化后调用</p>
<h3 id="1-7-beforeDestroy"><a href="#1-7-beforeDestroy" class="headerlink" title="1.7 beforeDestroy"></a>1.7 beforeDestroy</h3><p>挂载完毕，数据更新完成之后；解除绑定，销毁子组件以及事件监听器之前调用。</p>
<h3 id="1-8-destroyed"><a href="#1-8-destroyed" class="headerlink" title="1.8 destroyed"></a>1.8 destroyed</h3><p>销毁完毕之后调用。</p>
<h2 id="2-表单输入绑定"><a href="#2-表单输入绑定" class="headerlink" title="2.表单输入绑定"></a>2.表单输入绑定</h2><p>可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code> 及 <code>&lt;textarea&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素</p>
<h3 id="2-1单行文本框"><a href="#2-1单行文本框" class="headerlink" title="2.1单行文本框"></a>2.1单行文本框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-多行文本框"><a href="#2-2-多行文本框" class="headerlink" title="2.2 多行文本框"></a>2.2 多行文本框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Multiline message is:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"add multiple lines"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-复选框"><a href="#2-3-复选框" class="headerlink" title="2.3 复选框"></a>2.3 复选框</h3><p>单个复选框，绑定到布尔值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checked"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"checkbox"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>多个复选框，绑定到同一个数组：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'example-3'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"jack"</span> <span class="attr">value</span>=<span class="string">"Jack"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"jack"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"john"</span> <span class="attr">value</span>=<span class="string">"John"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"john"</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"mike"</span> <span class="attr">value</span>=<span class="string">"Mike"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"mike"</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#example-3',</span><br><span class="line">  data: &#123;</span><br><span class="line">    checkedNames: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-4-单选框"><a href="#2-4-单选框" class="headerlink" title="2.4 单选框"></a>2.4 单选框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"One"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"Two"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#example-4',</span><br><span class="line">  data: &#123;</span><br><span class="line">    picked: ''</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-5-下拉框"><a href="#2-5-下拉框" class="headerlink" title="2.5 下拉框"></a>2.5 下拉框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '...',</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected:''</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-计算属性-amp-监听属性"><a href="#3-计算属性-amp-监听属性" class="headerlink" title="3.计算属性&amp;监听属性"></a>3.计算属性&amp;监听属性</h2><h3 id="3-1-计算属性"><a href="#3-1-计算属性" class="headerlink" title="3.1 计算属性"></a>3.1 计算属性</h3><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个表达式的功能是将message字符串进行反转，这种带有复杂逻辑的表达式，我们可以使用计算属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "&#123;&#123; message &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: '#example',</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: 'Hello'</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      return this.message.split('').reverse().join('')</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-侦听属性"><a href="#3-2-侦听属性" class="headerlink" title="3.2 侦听属性"></a>3.2 侦听属性</h3><p>侦听属性的作用是侦听某属性值的变化，从而做相应的操作，侦听属性是一个对象，它的键是要监听的对象或者变量，值一般是函数,当你侦听的元素发生变化时，需要执行的函数，这个函数有两个形参，第一个是当前值，第二个是变化后的值。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">'#app'</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            iNum:<span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        watch:&#123;</span><br><span class="line">            iNum:<span class="function"><span class="keyword">function</span>(<span class="params">newval,oldval</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(newval + <span class="string">' | '</span> + oldval) </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            fnAdd:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.iNum += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-过滤器"><a href="#4-过滤器" class="headerlink" title="4.过滤器"></a>4.过滤器</h2><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></span><br><span class="line">&#123;&#123; prize | RMB &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在v-bind中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"rawId | formatId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>过滤器实际上是一个函数，可以在一个组件的选项中定义组件内部过滤器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filters:&#123;</span><br><span class="line">  RMB:<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value==<span class="string">''</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'¥ '</span>+value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者在创建 Vue 实例之前全局定义过滤器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.filter(<span class="string">'Yuan'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(value==<span class="string">''</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value+<span class="string">'元'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此时过滤器’RMB’只能在定义它的对象接管标签内使用，而 ‘Yuan’ 可以全局使用</p>
<h2 id="5-数据交互"><a href="#5-数据交互" class="headerlink" title="5. 数据交互"></a>5. 数据交互</h2><p>vue.js没有集成ajax功能，要使用ajax功能，可以使用vue官方推荐的axios.js库来做ajax的交互。 axios库的下载地址：<a href="https://github.com/axios/axios/releases" target="_blank" rel="noopener">https://github.com/axios/axios/releases</a></p>
<h3 id="5-1-axios完整写法："><a href="#5-1-axios完整写法：" class="headerlink" title="5.1 axios完整写法："></a>5.1 axios完整写法：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>axios请求的写法也写成get方式后post方式。</p>
<h3 id="5-2-执行get请求"><a href="#5-2-执行get请求" class="headerlink" title="5.2 执行get请求"></a>5.2 执行get请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为给定 ID 的 user 创建请求</span></span><br><span class="line"><span class="comment">// then是请求成功时的响应，catch是请求失败时的响应</span></span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选地，上面的请求可以这样做</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="5-3-执行post请求"><a href="#5-3-执行post请求" class="headerlink" title="5.3 执行post请求"></a>5.3 执行post请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">  firstName: <span class="string">'Fred'</span>,</span><br><span class="line">  lastName: <span class="string">'Flintstone'</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="6-ES6-语法"><a href="#6-ES6-语法" class="headerlink" title="6.ES6 语法"></a>6.ES6 语法</h2><h3 id="6-1-变量声明let和const"><a href="#6-1-变量声明let和const" class="headerlink" title="6.1 变量声明let和const"></a>6.1 变量声明let和const</h3><p>let 和 const 是新增的声明变量的开头的关键字，在这之前，变量声明是用 var 关键字，这两个关键字和 var 的区别是，它们声明的变量没有预解析，let 和 const 的区别是，let 声明的是一般变量，const 申明的常量，不可修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(iNum01) <span class="comment">// 弹出undefined</span></span><br><span class="line"><span class="comment">// alert(iNum02); 报错，let关键字定义变量没有变量预解析</span></span><br><span class="line"><span class="comment">// alert(iNum03); 报错，const关键字定义变量没有变量预解析</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iNum01 = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 使用let关键字定义变量</span></span><br><span class="line"><span class="keyword">let</span> iNum02 = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// 使用const关键字定义变量</span></span><br><span class="line"><span class="keyword">const</span> iNum03 = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">alert(iNum01); <span class="comment">// 弹出6</span></span><br><span class="line">alert(iNum02); <span class="comment">// 弹出12</span></span><br><span class="line">alert(iNum03); <span class="comment">// 弹出24</span></span><br><span class="line"></span><br><span class="line">iNum01 = <span class="number">7</span>;</span><br><span class="line">iNum02 = <span class="number">13</span>;</span><br><span class="line"><span class="comment">//iNum03 = 25; // 报错,const定义的变量不可修改,const定义的变量是常量</span></span><br><span class="line"></span><br><span class="line">alert(iNum01)</span><br><span class="line">alert(iNum02); </span><br><span class="line">alert(iNum03);</span><br></pre></td></tr></table></figure>

<h3 id="6-2-箭头函数"><a href="#6-2-箭头函数" class="headerlink" title="6.2 箭头函数"></a>6.2 箭头函数</h3><p>可以把箭头函数理解成匿名函数的第二种写法，箭头函数的作用是可以在对象中绑定 this，解决了 JavaScript 中 this 指定混乱的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义函数的一般方式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">function fnRs(a,b)&#123;</span></span><br><span class="line"><span class="comment">    var rs = a + b;</span></span><br><span class="line"><span class="comment">    alert(rs);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">fnRs(1,2);        </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过匿名函数赋值来定义函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">var fnRs = function(a,b)&#123;</span></span><br><span class="line"><span class="comment">    var rs = a + b;</span></span><br><span class="line"><span class="comment">    alert(rs);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">fnRs(1,2);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过箭头函数的写法定义</span></span><br><span class="line"><span class="keyword">var</span> fnRs = <span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rs = a + b;</span><br><span class="line">    alert(rs);</span><br><span class="line">&#125;        </span><br><span class="line"><span class="comment">// fnRs(1,2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个参数可以省略小括号</span></span><br><span class="line"><span class="keyword">var</span> fnRs2 = <span class="function"><span class="params">a</span> =&gt;</span>&#123;</span><br><span class="line">    alert(a);</span><br><span class="line">&#125;</span><br><span class="line">fnRs2(<span class="string">'haha!'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数的作用，可以绑定对象中的this</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">'tom'</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    showName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;,<span class="number">1000</span>)            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.showName();</span><br></pre></td></tr></table></figure>

<h3 id="6-3-模块导入import和导出export"><a href="#6-3-模块导入import和导出export" class="headerlink" title="6.3 模块导入import和导出export"></a>6.3 模块导入import和导出export</h3><p>javascript 之前是没有模块的功能的，之前做 js 模块化开发，是用的一些 js 库来模拟实现的，在 ES6 中加入了模块的功能，和 python 语言一样，python 中一个文件就是一个模块，ES6 中，一个 js 文件就是一个模块，不同的是，js 文件中需要先导出 (export) 后，才能被其他 js 文件导入(import)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// model.js文件中导出</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>:<span class="string">'tom'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;person&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js文件夹中导入</span></span><br><span class="line"><span class="keyword">import</span> person <span class="keyword">from</span> <span class="string">'js/model.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js中使用模块</span></span><br><span class="line">person.name</span><br><span class="line">person.age</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面导出时使用了default关键字，如果不使用这个关键字，导入时需要加大括号：</span></span><br><span class="line"><span class="comment">import &#123;person&#125; from 'js/model.js'</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>目前ES6的模块功能需要在服务器环境下才可以运行。</p>
<h3 id="6-4-对象的简写"><a href="#6-4-对象的简写" class="headerlink" title="6.4 对象的简写"></a>6.4 对象的简写</h3><p>javascript 对象在 ES6 中可以做一些简写形式，了解这些简写形式，才能方便我们读懂一些在 javascript 代码中简写的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'李思'</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">var person = &#123;</span></span><br><span class="line"><span class="comment">    name:name,</span></span><br><span class="line"><span class="comment">    age:age,</span></span><br><span class="line"><span class="comment">    showname:function()&#123;</span></span><br><span class="line"><span class="comment">        alert(this.name);</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    showage:function()&#123;</span></span><br><span class="line"><span class="comment">        alert(this.age);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写成下面的形式</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    showname()&#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    showage()&#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.showname();</span><br><span class="line">person.showage();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>有了Pycharm，就卸载了Postman吧</title>
    <url>/%E6%9C%89%E4%BA%86Pycharm%EF%BC%8C%E5%B0%B1%E5%8D%B8%E8%BD%BD%E4%BA%86Postman%E5%90%A7/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 

<p><code>Web</code> 开发还在一手 <code>PyCharm</code> 一手 <code>Postman</code> 吗？快给电脑减负（卸载掉 <code>Postman</code>）吧！教你如何使用 <code>PyCharm</code> 替代 <code>Postman</code> 。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>在 <code>PyCharm</code> 的 <code>Professional</code>  版本中，有一个专门测试 <code>RESTful</code> 接口的工具「<code>HTTP client</code>」。也许你从未听说过，但是看了这篇文章后你将发现一个新世界。</p>
<h2 id="1-窗口化操作"><a href="#1-窗口化操作" class="headerlink" title="1.窗口化操作"></a>1.窗口化操作</h2><p>如果你习惯了 <code>Postman</code> ，无法突然适应发生的变化，可以采用此种方法。</p>
<h3 id="1-1-步骤"><a href="#1-1-步骤" class="headerlink" title="1.1 步骤"></a>1.1 步骤</h3><p>1) 点击顶部菜单栏中的 「<code>Tools</code>」 按钮</p>
<p>2) 点击下拉菜单中的 「<code>HTTP client</code>」</p>
<p>3) 点击菜单中的「<code>Test RESTful Web Service</code>」</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/httpclient.png" alt="HTTP client"></p>
<p><strong>下面是界面介绍：</strong></p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/httpclientdesc.png" alt="HTTP client提示"></p>
<h2 id="2-curl-操作"><a href="#2-curl-操作" class="headerlink" title="2.curl 操作"></a>2.curl 操作</h2><p>如果你是一个 <code>Linux</code> 习惯者，可以在黑窗口中来去自如，那么完全可以使用此种方法。</p>
<h3 id="2-1-步骤"><a href="#2-1-步骤" class="headerlink" title="2.1 步骤"></a>2.1 步骤</h3><p>1) 点击顶部菜单栏中的 「<code>Tools</code>」 按钮</p>
<p>2) 点击下拉菜单中的 「<code>HTTP client</code>」</p>
<p>3) 点击菜单中的「<code>Convert cURL to HTTP Request</code>」</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/curl.png" alt="HTTP client2"></p>
<p>4) 然后你会看到如下界面，再按要求填写完成之后，点击「<code>CONVERT</code>」进行转换。转换后会发现进入了一个脚本文件（详细请看后面内容介绍），点击 <code>url</code> 左侧的运行绿色按钮即可执行访问。</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/curldesc.png" alt="HTTP client2提示"></p>
<h2 id="3-编写脚本文件"><a href="#3-编写脚本文件" class="headerlink" title="3.编写脚本文件"></a>3.编写脚本文件</h2><p>如果是最新版本的 <code>PyCharm</code> ，官方强烈推荐你使用最新的方式，即类似于脚本的方法，直接编写访问用例。语法超级简单，就好像写接口文档一样。界面超级清爽，以下将会以常见的场景讲解使用方法。</p>
<h3 id="3-1-步骤"><a href="#3-1-步骤" class="headerlink" title="3.1 步骤"></a>3.1 步骤</h3><p>1) 首先创建3个文件：<code>http-client.env.json</code>(此文件为配置文件，文件名固定)、<code>http-client.private.env.json</code>(此文件为配置文件，文件名固定)、<code>xxx.http</code>(此为脚本文件，<code>xxx</code> 为自定义名称)</p>
<p>2) 配置环境文件 <code>http-client.env.json</code>。此文件是通用配置文件，比如有两套环境（开发和测试），可以使用如下的方式进行配置，在使用时随意切换：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"development"</span>: &#123;</span><br><span class="line">        <span class="attr">"host"</span>: <span class="string">"192.168.0.88"</span>,</span><br><span class="line">        <span class="attr">"id-value"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"password"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"my-var"</span>: <span class="string">"my-dev-value"</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"test"</span>: &#123;</span><br><span class="line">        <span class="attr">"host"</span>: <span class="string">"192.168.0.99"</span>,</span><br><span class="line">        <span class="attr">"id-value"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"password"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"my-var"</span>: <span class="string">"my-test-value"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.配置文件中的字段可以自定义，相当于变量。脚本文件中使用变量的语法是 <code></code>。字段名便是环境配置文件中定义的字段。</p>
<p>2.也许你好奇为什么 <code>username</code> 和 <code>password</code> 两个字段空着。那是因为如此私密的信息当然要保存在私密文件中啦 ~ 此时就用到了下一个文件 <code>http-client.private.env.json</code></p>
</blockquote>
<p>3) 配置私密环境文件  <code>http-client.private.env.json</code> 。此文件中保存账号密码等信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"development"</span>: &#123;</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">"admin"</span>,</span><br><span class="line">        <span class="attr">"password"</span>: <span class="string">"admin"</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"test"</span>: &#123;</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">"admin"</span>,</span><br><span class="line">        <span class="attr">"password"</span>: <span class="string">"admin"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4) 编写脚本文件。</p>
<blockquote>
<p>如果没有变量，没有账号密码等私密信息，完全可以省略上面的步骤，直接编写访问用例</p>
</blockquote>
<p>语法如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 此处是注释信息，采用井号</span><br><span class="line"># 访问方式，格式：请求方式 url</span><br><span class="line">GET http://&#123;&#123;host&#125;&#125;/es/stage_order_info/_search</span><br><span class="line"># 请求头,注意：请求头与url之间不许有空行</span><br><span class="line"><span class="attribute">Accept</span>: application/json</span><br><span class="line"># 引用变量的方法：&#123;&#123;xxx&#125;&#125;</span><br><span class="line"><span class="attribute">Authorization</span>: Basic &#123;&#123;username&#125;&#125; &#123;&#123;password&#125;&#125;</span><br><span class="line">...</span><br><span class="line"># 请求体，如果有的话</span><br><span class="line">...</span><br><span class="line"># 最后以三个井号结尾</span><br><span class="line"></span><br><span class="line">###</span><br></pre></td></tr></table></figure>

<h3 id="3-2-示例"><a href="#3-2-示例" class="headerlink" title="3.2 示例"></a>3.2 示例</h3><p>1) <code>GET</code> 方式请求：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET http://&#123;&#123;host&#125;&#125;/es/stage_order_info/_search</span><br><span class="line"><span class="attribute">Accept</span>: application/json</span><br><span class="line"><span class="attribute">Authorization</span>: Basic &#123;&#123;username&#125;&#125; &#123;&#123;password&#125;&#125;</span><br><span class="line"></span><br><span class="line">###</span><br></pre></td></tr></table></figure>

<p>2) <code>DELETE</code> 方式请求：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">DELETE http://&#123;&#123;host&#125;&#125;/es/ethanyantest</span><br><span class="line"><span class="attribute">Authorization</span>: Basic &#123;&#123;username&#125;&#125; &#123;&#123;password&#125;&#125;</span><br><span class="line"></span><br><span class="line">###</span><br></pre></td></tr></table></figure>

<p>3) <code>PUT</code> 方式请求：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT http://&#123;&#123;host&#125;&#125;/es/ethanyantest/_doc/1</span><br><span class="line"><span class="attribute">Authorization</span>: Basic &#123;&#123;username&#125;&#125; &#123;&#123;password&#125;&#125;</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;"testfield": "测试成功"&#125;</span><br><span class="line"></span><br><span class="line">###</span><br></pre></td></tr></table></figure>

<p>4) <code>POST</code> 方式请求：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST http://&#123;&#123;host&#125;&#125;/es/ethanyantest/_doc/1/_update</span><br><span class="line"><span class="attribute">Authorization</span>: Basic &#123;&#123;username&#125;&#125; &#123;&#123;password&#125;&#125;</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   "doc" : &#123;</span><br><span class="line">      "testfield" : [ "&#123;&#123;testfield&#125;&#125;" ],</span><br><span class="line">      "views": 0</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">###</span><br></pre></td></tr></table></figure>

<h3 id="3-3-运行方式"><a href="#3-3-运行方式" class="headerlink" title="3.3 运行方式"></a>3.3 运行方式</h3><p>1.点击请求地址前的运行按钮：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E8%BF%90%E8%A1%8C1.png" alt="运行方式1"></p>
<p>2.选择运行环境：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20200228213716238.png" alt="运行方式1"></p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>pycharm</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
        <tag>postman</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法之kd树</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B9%8Bkd%E6%A0%91/</url>
    <content><![CDATA[<center>Editor：闫玉良</center>

<p>上篇文章讲了 <code>K-近邻算法</code> ，但是引出了一个问题：</p>
<p>实现 <code>K-近邻算法</code> 时，<strong>主要考虑的问题是如何对训练数据进行快速 k 近邻搜索。</strong>这在特征空间维数大及训练数据容量大时尤其必要。<strong>k 近邻法最简单的实现是线性扫描（穷举搜索），即要计算输入实例与每一个训练实例的距离。计算并存储好以后，再查找 K 近邻。</strong>当训练集很大时，计算非常耗时。为了提高 <code>KNN</code> 搜索的效率，可以考虑使用特殊的结构存储训练数据，以减小计算距离的次数。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>为了解决上述问题，我们引入了 <code>kd</code> 树，下面来了解一下吧。</p>
<h2 id="1-初识-kd-树"><a href="#1-初识-kd-树" class="headerlink" title="1.初识 kd 树"></a>1.初识 kd 树</h2><p><strong><code>KNN</code></strong> 在每次预测一个点时，都需要计算训练数据集里每个点到这个点的距离，然后选出距离最近的 k 个点进行投票。<strong>当数据集很大时，这个计算成本非常高，针对 N 个样本，D 个特征的数据集，其算法复杂度为 <code>O(DN^2)</code></strong>。</p>
<p><strong>kd 树</strong>：为了避免每次都重新计算一遍距离，算法会把距离信息保存在一棵树里，这样就可以在每次计算之前从树里查询距离信息，尽量避免重新计算。其基本原理是，<strong>如果 A 和 B 距离很远，B 和 C 距离很近，那么 A 和 C 的距离也很远</strong>。有了这个信息，就可以在合适的时候跳过距离远的点。这样优化后的算法复杂度可降低到 <strong><code>O(DNlog(N))</code></strong>。</p>
<blockquote>
<p>感兴趣的读者可参阅论文：Bentley，J.L.，Communications of the ACM（1975）。</p>
</blockquote>
<p>1989年，另外一种称为 <strong><code>Ball Tree</code></strong> 的算法，在 <code>kd Tree</code> 的基础上对性能进一步进行了优化。</p>
<blockquote>
<p>感兴趣的读者可以搜索 <strong>Five balltree construction algorithms</strong> 来了解详细的算法信息。</p>
</blockquote>
<h2 id="2-树的构建"><a href="#2-树的构建" class="headerlink" title="2.树的构建"></a>2.树的构建</h2><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190213191654082.png" alt="kd树1"></p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190213191739222.png" alt="kd2"></p>
<p>上方左侧图片中：黄色的点作为根节点，上面的点归左子树，下面的点归右子树。接下来再不断地划分，如上方右图，分割的那条线叫做分割超平面（splitting hyperplane），在一维中是一个点，二维中是线，三维的是面。</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219101722826.png" alt="kd3"></p>
<p>黄色节点就是 <code>Root</code> 节点，下一层是红色，再下一层是绿色，再下一层是蓝色。</p>
<h3 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h3><p>（1）构造根结点，使根结点对应于 k 维空间中包含所有实例点的超矩形区域；</p>
<p>（2）通过递归的方法，不断地对 k 维空间进行切分，生成子结点。在超矩形区域上选择一个坐标轴和在此坐标轴上的一个切分点，确定一个超平面，这个超平面通过选定的切分点并垂直于选定的坐标轴，将当前超矩形区域切分为左右两个子区域（子结点）；这时，实例被分到两个子区域。</p>
<p>（3）上述过程直到子区域内没有实例时终止（终止时的结点为叶结点）。在此过程中，将实例保存在相应的结点上。</p>
<p>（4）通常，循环的选择坐标轴对空间切分，选择训练实例点在坐标轴上的中位数为切分点，这样得到的 <code>kd树</code> 是平衡的</p>
<blockquote>
<p>平衡二叉树：它是一棵空树，或其左子树和右子树的深度之差的绝对值不超过1，且它的左子树和右子树都是平衡二叉树。</p>
</blockquote>
<p> <code>kd树</code> 中每个节点是一个向量，和二叉树按照数的大小划分不同的是， <code>kd树</code> 每层需要选定向量中的某一维，然后根据这一维按左小右大的方式划分数据。在构建 <code>kd树</code> 时，关键需要解决2个问题：</p>
<p><strong>（1）选择向量的哪一维进行划分；</strong></p>
<p><strong>（2）如何划分数据；</strong></p>
<p>第一个问题简单的解决方法可以是随机选择某一维或按顺序选择，但是<strong>更好的方法应该是在数据比较分散的那一维进行划分（分散的程度可以根据方差来衡量）</strong>。好的划分方法可以使构建的树比较平衡，可以每次选择中位数来进行划分，这样问题2也得到了解决。</p>
<h2 id="3-最近邻域搜索（Nearest-Neighbor-Lookup）"><a href="#3-最近邻域搜索（Nearest-Neighbor-Lookup）" class="headerlink" title="3.最近邻域搜索（Nearest-Neighbor Lookup）"></a>3.最近邻域搜索（Nearest-Neighbor Lookup）</h2><p><code>kd 树</code>(K-dimension tree) 是<strong>一种对 k 维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。</strong><code>kd树</code> 是一种二叉树，表示对 k 维空间的一个划分，<strong>构造 <code>kd树</code> 相当于不断地用垂直于坐标轴的超平面将 K 维空间切分，构成一系列的 K 维超矩形区域</strong>。<code>kd树</code> 的每个结点对应于一个 k 维超矩形区域。<strong>利用 <code>kd树</code> 可以省去对大部分数据点的搜索，从而减少搜索的计算量。</strong> </p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190213223817957.png" alt="kd4"></p>
<p>接下来需要引入一个概念「<strong>最近邻域搜索</strong>」，类比「二分查找」：给出一组数据：[9 1 4 7 2 5 0 3 8]，要查找8。如果挨个查找（线性扫描），那么将会把数据集都遍历一遍。而如果排一下序那数据集就变成了：[0 1 2 3 4 5 6 7 8 9]，按前一种方式我们进行了很多没有必要的查找，现在如果我们以5为分界点，那么数据集就被划分为了左右两个 <code>簇</code> ： [0 1 2 3 4] 和 [6 7 8 9]。</p>
<p>因此，根本就没有必要进入第一个簇，可以直接进入第二个簇进行查找。把二分查找中的数据点换成 k 维数据点，这样的划分就变成了用超平面对 k 维空间的划分。空间划分就是对数据点进行分类，「挨得近」的数据点就在一个空间里面。</p>
<h2 id="4-示例"><a href="#4-示例" class="headerlink" title="4.示例"></a>4.示例</h2><h3 id="4-1-树的建立"><a href="#4-1-树的建立" class="headerlink" title="4.1 树的建立"></a>4.1 树的建立</h3><p>给定一个二维空间数据集：T={(2,3),(5,4),(9,6),(4,7),(8,1),(7,2)}，构造一个平衡 <code>kd树</code>。</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219102142984.png" alt="kd5"></p>
<p>（1）思路引导：</p>
<p>根结点对应包含数据集 T 的矩形，选择 x(1) 轴，6个数据点的 x(1) 坐标中位数是6，这里选最接近的 (7,2) 点，以平面 x(1)=7 将空间分为左、右两个子矩形（子结点）；接着左矩形以 x(2)=4 分为两个子矩形（左矩形中{(2,3),(5,4),(4,7)}点的 x(2) 坐标中位数正好为4），右矩形以 x(2)=6 分为两个子矩形，如此递归，最后得到如下图所示的特征空间划分和 <code>kd树</code>。</p>
<blockquote>
<p>「百度百科」中位数，又称中点数，中值。中位数是按顺序排列的一组数据中居于中间位置的数，即在这组数据中，有一半的数据比他大，有一半的数据比他小</p>
</blockquote>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219102409567.png" alt="kd6"></p>
<h3 id="4-2-最近领域的搜索"><a href="#4-2-最近领域的搜索" class="headerlink" title="4.2 最近领域的搜索"></a>4.2 最近领域的搜索</h3><p>假设标记为星星的点是 test point， 绿色的点是找到的近似点，在回溯过程中，需要用到一个队列，存储需要回溯的点，在判断其他子节点空间中是否有可能有距离查询点更近的数据点时，做法是以查询点为圆心，以当前的最近距离为半径画圆，这个圆称为候选超球（candidate hypersphere），如果圆与回溯点的轴相交，则需要将轴另一边的节点都放到回溯队列里面来。</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190213224152601.png" alt="kd7"></p>
<p>样本集{(2,3),(5,4), (9,6), (4,7), (8,1), (7,2)}</p>
<h4 id="4-2-1-查询点为-2-1-3-1"><a href="#4-2-1-查询点为-2-1-3-1" class="headerlink" title="4.2.1 查询点为(2.1,3.1)"></a>4.2.1 查询点为(2.1,3.1)</h4><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190213224414342.png" alt="kd8"></p>
<p>星号表示要查询的点（2.1,3.1）。通过二叉搜索，顺着搜索路径很快就能找到最邻近的近似点，也就是叶子节点（2,3）。而找到的叶子节点并不一定就是最邻近的，最邻近肯定距离查询点更近，应该位于以查询点为圆心且通过叶子节点的圆域内。为了找到真正的最近邻，还需要进行相关的「回溯」操作。也就是说，算法首先沿搜索路径反向查找是否有距离查询点更近的数据点。</p>
<p>首先进行二叉树搜索：在 (7,2) 点测试到达 (5,4) ，在 (5,4) 点测试到达 (2,3) ，然后 <code>search_path</code> 中的结点为 &lt;(7,2),(5,4), (2,3)&gt; ，从 <code>search_path</code> 中取出 (2,3) 作为当前最佳结点 <code>nearest</code>，<code>dist</code> 为0.141；</p>
<p>然后回溯至 (5,4)，以 (2.1,3.1) 为圆心，以 dist=0.141 为半径画一个圆，并不和超平面 y=4 相交，如上图，所以不必跳到结点 (5,4) 的右子空间去搜索，因为右子空间中不可能有更近样本点了。</p>
<p>于是再回溯至 (7,2) ，同理，以 (2.1,3.1) 为圆心，以 dist=0.141 为半径画一个圆并不和超平面 x=7 相交，所以也不用跳到结点 (7,2) 的右子空间去搜索。</p>
<p>至此，<code>search_path</code> 为空，结束整个搜索，返回 nearest(2,3) 作为(2.1,3.1) 的最近邻点，最近距离为 0.141。</p>
<h4 id="4-2-2-查询点为-2-4-5"><a href="#4-2-2-查询点为-2-4-5" class="headerlink" title="4.2.2 查询点为(2,4.5)"></a>4.2.2 查询点为(2,4.5)</h4><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219103050940.png" alt="kd9"></p>
<p>类比上个例子，首先进行二叉树搜索：在 (7,2) 处测试到达 (5,4)，在 (5,4) 处测试到达 (4,7)【优先选择在本域搜索】，然后 <code>search_path</code> 中的结点为 &lt;(7,2),(5,4), (4,7)&gt;，从<code>search_path</code> 中取出 (4,7 ) 作为当前最佳结点 <code>nearest</code>，<code>dist</code>为3.202；</p>
<p>然后回溯至 (5,4)，以 (2,4.5) 为圆心，以 dist=3.202 为半径画一个圆与超平面 y=4 相交，所以需要跳到 (5,4) 的左子空间去搜索。还要将 (2,3) 加入到 <code>search_path</code> 中，现在 <code>search_path</code> 中的结点为 &lt;(7,2),(2, 3)&gt;；另外，(5,4) 与 (2,4.5) 的距离为 3.04 &lt; dist = 3.202，所以将 (5,4) 赋给 <code>nearest</code>，并且 dist=3.04。</p>
<p>回溯至 (2,3) 。(2,3) 是叶子节点，直接判断 (2,3) 是否离 (2,4.5) 更近，计算得到距离为1.5，所以 <code>nearest</code> 更新为(2,3)，<code>dist</code> 更新为(1.5)</p>
<p>回溯至 (7,2)，同理，以 (2,4.5) 为圆心，以 dist=1.5 为半径画一个圆并不和超平面 x=7 相交, 所以不用跳到结点 (7,2) 的右子空间去搜索。</p>
<p>至此，<code>search_path</code> 为空，结束整个搜索，返回 nearest(2,3) 作为(2,4.5) 的最近邻点，最近距离为1.5。</p>
<h4 id="4-2-3-总结"><a href="#4-2-3-总结" class="headerlink" title="4.2.3 总结"></a>4.2.3 总结</h4><p>首先通过二叉树搜索（比较待查询节点和分裂节点的分裂维的值，小于等于就进入左子树分支，大于就进入右子树分支直到叶子结点），顺着「搜索路径」很快能找到最近邻的近似点，也就是与待查询点处于同一个子空间的叶子结点；然后再回溯搜索路径，并判断搜索路径上的结点的其他子结点空间中是否可能有距离查询点更近的数据点。如果有可能，则需要跳到其他子结点空间中去搜索（将其他子结点加入到搜索路径）。重复这个过程直到搜索路径为空。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法之K-近邻算法</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B9%8BK-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<center>Editor：闫玉良</center>

<p><code>K Nearest Neighbor</code> 算法又叫 <code>KNN</code> 算法，此算法最早是由 <code>Cover</code> 和 <code>Hart</code> 提出的一种分类算法，是机器学习里面一个经典之作， 总体来说 <code>KNN</code> 算法是相对比较容易理解的。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="1.算法简介"></a>1.算法简介</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>如果一个样本在特征空间中的 <strong>k 个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别</strong>，则该样本也属于这个类别。</p>
<p><strong>实现流程：</strong></p>
<p>1）计算已知类别数据集中的点与当前点之间的距离</p>
<p>2）按距离递增次序排序</p>
<p>3）选取与当前点距离最小的 <code>k</code> 个点</p>
<p>4）统计前 <code>k</code> 个点所在的类别出现的频率</p>
<p>5）返回前 <code>k</code> 个点出现频率最高的类别作为当前点的预测分类</p>
<h3 id="1-2-欧式距离"><a href="#1-2-欧式距离" class="headerlink" title="1.2 欧式距离"></a>1.2 欧式距离</h3><p>两个样本的距离可以通过如下公式计算，又叫<strong>欧式距离</strong> 。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/1.3%20%E6%AC%A7%E5%BC%8F%E8%B7%9D%E7%A6%BB1.png" alt="欧式距离1"></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/1.4%20%E6%AC%A7%E5%BC%8F%E8%B7%9D%E7%A6%BB2.png" alt="欧式距离2"></p>
<h3 id="1-3-示例"><a href="#1-3-示例" class="headerlink" title="1.3 示例"></a>1.3 示例</h3><p>假设我们现在有几部电影</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/image-20190316204421392.png" alt="示例1"></p>
<p>其中 <code>?</code> 号电影不知道类别，如何去预测？我们可以利用K近邻算法的思想</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/image-20190316204448303.png" alt="示例2"></p>
<p>分别计算每个电影和被预测电影的距离，然后求解</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/image-20190316204517137.png" alt="示例3"></p>
<h2 id="2-KNN-api-初步使用"><a href="#2-KNN-api-初步使用" class="headerlink" title="2.KNN api 初步使用"></a>2.KNN api 初步使用</h2><h3 id="2-1-Scikit-learn工具介绍"><a href="#2-1-Scikit-learn工具介绍" class="headerlink" title="2.1 Scikit-learn工具介绍"></a>2.1 Scikit-learn工具介绍</h3><ul>
<li><code>Python</code> 语言的机器学习工具</li>
<li><code>Scikit-learn</code> 包括许多知名的机器学习算法的实现</li>
<li><code>Scikit-learn</code> 文档完善，容易上手，丰富的 <code>API</code></li>
<li>目前稳定版本0.19.1</li>
</ul>
<h3 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install scikit-learn==0.19.1</span><br></pre></td></tr></table></figure>

<p>安装好之后可以通过以下命令查看是否安装成功</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>安装 <code>scikit-learn</code> 需要 <code>Numpy</code>,  <code>Scipy</code> 等库。</p>
<h3 id="2-3-包含内容"><a href="#2-3-包含内容" class="headerlink" title="2.3 包含内容"></a>2.3 包含内容</h3><ul>
<li>分类、聚类、回归</li>
<li>特征工程</li>
<li>模型选择、调优</li>
</ul>
<h3 id="2-4-KNN-算法-api"><a href="#2-4-KNN-算法-api" class="headerlink" title="2.4 KNN 算法 api"></a>2.4 KNN 算法 api</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sklearn.neighbors.KNeighborsClassifier(n_neighbors=5)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>n_neighbors</code>：<code>int</code>,可选（默认= 5），<code>k_neighbors</code> 查询默认使用的邻居数</p>
</blockquote>
<h3 id="2-5-示例"><a href="#2-5-示例" class="headerlink" title="2.5 示例"></a>2.5 示例</h3><h4 id="2-5-1-步骤分析"><a href="#2-5-1-步骤分析" class="headerlink" title="2.5.1 步骤分析"></a>2.5.1 步骤分析</h4><p>1.获取数据集</p>
<p>2.数据基本处理（该案例中省略）</p>
<p>3.特征工程（该案例中省略）</p>
<p>4.机器学习</p>
<p>5.模型评估（该案例中省略）</p>
<h4 id="2-5-2-实现"><a href="#2-5-2-实现" class="headerlink" title="2.5.2 实现"></a>2.5.2 实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="comment"># 构造数据集</span></span><br><span class="line">x = [[<span class="number">0</span>], [<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]]</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># 机器学习 -- 模型训练</span></span><br><span class="line"><span class="comment"># 实例化API</span></span><br><span class="line">estimator = KNeighborsClassifier(n_neighbors=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 使用fit方法进行训练</span></span><br><span class="line">estimator.fit(x, y)</span><br><span class="line">estimator.predict([[<span class="number">1</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="3-距离度量"><a href="#3-距离度量" class="headerlink" title="3.距离度量"></a>3.距离度量</h2><h3 id="3-1-欧式距离-Euclidean-Distance"><a href="#3-1-欧式距离-Euclidean-Distance" class="headerlink" title="3.1 欧式距离(Euclidean Distance)"></a>3.1 欧式距离(Euclidean Distance)</h3><p>欧氏距离是最容易直观理解的距离度量方法，我们小学、初中和高中接触到的两个点在空间中的距离一般都是指欧氏距离。</p>
<p>举例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>]];</span><br><span class="line">经计算得:</span><br><span class="line">d = <span class="number">1.4142</span>    <span class="number">2.8284</span>    <span class="number">4.2426</span>    <span class="number">1.4142</span>    <span class="number">2.8284</span>    <span class="number">1.4142</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-曼哈顿距离-Manhattan-Distance"><a href="#3-2-曼哈顿距离-Manhattan-Distance" class="headerlink" title="3.2 曼哈顿距离(Manhattan Distance)"></a>3.2 曼哈顿距离(Manhattan Distance)</h3><p>在曼哈顿街区要从一个十字路口开车到另一个十字路口，驾驶距离显然不是两点间的直线距离。这个实际驾驶距离就是「曼哈顿距离」。曼哈顿距离也称为「城市街区距离」(City Block distance)。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/1.5%20%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB.png" alt="曼哈顿距离1"></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/1.6%20%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB.png" alt="曼哈顿距离2"></p>
<p>举例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>]];</span><br><span class="line">经计算得:</span><br><span class="line">d =   <span class="number">2</span>     <span class="number">4</span>     <span class="number">6</span>     <span class="number">2</span>     <span class="number">4</span>     <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-切比雪夫距离-Chebyshev-Distance"><a href="#3-3-切比雪夫距离-Chebyshev-Distance" class="headerlink" title="3.3 切比雪夫距离 (Chebyshev Distance)"></a>3.3 切比雪夫距离 (Chebyshev Distance)</h3><p>国际象棋中，国王可以直行、横行、斜行，所以国王走一步可以移动到相邻8个方格中的任意一个。国王从格子(x1,y1)走到格子(x2,y2)最少需要多少步？这个距离就叫切比雪夫距离。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/1.7%20%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB.png" alt="切比雪夫距离1"></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/1.8%20%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB.png" alt="切比雪夫距离2"></p>
<p>举例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>]];</span><br><span class="line">经计算得:</span><br><span class="line">d =   <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-闵可夫斯基距离-Minkowski-Distance"><a href="#3-4-闵可夫斯基距离-Minkowski-Distance" class="headerlink" title="3.4 闵可夫斯基距离(Minkowski Distance)"></a>3.4 闵可夫斯基距离(Minkowski Distance)</h3><p>闵氏距离不是一种距离，而是一组距离的定义，是对多个距离度量公式的概括性的表述。</p>
<p>两个n维变量a(x11,x12,…,x1n)与b(x21,x22,…,x2n)间的闵可夫斯基距离定义为：</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/image-20190225182628694.png" alt="闵可夫斯基距离"></p>
<p>其中p是一个变参数：</p>
<p>当p=1时，就是曼哈顿距离；</p>
<p>当p=2时，就是欧氏距离；</p>
<p>当p→∞时，就是切比雪夫距离。</p>
<p>根据p的不同，闵氏距离可以表示某一 类/种 的距离。</p>
<p><strong>小结：</strong></p>
<p>1.闵氏距离，包括曼哈顿距离、欧氏距离和切比雪夫距离都存在明显的缺点:</p>
<p>比如： 二维样本(身高[单位:cm],体重[单位:kg]),现有三个样本：a(180,50)，b(190,50)，c(180,60)。</p>
<p>a与b的闵氏距离（无论是曼哈顿距离、欧氏距离或切比雪夫距离）等于a与c的闵氏距离。但实际上身高的10cm并不能和体重的10kg划等号。</p>
<p><strong>2.闵氏距离的缺点：</strong></p>
<p> <strong>(1)将各个分量的量纲(scale)，也就是“单位”相同的看待了;</strong></p>
<p> <strong>(2)未考虑各个分量的分布（期望，方差等）可能是不同的。</strong></p>
<h3 id="3-5-标准化欧氏距离-Standardized-EuclideanDistance"><a href="#3-5-标准化欧氏距离-Standardized-EuclideanDistance" class="headerlink" title="3.5 标准化欧氏距离 (Standardized EuclideanDistance)"></a>3.5 标准化欧氏距离 (Standardized EuclideanDistance)</h3><p>标准化欧氏距离是针对欧氏距离的缺点而作的一种改进。</p>
<p>思路：既然数据各维分量的分布不一样，那先将各个分量都「标准化」到均值、方差相等。假设样本集X的均值(mean)为m，标准差(standard deviation)为s，X的「标准化变量」表示为：</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/image-20190213184012294.png" alt="image-20190213184012294"></p>
<p>如果将方差的倒数看成一个权重，也可称之为加权欧氏距离(Weighted Euclidean distance)。</p>
<p>举例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>]];（假设两个分量的标准差分别为<span class="number">0.5</span>和<span class="number">1</span>）</span><br><span class="line">经计算得:</span><br><span class="line">d =   <span class="number">2.2361</span>    <span class="number">4.4721</span>    <span class="number">6.7082</span>    <span class="number">2.2361</span>    <span class="number">4.4721</span>    <span class="number">2.2361</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-余弦距离-Cosine-Distance"><a href="#3-6-余弦距离-Cosine-Distance" class="headerlink" title="3.6 余弦距离(Cosine Distance)"></a>3.6 余弦距离(Cosine Distance)</h3><p>几何中，夹角余弦可用来衡量两个向量方向的差异；机器学习中，借用这一概念来衡量样本向量之间的差异。</p>
<ul>
<li>二维空间中向量A(x1,y1)与向量B(x2,y2)的夹角余弦公式：</li>
</ul>
<p><img src="https://github.com/EthanYan6/pic/raw/master/14200251_RZRZ.png" alt="余弦距离"></p>
<ul>
<li>两个n维样本点a(x11,x12,…,x1n)和b(x21,x22,…,x2n)的夹角余弦为：</li>
</ul>
<p><img src="https://github.com/EthanYan6/pic/raw/master/14200252_SE1M.png" alt="余弦距离"></p>
<p>即：</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/14200252_tITR.png" alt="余弦距离"></p>
<p>夹角余弦取值范围为[-1,1]。余弦越大表示两个向量的夹角越小，余弦越小表示两向量的夹角越大。当两个向量的方向重合时余弦取最大值1，当两个向量的方向完全相反余弦取最小值-1。</p>
<p>举例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X=[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">-4</span>]]</span><br><span class="line">经计算得:</span><br><span class="line">d =   <span class="number">0.9487</span>    <span class="number">0.9191</span>   <span class="number">-0.5145</span>    <span class="number">0.9965</span>   <span class="number">-0.7593</span>   <span class="number">-0.8107</span></span><br></pre></td></tr></table></figure>

<h3 id="3-7-汉明距离-Hamming-Distance-【了解】"><a href="#3-7-汉明距离-Hamming-Distance-【了解】" class="headerlink" title="3.7 汉明距离(Hamming Distance)【了解】"></a>3.7 汉明距离(Hamming Distance)【了解】</h3><p>两个等长字符串s1与s2的汉明距离为：将其中一个变为另外一个所需要作的最小字符替换次数。</p>
<p>另外还有一些距离，但是并不需要详细学习：<strong>杰卡德距离(Jaccard Distance)</strong>、<strong>马氏距离(Mahalanobis Distance)</strong></p>
<h2 id="4-k-值的选择"><a href="#4-k-值的选择" class="headerlink" title="4.k 值的选择"></a>4.k 值的选择</h2><p><strong>K值过小</strong>：</p>
<p> 容易受到异常点的影响</p>
<p><strong>k值过大：</strong></p>
<p> 受到样本均衡的问题</p>
<hr>
<p><strong>K值选择问题，李航博士的「统计学习方法」一书中所说：</strong></p>
<p>1) 选择较小的K值，就相当于用较小的领域中的训练实例进行预测，「学习」近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是「学习」的估计误差会增大，换句话说，<strong>K值的减小就意味着整体模型变得复杂，容易发生过拟合；</strong></p>
<p>2) 选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，<strong>与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。</strong></p>
<p>3) K=N（N为训练样本个数），则完全不足取，因为此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的类，模型过于简单，忽略了训练实例中大量有用信息。</p>
<p>在实际应用中，K值一般取一个比较小的数值，例如采用交叉验证法（简单来说，就是把训练数据在分成两组:训练集和验证集）来选择最优的K值。对这个简单的分类器进行泛化，用核方法把这个线性模型扩展到非线性的情况，具体方法是把低维数据集映射到高维特征空间。</p>
<hr>
<p><strong>近似误差</strong>：对现有训练集的训练误差，关注训练集，如果近似误差过小可能会出现过拟合的现象，对现有的训练集能有很好的预测，但是对未知的测试样本将会出现较大偏差的预测。模型本身不是最接近最佳模型。</p>
<p><strong>估计误差</strong>：可以理解为对测试集的测试误差，关注测试集，估计误差小说明对未知数据的预测能力好，模型本身最接近最佳模型。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法之欠拟合和过拟合</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B9%8B%E6%AC%A0%E6%8B%9F%E5%90%88%E5%92%8C%E8%BF%87%E6%8B%9F%E5%90%88/</url>
    <content><![CDATA[<center>Editor：闫玉良</center>

<blockquote>
<p><strong>引言：</strong>机器学习的基本问题是利用模型对数据进行拟合，学习的目的并非是对有限训练集进行正确预测，而是对未曾在训练集合出现的样本能够正确预测。模型对训练集数据的误差称为经验误差，对测试集数据的误差称为泛化误差。模型对训练集以外样本的预测能力就称为模型的泛化能力，追求这种泛化能力始终是机器学习的目标。过拟合和欠拟合是导致模型泛化能力不高的两种常见原因，都是模型学习能力与数据复杂度之间失配的结果。</p>
</blockquote>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p><strong>过拟合：</strong>一个假设<strong>在训练数据上能够获得比其他假设更好的拟合， 但是在测试数据集上却不能很好地拟合数据</strong>，此时认为这个假设出现了过拟合的现象。(模型过于复杂)</p>
<p><strong>欠拟合：</strong>一个假设<strong>在训练数据上不能获得更好的拟合，并且在测试数据集上也不能很好地拟合数据</strong>，此时认为这个假设出现了欠拟合的现象。(模型过于简单)</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3mkYxf.png" alt="欠拟合过拟合图示.png"></p>
<p><strong>那么是什么原因导致模型复杂？</strong></p>
<p>线性回归进行训练学习的时候，模型会变得复杂，因为线性回归有两种关系（线性关系和非线性关系），非线性关系的数据，存在很多无用的特征，或者现实中的事物特征跟目标值的关系并不是简单的线性关系。</p>
<h2 id="2-原因以及解决办法"><a href="#2-原因以及解决办法" class="headerlink" title="2.原因以及解决办法"></a>2.原因以及解决办法</h2><h3 id="2-1-欠拟合"><a href="#2-1-欠拟合" class="headerlink" title="2.1 欠拟合"></a>2.1 欠拟合</h3><p><strong>原因：</strong>学习到数据的特征过少</p>
<p><strong>解决办法：</strong></p>
<p><strong>1）添加其他特征项。</strong>有时模型出现欠拟合，是因为特征项不够。可以通过添加其他特征项来很好地解决。例如「组合」、「泛化」、「相关性」三类特征是特征添加的重要手段，无论在什么场景，都可以照葫芦画瓢，总会得到意想不到的效果。除上面的特征之外，「上下文特征」、「平台特征」等等，都可以作为特征添加的首选项。</p>
<p><strong>2）添加多项式特征</strong>。此操作在机器学习算法里面用的很普遍，例如将线性模型通过添加二次项或者三次项使模型泛化能力更强。</p>
<h3 id="2-2-过拟合"><a href="#2-2-过拟合" class="headerlink" title="2.2 过拟合"></a>2.2 过拟合</h3><p><strong>原因：</strong>原始特征过多，存在一些嘈杂特征，。模型过于复杂是因为模型尝试去兼顾各个测试数据点</p>
<p><strong>解决办法：</strong></p>
<p>1）重新清洗数据。导致过拟合的一个原因也有可能是数据不纯。此类情况就需要重新清洗数据。</p>
<p>2）增大数据的训练量。还有一个原因就是用于训练的数据量太小，即训练数据占总数据的比例过小。</p>
<p><strong>3）正则化</strong>（下面我们会详细讲解）</p>
<p>4）减少特征维度，防止<strong>维灾难</strong>（文章末尾会讲解）</p>
<h3 id="2-3-图解过拟合和欠拟合"><a href="#2-3-图解过拟合和欠拟合" class="headerlink" title="2.3 图解过拟合和欠拟合"></a>2.3 图解过拟合和欠拟合</h3><p><img src="https://s2.ax1x.com/2020/02/20/3mmVGd.png" alt="模型复杂.png"></p>
<h2 id="3-正则化"><a href="#3-正则化" class="headerlink" title="3.正则化"></a>3.正则化</h2><h3 id="3-1-什么是正则化"><a href="#3-1-什么是正则化" class="headerlink" title="3.1 什么是正则化"></a>3.1 什么是正则化</h3><p>数据提供的特征可能影响模型复杂度或者这个特征的数据点异常较多，所以算法在学习时，应尽量减少这个特征的影响（甚至删除这个特征的影响），这就是正则化。</p>
<p>简单来说，正则化是一种为了减小<strong>测试误差</strong>而发生的行为(有时候会增加<strong>训练误差</strong>)。在构造机器学习模型时，最终目的是让模型在面对新数据的时候，可以有很好的表现。当你用比较复杂的模型比如神经网络，去拟合数据时，很容易出现过拟合现象(训练集表现很好，测试集表现较差)，这会导致模型的泛化能力下降，此时，我们就需要使用<strong>正则化</strong>，降低模型的复杂度。</p>
<p>在这里针对回归，选择正则化。但是对于其他机器学习算法如分类算法来说也会出现这样的问题，除了一些算法本身作用之外（决策树、神经网络），更多情况下也会自己做特征选择，包括删除、合并一些特征。</p>
<h3 id="3-2-正则化类别"><a href="#3-2-正则化类别" class="headerlink" title="3.2 正则化类别"></a>3.2 正则化类别</h3><p><strong>L1正则化</strong></p>
<ul>
<li>作用：可以使得其中一些 <code>W</code> 的值直接为0，删除这个特征的影响</li>
<li><code>LASSO</code> 回归</li>
</ul>
<p><strong>L2正则化</strong></p>
<ul>
<li>作用：可以使得其中一些 <code>W</code> 的值都很小，接近于0，削弱某个特征的影响</li>
<li>优点：越小的参数说明模型越简单，越简单的模型则越不容易产生过拟合现象</li>
<li><code>Ridge</code> 回归</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/20/3mmHSA.png" alt="正则化.png"></p>
<p><strong>注：</strong>调整时候，算法并不知道某个特征影响，而是去调整参数得出优化的结果</p>
<h2 id="4-维灾难"><a href="#4-维灾难" class="headerlink" title="4.维灾难"></a>4.维灾难</h2><h3 id="4-1-什么是维灾难"><a href="#4-1-什么是维灾难" class="headerlink" title="4.1 什么是维灾难"></a>4.1 什么是维灾难</h3><p>随着维度的增加，分类器性能逐步上升，到达某点之后，其性能便逐渐下降</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3mQSH0.png" alt="维灾难1.png"></p>
<p>有一系列的图片，每张图片的内容可能是猫也可能是狗。我们需要构造一个分类器，使其能够对猫、狗自动的分类。首先，要寻找到一些能够描述猫和狗的特征，这样我们的分类算法就可以利用这些特征去识别物体。猫和狗的皮毛颜色可能是一个很好的特征。考虑到红绿蓝这三种构成图像的基色，制作了一个简单的 <code>Fisher</code> 分类器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If  0.5*red + 0.3*green + 0.2*blue &gt; 0.6 : return cat;</span><br><span class="line">    else return dog;</span><br></pre></td></tr></table></figure>

<p>只使用颜色特征可能无法得到一个足够准确的分类器，那么不妨加入一些诸如图像纹理(图像灰度值在其 <code>X</code>、<code>Y</code> 方向的导数 <code>dx</code>、<code>dy</code>)，这样就有5个特征( <code>Red</code>、<code>Blue</code>、<code>Green</code>、<code>dx</code>、<code>dy</code>)来设计我们的分类器：</p>
<p>也许分类器准确率依然无法达到要求，这就需要加入更多的特征，如此下去，可能会得到上百个特征。那是不是我们的分类器性能会随着特征数量的增加而逐步提高呢？答案也许有些让人沮丧。事实上，当特征数量达到一定规模后，分类器的性能是在下降的。</p>
<p><strong>随着维度(特征数量)的增加，分类器的性能却下降了，这就是维灾难</strong></p>
<h3 id="4-2-维数灾难与过拟合"><a href="#4-2-维数灾难与过拟合" class="headerlink" title="4.2 维数灾难与过拟合"></a>4.2 维数灾难与过拟合</h3><p>假设猫和狗图片的数量是有限的(样本数量总是有限的)，比如有10张图片，接下来就用这仅有的10张图片训练我们的分类器。</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3mlROA.png" alt="i维灾难2.png"></p>
<p>增加一个特征，比如绿色，这样特征维数扩展到了2维：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3mlIFf.png" alt="维灾难3.png"></p>
<p>但在增加一个特征后，我们依然无法找到一条简单的直线将它们有效分类。不妨再增加一个特征，比如蓝色，扩展到3维特征空间：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3m1FX9.png" alt="维灾难4.png"></p>
<p>在3维特征空间中，就很容易找到一个分类平面，将训练集上的猫和狗进行有效的分类：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3m1d1g.png" alt="维灾难5.png"></p>
<p>这样看来，在高维空间中，似乎分类器性能更优。</p>
<p>从1维到3维，给我们的感觉是：维数越高，分类性能越优。然而，维数过高将导致一定的问题：在一维特征空间下，假设一个维度的宽度为5个单位，这样样本密度为10/5=2；在2维特征空间下，10个样本所分布的空间大小25，这样样本密度为10/25=0.4；在3维特征空间下，10个样本分布的空间大小为125，样本密度就变为了10/125=0.08。</p>
<p>如果继续增加特征数量，维度也会继续增加，样本将变得越来越稀疏。此时，虽然更容易找到一个超平面将目标分开，但如果我们将高维空间向低维空间投影，高维空间隐藏的问题也会显现出来：<strong>过多的特征导致过拟合现象</strong>，即训练集上表现良好，但是对新数据缺乏泛化能力。</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3m3UV1.png" alt="维灾难7.png"></p>
<p><strong>高维空间训练形成的线性分类器，相当于在低维空间的一个复杂的非线性分类器</strong>，这种分类器过多的强调了训练集的准确率甚至于对一些 错误 或者 异常 的数据也进行了学习，而正确的数据却无法覆盖整个特征空间。为此，这样得到的分类器在对新数据进行预测时将会出现错误。这种现象称之为<strong>过拟合</strong>，同时也是维灾难的直接体现。</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3m3TMQ.png" alt="维灾难8.png"></p>
<p>简单的线性分类器在训练数据上的表现不如非线性分类器，但由于线性分类器的学习过程中对噪声不像非线性分类器那样敏感，因此对新数据具备更优的泛化能力。换句话说，通过使用更少的特征，避免了维数灾难的发生(也即避免了高维情况下的过拟合)</p>
<p><strong>由于高维而带来的数据稀疏性问题：</strong>假设有一个特征，它的取值范围 <code>D</code> 在0到1之间均匀分布，并且对狗和猫来说其值都是唯一的。现在利用这个特征来设计分类器。</p>
<p>如果训练数据覆盖了取值范围的20%(e.g 0到0.2)，那么所使用的训练数据就占总样本量的20%。上升到二维情况下，覆盖二维特征空间20%的面积，则需要在每个维度上取得45%的取值范围。在三维情况下，要覆盖特征空间20%的体积，则需要在每个维度上取得58%的取值范围 … 在维度接近一定程度时，要取得同样的训练样本数量，则几乎要在每个维度上取得接近100%的取值范围，或者增加总样本数量，但样本数量也总是有限的。</p>
<p>这样一直增加特征维数，由于样本分布越来越稀疏，如果要避免过拟合的出现，就不得不持续增加样本数量。</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3m80wn.png" alt="维灾难9.png"></p>
<p>数据在高维空间的中心比在边缘区域具备更大的稀疏性，数据更倾向于分布在空间的边缘区域：</p>
<p>不属于单位圆的训练样本比搜索空间的中心更接近搜索空间的角点。这些样本很难分类，因为它们的特征值差别很大（例如，单位正方形的对角的样本）。</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3mGStP.png" alt="维灾难10.png"></p>
<p>一个有趣的问题是，当我们增加特征空间的维度时，圆（超球面）的体积相对于正方形（超立方体）的体积如何发生变化。尺寸 <code>d</code> 的单位超立方体的体积总是1 ^ d = 1。尺寸 <code>d</code> 和半径0.5的内切超球体的体积可以计算为：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3mGKpT.png" alt="维灾难11.png"></p>
<p>在高维空间中，大多数训练数据驻留在定义特征空间的超立方体的角落中。如前所述，特征空间角落中的实例比围绕超球体质心的实例难以分类。</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3mGttx.png" alt="维灾难12.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/20/3mYCLQ.md.png" alt="维度灾难"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">an 8D hypercube which has 2^8 = 256 corners</span><br></pre></td></tr></table></figure>

<p>事实证明，许多事物在高维空间中表现得非常不同。 例如，如果你选择一个单位平方（1×1平方）的随机点，它将只有大约0.4％的机会位于小于0.001的边界（换句话说，随机点位于任何维度「极端」这是非常不可能的）。 但是在一个10000维单位超立方体（1×1×1立方体，有1万个1）中，这个概率大于99.999999％。 高维超立方体中的大部分点都非常靠近边界。更难区分的是：如果在一个单位正方形中随机抽取两个点，这两个点之间的距离平均约为0.52。如果在单位三维立方体中选取两个随机点，则平均距离将大致为0.66。但是在一个100万维的超立方体中随机抽取两点呢？那么平均距离将是大约408.25（大约1,000,000 / 6）！</p>
<p>非常违反直觉：当位于相同的单位超立方体内时，两点如何分离？这个事实意味着高维数据集有可能非常稀疏，大多数训练实例可能彼此远离。当然，这也意味着一个新实例可能离任何训练实例都很远，这使得预测的可信度表现得比在低维度数据中要差。<strong>训练集的维度越多，过度拟合的风险就越大</strong>。</p>
<p>理论上讲，维度灾难的一个解决方案是增加训练集的大小以达到足够密度的训练实例。 不幸的是，在实践中，达到给定密度所需训练实例的数量随着维度的数量呈指数增长。 如果只有100个特征（比MNIST问题少得多），那么为了使训练实例的平均值在0.1以内，需要有比可观察宇宙中的原子更多的训练实例，假设它们在所有维度上均匀分布。</p>
<p>对于8维超立方体，大约98％的数据集中在其256个角上。结果，当特征空间的维度达到无穷大时，从采样点到质心的最小和最大欧几里得距离的差与最小距离本身只比趋于零：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3mJFC6.png" alt="维灾难14.png"></p>
<p><code>距离测量</code> 开始失去其在高维空间中测量的 <code>有效性</code>，由于分类器取决于这些距离测量，因此在较低维空间中分类通常更容易，其中较少特征用于描述感兴趣对象。</p>
<p>如果理论上，无限数量的训练样本可用，则维度的诅咒不适用，我们可以简单地使用无数个特征来获得完美的分类。训练数据量越小，应使用的功能就越少。如果 <code>N</code> 个训练样本足以覆盖单位区间大小的 <code>1D</code> 特征空间，则需要 <code>N ^ 2</code> 个样本来覆盖具有相同密度的 <code>2D</code> 特征空间，并且在 <code>3D</code> 特征空间中需要 <code>N ^ 3</code> 个样本。换句话说，<strong>所需的训练实例数量随着使用的维度数量呈指数增长</strong>。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法之决策树</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<center>Editor：闫玉良</center>

<p>今天来学习一种新的<strong>分类</strong>算法「决策树」</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-决策树简介"><a href="#1-决策树简介" class="headerlink" title="1.决策树简介"></a>1.决策树简介</h2><blockquote>
<p>科普中国：决策树(<code>Decision Tree</code>)是在已知各种情况发生概率的基础上，通过构成决策树来求取净现值的期望值大于等于零的概率，评价项目风险，判断其可行性的决策分析方法，是直观运用概率分析的一种图解法。由于这种决策分支画成图形很像一棵树的枝干，故称决策树。</p>
</blockquote>
<p>决策树思想的来源非常朴素，最早的决策树就是利用程序设计中的条件分支结构(<code>if-else</code>)分割数据的一种分类学习方法。接下来使用简单的语言进行描述：</p>
<p><strong>决策树：是一种树形结构，其中每个内部节点表示一个属性上的判断，每个分支代表一个判断结果的输出，最后每个叶节点代表一种分类结果，本质是一颗由多个判断节点组成的树</strong>。</p>
<p>比如生活中和女朋友决策去哪旅行：</p>
<p>1.距离超过30公里的地方不去</p>
<p>2.没有美食的地方不去</p>
<p>3.没有拍照景点，打卡胜地的地方不去</p>
<p>4.没有购物的地方不去</p>
<p>先选择一个地点（拉萨）：距离超过30公里，不去！</p>
<p>再选择一个地点（衡水）：距离在30公里以内，往下进行判断；有美食（大饼卷肉、咸鸭蛋），再向下进行；没有打卡胜地，不去！</p>
<p>选择下一个地点（武汉）：距离在30公里以内，往下进行判断；有美食（热干面），再向下进行；有打卡胜地（武汉大学的樱花大道），再向下进行；有购物地方（光谷），那此次旅行的地方就它了！</p>
<h3 id="1-1-知识点汇总"><a href="#1-1-知识点汇总" class="headerlink" title="1.1 知识点汇总"></a>1.1 知识点汇总</h3><p><strong>1.决策树构建的基本步骤如下</strong>：</p>
<p>1) 开始将所有记录看作一个节点</p>
<p>2) 遍历每个变量的每一种分割方式，找到最好的分割点</p>
<p>3) 分割成两个节点 <code>N1</code> 和 <code>N2</code></p>
<p>4) 对 <code>N1</code> 和 <code>N2</code> 分别继续执行2-3步，直到每个节点足够「纯」为止。</p>
<p><strong>2.决策树的变量可以有两种</strong>：</p>
<p>1) 数字型 (<code>Numeric</code>) ：变量类型是整数或浮点数。用「&gt;=」，「&gt;」,「&lt;」或「&lt;=」作为分割条件（排序后，利用已有的分割情况，可以优化分割算法的时间复杂度）。</p>
<p>2) 名称型 (<code>Nominal</code>) ：类似编程语言中的枚举类型，变量只能从有限的选项中选取，使用「=」来分割。</p>
<p><strong>3.如何评估分割点的好坏？</strong></p>
<p>如果一个分割点可以将当前的所有节点分为两类，使得每一类都很「纯」，也就是同一类的记录较多，那么就是一个好分割点。</p>
<blockquote>
<p>构建决策树采用贪心算法，只考虑当前纯度差最大的情况作为分割点。</p>
</blockquote>
<h2 id="2-决策树分类原理"><a href="#2-决策树分类原理" class="headerlink" title="2.决策树分类原理"></a>2.决策树分类原理</h2><h3 id="2-1-熵"><a href="#2-1-熵" class="headerlink" title="2.1 熵"></a>2.1 熵</h3><p>物理学上，<strong>熵 <code>Entropy</code></strong> 是「混乱」程度的量度。<strong>系统越有序，熵值越低；系统越混乱或者分散，熵值越高</strong>。</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3MXWh6.png" alt="image-20190214113741822"></p>
<p><strong>信息理论</strong>：</p>
<p>1.<strong>从信息的完整性上进行的描述:</strong></p>
<p>当<strong>系统的有序状态一致时</strong>，数据越集中的地方熵值越小，数据越分散的地方熵值越大。</p>
<p>2.<strong>从信息的有序性上进行的描述:</strong></p>
<p>当<strong>数据量一致时</strong>，<strong>系统越有序，熵值越低；系统越混乱或者分散，熵值越高</strong>。</p>
<p>1948年香农提出了<strong>信息熵</strong>（<code>Entropy</code>）的概念。</p>
<p>假如事件 <code>A</code> 的分类划分是（<code>A1</code> ,<code>A2</code>,…,<code>An</code>），每部分发生的概率是(<code>p1</code>,<code>p2</code>,…,<code>pn</code>)，那信息熵定义为公式如下：（<code>log</code>是以2为底，<code>lg</code>是以10为底）</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3MjFNq.png" alt="image-20190214113927352"></p>
<h4 id="2-1-1-案例"><a href="#2-1-1-案例" class="headerlink" title="2.1.1 案例"></a>2.1.1 案例</h4><p><strong>案例1：如果一颗骰子的六个面都是1 ，投掷它不会给你带来任何新信息，因为你知道它的结果肯定是1，它的信息熵为？</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">- log(1) = 0</span><br></pre></td></tr></table></figure>

<p><strong>案例2：假设没有看世界杯的比赛，但是想知道哪支球队会是冠军，于是只能猜测某支球队是或不是冠军，然后观众用对或不对来回答。想要猜测次数尽可能少，你会用什么方法？</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">二分法：</span><br><span class="line">假如有 16 支球队，分别编号，先问是否在 1-8 之间，如果是就继续问是否在 1-4 之间，</span><br><span class="line">以此类推，直到最后判断出冠军球队是哪只。</span><br><span class="line">如果球队数量是 16，我们需要问 4 次来得到最后的答案。那么世界冠军这条消息的信息熵就是 4。</span><br><span class="line"></span><br><span class="line">如果有32个球队，准确的信息量应该是： </span><br><span class="line">H = -（p1 * logp1 + p2 * logp2 + ... + p32 * logp32），</span><br><span class="line">其中 p1, ..., p32 分别是这 32 支球队夺冠的概率。</span><br><span class="line">当每支球队夺冠概率相等都是 1/32 的时：H = -（32 * 1/32 * log1/32） = 5</span><br><span class="line">每个事件概率相同时，熵最大，这件事越不确定。</span><br></pre></td></tr></table></figure>

<p><strong>案例3：篮球比赛里，有4个球队 { <code>A</code>,<code>B</code>,<code>C</code>,<code>D</code>} ，获胜概率分别为{1/2, 1/4, 1/8, 1/8}，求<code>H(X)</code></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">H(X) = 1\2log(2)+1\4log(4)+1\8log(8)+1\8log(8)=(1\2+1\2+3\8+3\8)log(2)=7\4bits</span><br><span class="line">tips:</span><br><span class="line">    以2为底的对数，记做lb,单位bit</span><br><span class="line">    以e为底的对数，记做ln,单位nat</span><br></pre></td></tr></table></figure>

<h3 id="2-2-决策树的划分依据"><a href="#2-2-决策树的划分依据" class="headerlink" title="2.2 决策树的划分依据"></a>2.2 决策树的划分依据</h3><h4 id="2-2-1-信息增益"><a href="#2-2-1-信息增益" class="headerlink" title="2.2.1 信息增益"></a>2.2.1 信息增益</h4><p><strong>信息增益：</strong>以某特征划分数据集前后的熵的差值。熵可以表示样本集合的不确定性，熵越大，样本的不确定性就越高。因此可以<strong>使用划分前后集合熵的差值来衡量使用当前特征对于样本集合 <code>D</code> 划分效果的好坏</strong>。</p>
<p><strong>信息增益 = entroy(前) - entroy(后)</strong></p>
<p>特征 <code>A</code> 对训练数据集 <code>D</code> 的信息增益 <code>g(D,A)</code> ，定义为集合 <code>D</code> 的信息熵 <code>H(D)</code> 与特征 <code>A</code> 给定条件下 <code>D</code> 的信息条件熵 <code>H(D|A)</code> 之差，即公式为：</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3MxZm4.png" alt="信息增益公式.png"></p>
<p>公式的详细解释：</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3MxJne.png" alt="信息增益公式详解.png"></p>
<blockquote>
<p>注：信息增益表示得知特征 <code>X</code> 的信息而使得类 <code>Y</code> 的信息熵减少的程度</p>
</blockquote>
<h4 id="2-2-2-信息增益率"><a href="#2-2-2-信息增益率" class="headerlink" title="2.2.2 信息增益率"></a>2.2.2 信息增益率</h4><p><strong>增益率：</strong>增益比率度量是用增益度量 <code>Gain(S，A)</code> 和所分离信息度量 <code>SplitInformation</code>的比值来共同定义的。</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3QSFLF.png" alt="image-20190214130252748"></p>
<h4 id="2-2-3-基尼值和基尼指数"><a href="#2-2-3-基尼值和基尼指数" class="headerlink" title="2.2.3 基尼值和基尼指数"></a>2.2.3 基尼值和基尼指数</h4><p><strong>基尼值 <code>Gini(D)</code>：</strong>从数据集 <code>D</code> 中随机抽取两个样本，其类别标记不一致的概率。故，<code>Gini(D)</code> 值越小，数据集 <code>D</code> 的纯度越高。</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3QpHHg.png" alt="image-20190214130436855"></p>
<p><strong>基尼指数 <code>Gini_index(D)</code>：</strong>一般，选择使划分后基尼系数最小的属性作为最优化分属性。</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3Qpv3q.png" alt="image-20190214130516659"></p>
<h3 id="2-3-常见决策树类型比较"><a href="#2-3-常见决策树类型比较" class="headerlink" title="2.3 常见决策树类型比较"></a>2.3 常见决策树类型比较</h3><p><img src="https://s2.ax1x.com/2020/02/22/3QPB3n.png" alt="image-20190214152048210"></p>
<p><img src="https://s2.ax1x.com/2020/02/22/3QPxgI.png" alt="image-20190214132605305"></p>
<h4 id="2-3-1-ID3-算法"><a href="#2-3-1-ID3-算法" class="headerlink" title="2.3.1 ID3 算法"></a>2.3.1 ID3 算法</h4><p><strong>存在的缺点</strong></p>
<p> (1) <code>ID3</code> 算法在选择根节点和各内部节点中的分支属性时，<strong>采用信息增益作为评价标准</strong>。信息增益的缺点是倾向于选择取值较多的属性，在有些情况下这类属性可能不会提供太多有价值的信息.</p>
<p> (2) <code>ID3</code>算法<strong>只能对描述属性为离散型属性的数据集构造决策树</strong>。</p>
<h4 id="2-3-2-C4-5算法"><a href="#2-3-2-C4-5算法" class="headerlink" title="2.3.2 C4.5算法"></a>2.3.2 C4.5算法</h4><p><strong>做出的改进(为什么使用 <code>C4.5</code>要好)</strong></p>
<p> (1) 用信息增益率来选择属性</p>
<p> (2) 可以处理连续数值型属性</p>
<p> (3) 采用了一种后剪枝方法</p>
<p> (4) 对于缺失值的处理</p>
<p><strong>C4.5算法的优缺点</strong></p>
<p> 优点：产生的分类规则易于理解，准确率较高。</p>
<p> 缺点：在构造树的过程中，需要对数据集进行多次的顺序扫描和排序，因而导致算法的低效。</p>
<p> 此外，C4.5只适合于能够驻留于内存的数据集，当训练集大得无法在内存容纳时程序无法运行。</p>
<h4 id="2-3-3-CART算法"><a href="#2-3-3-CART算法" class="headerlink" title="2.3.3 CART算法"></a>2.3.3 CART算法</h4><p><code>CART</code> 算法相比 <code>C4.5</code> 算法的分类方法，采用了简化的二叉树模型，同时特征选择采用了近似的基尼系数来简化计算。</p>
<p><code>C4.5</code> 不一定是二叉树，但 <code>CART</code> 一定是二叉树。</p>
<p>同时，无论是 <code>ID3</code> ,  <code>C4.5</code> 还是 <code>CART</code> ，在做特征选择的时候都是选择最优的一个特征来做分类决策，但是大多数，<strong>分类决策不应该是由某一个特征决定的，而是应该由一组特征决定的。</strong>这样决策得到的决策树更加准确。这个决策树叫做多变量决策树( <code>multi-variate decision tree</code>)。在选择最优特征的时候，多变量决策树不是选择某一个最优特征，而是选择最优的一个特征线性组合来做决策。这个算法的代表是 <code>OC1</code>，这里不多介绍。</p>
<p>如果样本发生一点点的改动，就会导致树结构的剧烈改变。这个可以通过集成学习里面的随机森林之类的方法解决。</p>
<h2 id="3-cart剪枝"><a href="#3-cart剪枝" class="headerlink" title="3.cart剪枝"></a>3.cart剪枝</h2><h3 id="3-1-为什么要剪枝"><a href="#3-1-为什么要剪枝" class="headerlink" title="3.1 为什么要剪枝"></a>3.1 为什么要剪枝</h3><p><img src="https://s2.ax1x.com/2020/02/22/3QeEwt.png" alt="image-20190214142450219"></p>
<p><strong>横轴</strong>表示在决策树创建过程中树的结点总数，<strong>纵轴</strong>表示决策树的预测精度。</p>
<p>实线显示的是决策树在训练集上的精度，虚线显示的则是在一个独立的测试集上测量出来的精度。</p>
<p>随着树的增长，在训练样集上的精度是单调上升的， 然而在独立的测试样例上测出的精度先上升后下降。</p>
<p>出现这种情况的原因：</p>
<p>原因1：噪声、样本冲突，即错误的样本数据。</p>
<p>原因2：特征即属性不能完全作为分类标准。</p>
<p>原因3：巧合的规律性，数据量不够大。</p>
<h3 id="3-2-常用的减枝方法"><a href="#3-2-常用的减枝方法" class="headerlink" title="3.2 常用的减枝方法"></a>3.2 常用的减枝方法</h3><h4 id="3-2-1-预剪枝"><a href="#3-2-1-预剪枝" class="headerlink" title="3.2.1 预剪枝"></a>3.2.1 预剪枝</h4><p>（1）每一个结点所包含的最小样本数目，例如10，则该结点总样本数小于10时，则不再分；</p>
<p>（2）指定树的高度或者深度，例如树的最大深度为4；</p>
<p>（3）指定结点的熵小于某个值，不再划分。随着树的增长， 在训练样集上的精度是单调上升的， 然而在独立的测试样例上测出的精度先上升后下降<strong>。</strong></p>
<h4 id="3-2-2-后剪枝"><a href="#3-2-2-后剪枝" class="headerlink" title="3.2.2 后剪枝"></a>3.2.2 后剪枝</h4><p>后剪枝，在已生成过拟合决策树上进行剪枝，可以得到简化版的剪枝决策树。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法之线性回归</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<center>Editor：闫玉良</center>

<p>机器学习中最常见的一类问题：线性回归问题。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1.应用场景"></a>1.应用场景</h2><ul>
<li>房价预测</li>
</ul>
<p>通过以往房屋面积与房屋价格对应情况，推断出现有房屋的价格。</p>
<ul>
<li>销售额度预测</li>
</ul>
<p>销售额度受影响因素很多，比如广告，市场环境等等。我们可以分析出其中的关系，从而预测销售额度。</p>
<ul>
<li>贷款额度预测</li>
</ul>
<p>银行对于每个人的贷款额度参考，预测出某人的贷款额度。</p>
<p>……</p>
<h2 id="2-线性回归"><a href="#2-线性回归" class="headerlink" title="2.线性回归"></a>2.线性回归</h2><p>在说线性回归之前，需要先搞清楚『分类』和『回归』这两个概念，这也是机器学习中很重要的概念。简单来讲，『分类』和『回归』都是预测目标值的过程，但是『分类』预测的是离散型变量，而『回归』预测的是连续型变量。下面开始介绍线性回归：</p>
<p>线性回归(<code>Linear regression</code>)是利用<strong>回归方程(函数)</strong>对<strong>一个或多个自变量(特征值)和因变量(目标值)之间</strong>关系进行建模的一种分析方式。下面即对应公式：</p>
<blockquote>
<p>只有一个自变量的情况称为单变量回归，多于一个自变量情况的叫做多元回归</p>
</blockquote>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%85%AC%E5%BC%8F.png" alt="线性回归公式"></p>
<p>那么怎么理解呢？我们来看几个例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">期末成绩 = 0.7 × 考试成绩 + 0.3 × 平时成绩</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">房子价格 = 0.02 × 中心区域的距离 + 0.04 × 城市一氧化氮浓度 + (-0.12 × 自住房平均房价) + 0.254 × 城镇犯罪率</span><br></pre></td></tr></table></figure>

<p>上面两个例子，<strong>我们看到特征值与目标值之间建立了一个关系，这个关系可以理解为线性模型</strong>。</p>
<p>如果还是难以理解的话，那么再通俗易懂的解释一下：</p>
<p>假设有很多小点点在屏幕上，他们看似杂乱，但貌似又有些关系。线性回归就是找出一条直线，尽可能的让给定的特征值点（屏幕上的小点点）都落到线上或均匀分布于两侧并靠近于这条线。</p>
<blockquote>
<p>当然这些点分布的不能过于散乱，他们的整体趋势必须是线性的，否则拟合结果就是非线性。</p>
</blockquote>
<p>这样看来，像不像给定几个点，然后求直线方程呢？（无限趋于完美情况，所有点都在直线上）这个直线方程就是<strong>「线性回归方程」</strong>，要求的参数就是「回归参数」</p>
<h2 id="3-特征值与目标值关系分析"><a href="#3-特征值与目标值关系分析" class="headerlink" title="3.特征值与目标值关系分析"></a>3.特征值与目标值关系分析</h2><p>线性回归当中线性模型有两种：<strong>一种是线性关系，另一种是非线性关系。</strong>在这里我们只能画一个平面更好去理解，所以都用单个特征或两个特征举例子。</p>
<h3 id="3-1-线性关系"><a href="#3-1-线性关系" class="headerlink" title="3.1 线性关系"></a>3.1 线性关系</h3><h4 id="3-1-1-单变量线性关系"><a href="#3-1-1-单变量线性关系" class="headerlink" title="3.1.1 单变量线性关系"></a>3.1.1 单变量线性关系</h4><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E7%BA%BF%E6%80%A7%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="单变量线性关系"></p>
<h4 id="3-1-2-多变量线性关系"><a href="#3-1-2-多变量线性关系" class="headerlink" title="3.1.2 多变量线性关系"></a>3.1.2 多变量线性关系</h4><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E5%A4%9A%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%85%B3%E7%B3%BB.png" alt="多变量线性关系"></p>
<p><strong>注释：</strong>单特征与目标值的关系呈直线关系，或者两个特征与目标值呈现平面的关系。</p>
<p>更高维度的我们不用自己去想，记住这种关系即可</p>
<h3 id="3-2-非线性关系"><a href="#3-2-非线性关系" class="headerlink" title="3.2 非线性关系"></a>3.2 非线性关系</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%85%B3%E7%B3%BB.png" alt="非线性关系"></p>
<h2 id="4-线性回归api初步使用"><a href="#4-线性回归api初步使用" class="headerlink" title="4.线性回归api初步使用"></a>4.线性回归api初步使用</h2><h3 id="4-1-api"><a href="#4-1-api" class="headerlink" title="4.1 api"></a>4.1 api</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sklearn.linear_model.LinearRegression()</span><br><span class="line"><span class="meta">#</span><span class="bash"> LinearRegression.coef_：回归系数</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-举例"><a href="#4-2-举例" class="headerlink" title="4.2 举例"></a>4.2 举例</h3><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190320204457160.png" alt="示例表格"></p>
<h4 id="4-2-1-步骤分析"><a href="#4-2-1-步骤分析" class="headerlink" title="4.2.1 步骤分析"></a>4.2.1 步骤分析</h4><ul>
<li>1.获取数据集</li>
<li>2.数据基本处理（该案例中省略）</li>
<li>3.特征工程（该案例中省略）</li>
<li>4.机器学习</li>
<li>5.模型评估（该案例中省略）</li>
</ul>
<h4 id="4-2-2-代码过程"><a href="#4-2-2-代码过程" class="headerlink" title="4.2.2 代码过程"></a>4.2.2 代码过程</h4><ul>
<li>导入模块</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br></pre></td></tr></table></figure>

<ul>
<li>构造数据集</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [[<span class="number">80</span>, <span class="number">86</span>],</span><br><span class="line">[<span class="number">82</span>, <span class="number">80</span>],</span><br><span class="line">[<span class="number">85</span>, <span class="number">78</span>],</span><br><span class="line">[<span class="number">90</span>, <span class="number">90</span>],</span><br><span class="line">[<span class="number">86</span>, <span class="number">82</span>],</span><br><span class="line">[<span class="number">82</span>, <span class="number">90</span>],</span><br><span class="line">[<span class="number">78</span>, <span class="number">80</span>],</span><br><span class="line">[<span class="number">92</span>, <span class="number">94</span>]]</span><br><span class="line">y = [<span class="number">84.2</span>, <span class="number">80.6</span>, <span class="number">80.1</span>, <span class="number">90</span>, <span class="number">83.2</span>, <span class="number">87.6</span>, <span class="number">79.4</span>, <span class="number">93.4</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>机器学习– 模型训练</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例化API</span></span><br><span class="line">estimator = LinearRegression()</span><br><span class="line"><span class="comment"># 使用fit方法进行训练</span></span><br><span class="line">estimator.fit(x,y)</span><br><span class="line"><span class="comment"># 回归系数</span></span><br><span class="line">estimator.coef_</span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">estimator.predict([[<span class="number">100</span>, <span class="number">80</span>]])</span><br></pre></td></tr></table></figure>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法之线性回归的损失和优化</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%9A%84%E6%8D%9F%E5%A4%B1%E5%92%8C%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<center>Editor：闫玉良</center>

<p>学习了线性回归，接下来就需要考虑其损失以及优化了。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p><strong>我们仍然选择房子的例子，假设真实的数据之间存在这样的关系：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">真实关系：真实房子价格 = <span class="number">0.02</span>×中心区域的距离 + <span class="number">0.04</span>×城市一氧化氮浓度 + (<span class="number">-0.12</span>×自住房平均房价) + <span class="number">0.254</span>×城镇犯罪率</span><br></pre></td></tr></table></figure>

<p>那么现在，我们随意指定一个关系（猜测）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">随机指定关系：预测房子价格 = <span class="number">0.25</span>×中心区域的距离 + <span class="number">0.14</span>×城市一氧化氮浓度 + <span class="number">0.42</span>×自住房平均房价 + <span class="number">0.34</span>×城镇犯罪率</span><br></pre></td></tr></table></figure>

<p>思考一下，这样的话，会发生什么？真实结果与我们预测的结果之间是不是存在一定的误差呢？类似下图所示：</p>
<img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221093806586.png" alt="房屋示例" style="zoom:50%;">

<p>既然存在这个误差，那我们就需要将这个误差给衡量出来。</p>
<h3 id="1-损失函数"><a href="#1-损失函数" class="headerlink" title="1.损失函数"></a>1.损失函数</h3><p>总损失定义为：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.png" alt="线性回归损失函数"></p>
<ul>
<li><code>yi</code> 为第 <code>i</code> 个训练样本的真实值</li>
<li><code>h(xi)</code> 为第 <code>i</code> 个训练样本特征值组合预测函数</li>
<li>又称最小二乘法</li>
</ul>
<p>如何去减少这个损失，使预测更加准确呢？我们一直说机器学习有自动学习的功能，在线性回归中更能体现。此处可以通过一些优化方法去优化（其实运用了是数学当中的求导功能）回归的总损失！！！</p>
<h3 id="2-优化算法"><a href="#2-优化算法" class="headerlink" title="2.优化算法"></a>2.优化算法</h3><p><strong>如何去求模型当中的 <code>W</code>，使得损失最小？（目的是找到最小损失对应的 <code>W</code> 值）</strong></p>
<p>下面即线性回归经常使用的两种优化算法：</p>
<h4 id="2-1-正规方程"><a href="#2-1-正规方程" class="headerlink" title="2.1 正规方程"></a>2.1 正规方程</h4><h5 id="2-1-1-什么是正规方程"><a href="#2-1-1-什么是正规方程" class="headerlink" title="2.1.1 什么是正规方程"></a>2.1.1 什么是正规方程</h5><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B.png" alt="正规方程"></p>
<blockquote>
<p><strong>理解：</strong><code>X</code> 为特征值矩阵，<code>y</code> 为目标值矩阵。根据公式直接求出最好的结果。</p>
<p><strong>缺点：</strong>当特征过多且十分复杂时，求解速度太慢并且很难得到甚至得不到正确结果</p>
</blockquote>
<img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221094805620.png" alt="求解示意图" style="zoom:50%;">

<h5 id="2-1-2-正规方程求解举例"><a href="#2-1-2-正规方程求解举例" class="headerlink" title="2.1.2 正规方程求解举例"></a>2.1.2 正规方程求解举例</h5><p>以下图片展示数据为例：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221100240178.png" alt="示例1"></p>
<p>即：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221100305355.png" alt="示例2"></p>
<p>运用<strong>正规方程</strong>方法求解参数：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221100324767.png" alt="求解"></p>
<h5 id="2-1-3-正规方程的推导"><a href="#2-1-3-正规方程的推导" class="headerlink" title="2.1.3 正规方程的推导"></a>2.1.3 正规方程的推导</h5><p>把该损失函数转换成矩阵写法：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190319162703732.png" alt="矩阵写法"></p>
<p>其中 <code>y</code> 是真实值矩阵，<code>X</code> 是特征值矩阵，<code>w</code> 是权重矩阵。</p>
<p>对其求解关于 <code>w</code> 的最小值，起止 <code>y</code> , <code>X</code>  均已知二次函数，直接求导，导数为零的位置，即为最小值。</p>
<p>求导：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190320211408492.png" alt="求导"></p>
<p><strong>注：</strong>式(1) 到 式(2) 推导过程中, <code>X</code> 是一个 <code>m</code> 行 <code>n</code> 列的矩阵，并不能保证其有逆矩阵，但是右乘 <code>XT</code> 可把其变成一个方阵，保证其有逆矩阵。</p>
<p>式(5)  到 式(6) 推导过程中，和上面类似。</p>
<h4 id="2-2-梯度下降-Gradient-Descent"><a href="#2-2-梯度下降-Gradient-Descent" class="headerlink" title="2.2 梯度下降(Gradient Descent)"></a>2.2 梯度下降(Gradient Descent)</h4><h5 id="2-2-1-什么是梯度下降"><a href="#2-2-1-什么是梯度下降" class="headerlink" title="2.2.1 什么是梯度下降"></a>2.2.1 什么是梯度下降</h5><p>梯度下降法的基本思想可以类比为一个下山的过程。</p>
<p>假设这样一个场景：一个人被困在山上，需要从山上下来(i.e. 找到山的最低点，也就是山谷)。但此时山上浓雾密布，可视度很低，下山的路径根本无法确定。他必须利用自己周围的信息去找到下山路径（根据身边信息不断摸索前进）。此时，就可以利用<strong>梯度下降算法</strong>来下山了。换成直白的话语，以他当前的所处的位置为基准，<strong>寻找这个位置最陡峭的地方，然后朝着 山高度下降的地方 走</strong>，（同理，如果我们的目标是上山，也就是爬到山顶，那么此时应该是朝着最陡峭的方向往上走）。然后每走一段距离，都反复采用同一种方法，最后就能成功的抵达山谷。</p>
<blockquote>
<p>英文中 <code>e.g.</code> 的全称是 exempli gratia；<code>i.e.</code> 的全称是 id est 。</p>
<p>英文中 <code>e.g.</code> 的意思是 <code>例如</code>、<code>比如</code>；<code>i.e.</code> 的意思是 <code>那就是说</code>、<code>换句话说</code>。</p>
</blockquote>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221112607972.png" alt="下山"></p>
<p>梯度下降的基本过程同下山的场景类似。首先，有一个<strong>可微分的函数</strong>。此函数就代表着一座山。我们的目标就是找到<strong>这个函数的最小值</strong>，也就是山底。</p>
<p>根据之前的场景假设，最快的下山的方式就是找到当前位置最陡峭的方向，然后沿着此方向向下走，对应到函数中，就是<strong>找到给定点的梯度</strong> ，然后朝着梯度相反的方向，就能让函数值下降的最快！因为梯度的方向就是函数变化最快的方向。 重复利用此方法，反复求取梯度，最后就能到达局部的最小值，这就类似于下山的过程。而求取梯度就确定了最陡峭的方向，也就是场景中测量方向的手段。</p>
<blockquote>
<p>百度百科：梯度的本意是一个向量（矢量），表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（此梯度的方向）变化最快，变化率最大（为该梯度的模）。梯度向量的方向即为函数值增长最快的方向。</p>
</blockquote>
<p>如果梯度的概念你还不是很清楚，请看下方解释</p>
<h5 id="2-2-2-梯度的概念"><a href="#2-2-2-梯度的概念" class="headerlink" title="2.2.2 梯度的概念"></a>2.2.2 梯度的概念</h5><p>梯度是微积分中一个很重要的概念。在单变量的函数中，梯度其实就是函数的微分，代表着函数在某个给定点的切线的斜率。在多变量函数中，梯度是一个向量，向量有方向，梯度的方向就指出了函数在给定点的上升最快的方向。</p>
<p>这也就说明了为什么我们需要千方百计的求取梯度！我们需要到达山底，就需要在每一步观测到此时最陡峭的地方，梯度就恰巧告诉了我们这个方向。梯度的方向是函数在给定点上升最快的方向，那么梯度的反方向就是函数在给定点下降最快的方向，这正是我们所需要的。所以我们只要沿着梯度的反方向一直走，就能走到局部的最低点！</p>
<h5 id="2-2-3-梯度下降举例"><a href="#2-2-3-梯度下降举例" class="headerlink" title="2.2.3 梯度下降举例"></a>2.2.3 梯度下降举例</h5><ul>
<li><strong>1. 单变量函数的梯度下降</strong></li>
</ul>
<p>假设有一个单变量的函数：J(θ) = θ的平方</p>
<p>函数的微分：J(θ)的微分 = 2θ</p>
<p>初始化，起点为： θ0 = 1</p>
<p>学习率：α = 0.4</p>
<p>我们开始进行梯度下降的迭代计算过程:</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221102707528.png" alt="image-20190221102707528"></p>
<p>如下示意图，经过四次的运算，也就是走了四步，基本就抵达了函数的最低点，也就是山底</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221102725918.png" alt="迭代计算示意图"></p>
<ul>
<li><strong>2.多变量函数的梯度下降</strong></li>
</ul>
<p>我们假设有一个目标函数 ：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E5%A4%9A%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="目标函数"></p>
<p>现在要利用梯度下降法计算这个函数的最小值。通过观察就能发现最小值其实就是  (0，0) 点。但是不能直接看，需要论证。接下来，我们会从梯度下降算法开始，一步步计算到这个最小值! </p>
<p>我们假设初始的起点为：θ0 = (1, 3)</p>
<p>初始的学习率为：α = 0.1</p>
<p>函数的梯度为：▽J(θ) =&lt; 2θ1 ,2θ2&gt;</p>
<p>进行多次迭代:</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221103158740.png" alt="image-20190221103158740"></p>
<p>我们发现，已经基本靠近函数的最小值点</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221103220033.png" alt="image-20190221103220033"></p>
<h5 id="2-2-4-梯度下降（Gradient-Descent）公式"><a href="#2-2-4-梯度下降（Gradient-Descent）公式" class="headerlink" title="2.2.4 梯度下降（Gradient Descent）公式"></a>2.2.4 梯度下降<strong>（</strong>Gradient Descent）公式</h5><p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E5%85%AC%E5%BC%8F.png" alt="梯度下降公式"></p>
<ul>
<li><p><strong>1) <code>α</code> 是什么含义？</strong></p>
<p><code>α</code> 在梯度下降算法中被称作 <strong>学习率</strong> 或者 <strong>步长</strong>，意味着我们可以通过 <code>α</code> 来控制每一步走的距离，以保证不要步子跨的太大扯着蛋，哈哈。其实就是不要走太快，错过了最低点。同时也要保证不要走的太慢，导致太阳下山了，还没有走到山下。所以 <code>α</code> 的选择在梯度下降法中往往是很重要的！<code>α</code> 不能太大也不能太小，太小的话，可能导致迟迟走不到最低点，太大的话，会导致错过最低点！</p>
</li>
</ul>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190221113408141.png" alt="image-20190221113408141"></p>
<ul>
<li><strong>2) 为什么梯度要乘以一个负号</strong>？</li>
</ul>
<p>梯度前加一个负号，就意味着朝着梯度相反的方向前进。在前文提到，梯度的方向实际就是函数在此点上升最快的方向。而我们需要朝着下降最快的方向走，自然就是负的梯度的方向，所以此处需要加上负号。</p>
<p>通过两个图更好理解梯度下降的过程：</p>
<p><strong>单变量的梯度下降：</strong></p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E5%8D%95%E5%8F%98%E9%87%8F%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D.png" alt="单变量的梯度下降"></p>
<p><strong>多变量的梯度下降：</strong></p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/%E5%A4%9A%E5%8F%98%E9%87%8F%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D.png" alt="多变量的梯度下降"></p>
<p><strong>正因为有了梯度下降这样一个优化算法，回归才具有「自动学习」的能力</strong></p>
<h5 id="2-2-5-优化动态图演示"><a href="#2-2-5-优化动态图演示" class="headerlink" title="2.2.5 优化动态图演示"></a>2.2.5 优化动态图演示</h5><p><img src="https://s2.ax1x.com/2020/02/19/3EMkS1.gif" alt="线性回归优化动态图"></p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul>
<li>线性回归的损失函数 - 均方误差</li>
<li>线性回归的优化方法<ul>
<li>正规方程</li>
<li>梯度下降</li>
</ul>
</li>
<li>梯度下降和正规方程的对比</li>
</ul>
<table>
<thead>
<tr>
<th>梯度下降</th>
<th>正规方程</th>
</tr>
</thead>
<tbody><tr>
<td>需要选择学习率</td>
<td>不需要</td>
</tr>
<tr>
<td>需要迭代求解</td>
<td>一次运算得出</td>
</tr>
<tr>
<td>特征数量较大可以使用</td>
<td>需要计算方程，时间复杂度高O(n的立方)</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>选择上</strong></p>
<p>小规模数据：</p>
<ul>
<li><strong><code>LinearRegression</code>(不能解决拟合问题)</strong></li>
<li>岭回归</li>
</ul>
<p>大规模数据：<code>SGDRegressor</code></p>
</li>
</ul>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法之聚类算法</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B9%8B%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<center>Editor：闫玉良</center>

<p>今日开启新算法的学习「聚类算法」</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-认识聚类算法"><a href="#1-认识聚类算法" class="headerlink" title="1.认识聚类算法"></a>1.认识聚类算法</h2><h3 id="1-1-应用"><a href="#1-1-应用" class="headerlink" title="1.1 应用"></a>1.1 应用</h3><p>1) 用户画像，广告推荐，<code>Data Segmentation</code>，搜索引擎的流量推荐，恶意流量识别</p>
<p>2) 基于位置信息的商业推送，新闻聚类，筛选排序</p>
<p>3) 图像分割，降维，识别；离群点检测；信用卡异常消费；发掘相同功能的基因片段</p>
<h3 id="1-2-概念"><a href="#1-2-概念" class="headerlink" title="1.2 概念"></a>1.2 概念</h3><p><strong>聚类算法</strong>：</p>
<p>一种典型的<strong>无监督</strong>学习算法，主要用于将相似的样本自动归到一个类别中。</p>
<p>在聚类算法中根据样本之间的相似性，将样本划分到不同的类别中，对于不同的相似度计算方法，会得到不同的聚类结果，常用的相似度计算方法有欧式距离法。</p>
<h3 id="1-3-与分类算法最大的区别"><a href="#1-3-与分类算法最大的区别" class="headerlink" title="1.3 与分类算法最大的区别"></a>1.3 与分类算法最大的区别</h3><p>聚类算法是无监督的学习算法，而分类算法属于监督的学习算法。</p>
<h2 id="2-聚类算法-API-初步使用"><a href="#2-聚类算法-API-初步使用" class="headerlink" title="2.聚类算法 API 初步使用"></a>2.聚类算法 API 初步使用</h2><h3 id="2-1-API-介绍"><a href="#2-1-API-介绍" class="headerlink" title="2.1 API 介绍"></a>2.1 API 介绍</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sklearn.cluster.KMeans(n_clusters=<span class="number">8</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">参数:</span></span><br><span class="line"><span class="string">  n_clusters:开始的聚类中心数量</span></span><br><span class="line"><span class="string">    - 整型，缺省值=8，生成的聚类数，即产生的质心（centroids）数。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">方法:</span></span><br><span class="line"><span class="string">  estimator.fit(x)</span></span><br><span class="line"><span class="string">  estimator.predict(x)</span></span><br><span class="line"><span class="string">  estimator.fit_predict(x)</span></span><br><span class="line"><span class="string">    - 计算聚类中心并预测每个样本属于哪个类别,相当于先调用fit(x),然后再调用predict(x)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-案例"><a href="#2-2-案例" class="headerlink" title="2.2 案例"></a>2.2 案例</h3><p>随机创建不同二维数据集作为训练集，并结合 <code>k-means</code> 算法将其聚类，你可以尝试分别聚类不同数量的簇，并观察聚类效果：</p>
<p><img src="https://s2.ax1x.com/2020/02/24/33LfPI.png" alt="image-20190219163451509"></p>
<p>聚类参数 <code>n_cluster</code> 传值不同，得到的聚类结果不同</p>
<p><img src="https://s2.ax1x.com/2020/02/24/33LXin.png" alt="image-20190219163505530"></p>
<h4 id="2-2-1-流程分析"><a href="#2-2-1-流程分析" class="headerlink" title="2.2.1 流程分析"></a>2.2.1 流程分析</h4><p><img src="https://s2.ax1x.com/2020/02/24/33OpsU.png" alt="image-20190219163649472"></p>
<h4 id="2-2-2-代码实现"><a href="#2-2-2-代码实现" class="headerlink" title="2.2.2 代码实现"></a>2.2.2 代码实现</h4><p>1) 创建数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> calinski_harabaz_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据集</span></span><br><span class="line"><span class="comment"># X为样本特征，Y为样本簇类别， 共1000个样本，每个样本4个特征，共4个簇，</span></span><br><span class="line"><span class="comment"># 簇中心在[-1,-1], [0,0],[1,1], [2,2]， 簇方差分别为[0.4, 0.2, 0.2, 0.2]</span></span><br><span class="line">X, y = make_blobs(n_samples=<span class="number">1000</span>, n_features=<span class="number">2</span>, centers=[[<span class="number">-1</span>, <span class="number">-1</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]],</span><br><span class="line">                  cluster_std=[<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>],</span><br><span class="line">                  random_state=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据集可视化</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], marker=<span class="string">'o'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>2) 使用 <code>k-means</code> 进行聚类,并使用 <code>CH</code> 方法评估</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_pred = KMeans(n_clusters=<span class="number">2</span>, random_state=<span class="number">9</span>).fit_predict(X)</span><br><span class="line"><span class="comment"># 分别尝试n_cluses=2\3\4,然后查看聚类效果</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y_pred)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用Calinski-Harabasz Index评估的聚类分数</span></span><br><span class="line">print(calinski_harabaz_score(X, y_pred))</span><br></pre></td></tr></table></figure>

<h2 id="3-聚类算法实现流程"><a href="#3-聚类算法实现流程" class="headerlink" title="3.聚类算法实现流程"></a>3.聚类算法实现流程</h2><p><strong><code>k-means</code> 其实包含两层内容：</strong></p>
<p><code>K</code> ：初始中心点个数（计划聚类数）</p>
<p><code>means</code>：求中心点到其他数据点距离的平均值</p>
<h3 id="3-1-k-means-聚类步骤"><a href="#3-1-k-means-聚类步骤" class="headerlink" title="3.1 k-means 聚类步骤"></a>3.1 k-means 聚类步骤</h3><p>1) 随机设置 <code>K</code> 个特征空间内的点作为初始的聚类中心</p>
<p>2) 对于其他每个点计算到 <code>K</code> 个中心的距离，未知的点选择最近的一个聚类中心点作为标记类别</p>
<p>3) 紧接着，重新计算出每个聚类的新中心点（平均值）</p>
<p>4) 如果计算得出的新中心点与原中心点一样（质心不再移动），那么结束，否则重新进行第二步过程</p>
<p>通过下图解释实现流程：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/K-means%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="K-meansè¿‡ç¨‹åˆ†æž"></p>
<p>k聚类动态效果图</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/2019-02-19%2017.06.49.gif" alt="2019-02-19 17.06.49"></p>
<h3 id="3-2-案例练习"><a href="#3-2-案例练习" class="headerlink" title="3.2 案例练习"></a>3.2 案例练习</h3><p>案例：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219171158984.png" alt="image-20190219171158984"></p>
<p>1) 随机设置 <code>K</code> 个特征空间内的点作为初始的聚类中心（本案例中设置 <code>p1</code> 和 <code>p2</code> ）</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219171244828.png" alt="image-20190219171244828"></p>
<p>2) 对于其他每个点计算到 <code>K</code> 个中心的距离，未知的点选择最近的一个聚类中心点作为标记类别</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219171326923.png" alt="image-20190219171326923"></p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219171338441.png" alt="image-20190219171338441"></p>
<p>3) 重新计算出每个聚类的新中心点（平均值）</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219171727035.png" alt="image-20190219171727035"></p>
<p>4) 如果计算得出的新中心点与原中心点一样（质心不再移动），那么结束，否则重新进行第二步过程「经过判断，需要重复上述步骤，开始新一轮迭代」</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219171951607.png" alt="image-20190219171951607"></p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219172011618.png" alt="image-20190219172011618"></p>
<p>5) 当每次迭代结果不变时，认为算法收敛，聚类完成，<strong><code>K-Means</code> 一定会停下，不可能陷入一直选质心的过程。</strong></p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219172125388.png" alt="image-20190219172125388"></p>
<h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><p><strong>流程</strong>：</p>
<p>1) 事先<strong>确定常数 <code>K</code></strong>，常数 <code>K</code> 意味着最终的聚类类别数;</p>
<p>2) 首先随机<strong>选定初始点为质心</strong>，并通过计算每一个样本与质心之间的相似度(这里为欧式距离)，将样本点归到最相似的类中，</p>
<p>3) 接着，<strong>重新计算</strong>每个类的质心(即为类中心)，重复这样的过程，直到<strong>质心不再改变</strong>，</p>
<p>4) 最终就确定了每个样本所属的类别以及每个类的质心。</p>
<p><strong>注意</strong>：由于每次都要计算所有的样本与每一个质心之间的相似度，故在大规模的数据集上，<code>K-Means</code> 算法的收敛速度比较慢。</p>
<h2 id="4-模型评估"><a href="#4-模型评估" class="headerlink" title="4.模型评估"></a>4.模型评估</h2><h3 id="4-1-误差平方和-SSE-The-sum-of-squares-due-to-error"><a href="#4-1-误差平方和-SSE-The-sum-of-squares-due-to-error" class="headerlink" title="4.1 误差平方和(SSE \The sum of squares due to error)"></a>4.1 误差平方和(SSE \The sum of squares due to error)</h3><p>举例：(下图中数据-0.2, 0.4, -0.8, 1.3, -0.7, 均为真实值和预测值的差)</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190308211436382.png" alt="image-20190308211436382"></p>
<p>在 <code>k-means</code> 中的应用：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219173503991.png" alt="image-20190219173503991.png"></p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219173610490.png" alt="image-20190219173610490"></p>
<p>公式各部分内容:</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190308211313308.png" alt="image-20190308211313308"></p>
<p>上图中: <code>k=2</code></p>
<p><strong>1) <code>SSE</code> 图最终的结果，对图松散度的衡量。</strong>(eg: <code>SSE(左图)</code> &lt; <code>SSE(右图)</code>)</p>
<p>2) <code>SSE</code> 随着聚类迭代，其值会越来越小，直到最后趋于稳定</p>
<p>3) 如果质心的初始值选择不好，<code>SSE</code> 只会达到一个不怎么好的局部最优解</p>
<h3 id="4-2「肘」方法-Elbow-method-—-K值确定"><a href="#4-2「肘」方法-Elbow-method-—-K值确定" class="headerlink" title="4.2「肘」方法(Elbow method) — K值确定"></a>4.2「肘」方法(Elbow method) — K值确定</h3><p>1) 对于 <code>n</code> 个点的数据集，迭代计算 <code>k from 1 to n</code>，每次聚类完成后计算每个点到其所属的簇中心的距离的平方和；</p>
<p>2) 平方和是会逐渐变小的，直到 <code>k==n</code> 时平方和为0，因为每个点都是它所在的簇中心本身。</p>
<p>3) 在这个平方和变化过程中，会出现一个拐点也即「肘」点，<strong>下降率突然变缓时即认为是最佳的 <code>k</code> 值</strong>。</p>
<p>在决定什么时候停止训练时，肘形判据同样有效，数据通常有更多的噪音，在<strong>增加分类无法带来更多回报时，我们停止增加类别</strong>。</p>
<h3 id="4-3-轮廓系数法-Silhouette-Coefficient"><a href="#4-3-轮廓系数法-Silhouette-Coefficient" class="headerlink" title="4.3 轮廓系数法(Silhouette Coefficient)"></a>4.3 轮廓系数法(Silhouette Coefficient)</h3><p>结合了聚类的凝聚度（Cohesion）和分离度（Separation），用于评估聚类的效果：</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219174853018.png" alt="image-20190219174853018"></p>
<p><strong>目的：</strong>内部距离最小化，外部距离最大化</p>
<p><img src="https://gitee.com/Ethanyan/pic_data/raw/master/image-20190219175813875.png" alt="image-20190219175813875"></p>
<p>计算样本 <code>i</code> 到同簇其他样本的平均距离 <code>ai</code>，<code>ai</code> 越小样本 <code>i</code> 的簇内不相似度越小，说明样本 <code>i</code> 越应该被聚类到该簇。</p>
<p>计算样本 <code>i</code> 到最近簇 <code>Cj</code> 的所有样本的平均距离 <code>bij</code>，称样本 <code>i</code> 与最近簇 <code>Cj</code> 的不相似度，定义为样本 <code>i</code> 的簇间不相似度：<code>bi =min{bi1, bi2, ..., bik}</code>，<code>bi</code> 越大，说明样本 <code>i</code> 越不属于其他簇。</p>
<p>求出所有样本的轮廓系数后再求平均值就得到了<strong>平均轮廓系数</strong>。</p>
<p>平均轮廓系数的取值范围为[-1,1]，系数越大，聚类效果越好。</p>
<p>簇内样本的距离越近，簇间样本距离越远。</p>
<h3 id="4-4-CH-系数-Calinski-Harabasz-Index"><a href="#4-4-CH-系数-Calinski-Harabasz-Index" class="headerlink" title="4.4 CH 系数(Calinski-Harabasz Index)"></a>4.4 CH 系数(Calinski-Harabasz Index)</h3><p><strong>Calinski-Harabasz：</strong></p>
<p>类别内部数据的协方差越小越好，类别之间的协方差越大越好（换句话说：类别内部数据的距离平方和越小越好，类别之间的距离平方和越大越好），这样的 <code>Calinski-Harabasz</code> 分数 <code>s</code> 会高，分数 <code>s</code> 高则聚类效果越好。</p>
<p><img src="https://s2.ax1x.com/2020/02/24/38u9OO.png" alt="image-20190219182033877"></p>
<p><code>tr</code> 为<strong>矩阵的迹</strong>, <code>Bk</code> 为类别之间的协方差矩阵，<code>Wk</code> 为类别内部数据的协方差矩阵;</p>
<p><code>m</code> 为训练集样本数，<code>k</code> 为类别数。</p>
<p><img src="https://s2.ax1x.com/2020/02/24/38uept.png" alt="image-20190219182615777"></p>
<p>使用矩阵的迹进行求解的理解：</p>
<p>矩阵的对角线可以表示一个物体的相似性</p>
<p>在机器学习里，主要为了获取数据的特征值，那么就是说，在任何一个矩阵计算出来之后，都可以简单化，只要获取矩阵的迹，就可以表示这一块数据的最重要的特征了，这样就可以把很多无关紧要的数据删除掉，达到简化数据，提高处理速度。</p>
<p><code>CH</code> 需要达到的目的：<strong>用尽量少的类别聚类尽量多的样本，同时获得较好的聚类效果。</strong></p>
<h3 id="4-5-总结"><a href="#4-5-总结" class="headerlink" title="4.5 总结"></a>4.5 总结</h3><p>1) <strong>肘部法</strong>：下降率突然变缓时即认为是最佳的 <code>k</code> 值</p>
<p>2) <strong><code>SC</code> 系数</strong>：取值为[-1, 1]，其值越大越好</p>
<p>3)  <strong><code>CH</code>系数</strong>：分数 <code>s</code> 高则聚类效果越好</p>
<h2 id="5-算法优化"><a href="#5-算法优化" class="headerlink" title="5.算法优化"></a>5.算法优化</h2><h3 id="5-1-k-means-算法小结"><a href="#5-1-k-means-算法小结" class="headerlink" title="5.1 k-means 算法小结"></a>5.1 k-means 算法小结</h3><p><strong>优点：</strong></p>
<p> 1) 原理简单（靠近中心点），实现容易</p>
<p> 2) 聚类效果中上（依赖K的选择）</p>
<p> 3) 空间复杂度 <code>O(N)</code>，时间复杂度 <code>O(IKN)</code></p>
<blockquote>
<p><code>N</code> 为样本点个数，<code>K</code> 为中心点个数，<code>I</code> 为迭代次数</p>
</blockquote>
<p><strong>缺点：</strong></p>
<p> 1) 对离群点，噪声敏感 （中心点易偏移）</p>
<p> 2) 很难发现大小差别很大的簇及进行增量计算</p>
<p> 3) 结果不一定是全局最优，只能保证局部最优（与 <code>K</code> 的个数及初值选取有关）</p>
<h3 id="5-2-Canopy-算法配合初始聚类"><a href="#5-2-Canopy-算法配合初始聚类" class="headerlink" title="5.2 Canopy 算法配合初始聚类"></a>5.2 Canopy 算法配合初始聚类</h3><h4 id="5-2-1-实现流程"><a href="#5-2-1-实现流程" class="headerlink" title="5.2.1 实现流程"></a>5.2.1 实现流程</h4><p><img src="https://s2.ax1x.com/2020/02/24/38KJVe.png" alt="image-20190219190832599"></p>
<h4 id="5-2-2-优缺点"><a href="#5-2-2-优缺点" class="headerlink" title="5.2.2 优缺点"></a>5.2.2 优缺点</h4><p><strong>优点：</strong></p>
<p> 1) <code>Kmeans</code> 对噪声抗干扰较弱，通过 <code>Canopy</code> 对比，将较小的 <code>NumPoint</code> 的 <code>Cluster</code> 直接去掉有利于抗干扰。</p>
<p> 2) <code>Canopy</code> 选择出来的每个 <code>Canopy</code> 的 <code>centerPoint</code> 作为 <code>K</code> 会更精确。</p>
<p> 3) 只是针对每个 <code>Canopy</code> 的内做 <code>Kmeans</code> 聚类，减少相似计算的数量。</p>
<p><strong>缺点：</strong></p>
<p> 1) 算法中 <code>T1</code>、<code>T2</code> 的确定问题 ，依旧可能落入局部最优解</p>
<h3 id="5-3-K-means"><a href="#5-3-K-means" class="headerlink" title="5.3 K-means++"></a>5.3 K-means++</h3><p><img src="https://s2.ax1x.com/2020/02/24/38KvM6.png" alt="image-20190219233830941"></p>
<p><img src="https://s2.ax1x.com/2020/02/24/38MCIH.png" alt="image-20190219233845360"></p>
<p><img src="https://s2.ax1x.com/2020/02/24/38MkRI.png" alt="image-20190219233904862"></p>
<p><img src="https://s2.ax1x.com/2020/02/24/38Mudg.png" alt="image-20190219233921494"></p>
<p><code>kmeans++</code> 目的，让选择的质心尽可能的分散</p>
<p>如下图中，如果第一个质心选择在圆心，那么最优可能选择到的下一个点在 <code>P(A)</code> 这个区域（根据颜色进行划分）</p>
<p><img src="https://s2.ax1x.com/2020/02/24/38M1Wn.png" alt="image-20190219234135506"></p>
<h3 id="5-4-二分-k-means"><a href="#5-4-二分-k-means" class="headerlink" title="5.4 二分 k-means"></a>5.4 二分 k-means</h3><p><strong>实现流程：</strong></p>
<p>1) 所有点作为一个簇</p>
<p>2) 将该簇一分为二</p>
<p>3) 选择能最大限度降低聚类代价函数（也就是误差平方和）的簇划分为两个簇。</p>
<p>4) 以此进行下去，直到簇的数目等于用户给定的数目 <code>k</code>为止。</p>
<p><img src="https://s2.ax1x.com/2020/02/24/38M6OK.png" alt="image-20190323000108301"></p>
<p><strong>隐含的一个原则</strong></p>
<p>因为聚类的误差平方和能够衡量聚类性能，该值越小表示数据点越接近于他们的质心，聚类效果就越好。所以需要对误差平方和最大的簇进行再一次划分，因为误差平方和越大，表示该簇聚类效果越不好，越有可能是多个簇被当成了一个簇，所以我们首先需要对这个簇进行划分。</p>
<p>二分 <code>K</code> 均值算法可以加速 <code>K-means</code> 算法的执行速度，因为它的相似度计算少了并且不受初始化问题的影响，因为这里不存在随机点的选取，且每一步都保证了误差最小。</p>
<h3 id="5-5-k-medoids（k-中心聚类算法）"><a href="#5-5-k-medoids（k-中心聚类算法）" class="headerlink" title="5.5 k-medoids（k-中心聚类算法）"></a>5.5 k-medoids（k-中心聚类算法）</h3><p><code>K-medoids</code> 和 <code>K-means</code> 是有区别的，<strong>不一样的地方在于中心点的选取</strong></p>
<blockquote>
<p><code>K-means</code> 中，将中心点取为当前 <code>cluster</code> 中所有数据点的平均值，对异常点很敏感!</p>
<p><code>K-medoids</code> 中，将从当前 <code>cluster</code> 中选取到其他所有（当前 <code>cluster</code> 中的）点的距离之和最小的点作为中心点。</p>
</blockquote>
<p><img src="https://s2.ax1x.com/2020/02/24/38M7Of.png" alt="image-20190220000002208"></p>
<p><strong>算法流程：</strong></p>
<p>1) 总体 <code>n</code> 个样本点中任意选取 <code>k</code> 个点作为 <code>medoids</code></p>
<p>2) 按照与 <code>medoids</code> 最近的原则，将剩余的 <code>n-k</code> 个点分配到当前最佳的 <code>medoids</code> 代表的类中</p>
<p>3) 对于第 <code>i</code> 个类中除对应 <code>medoids</code> 点外的所有其他点，按顺序计算当其为新的 <code>medoids</code> 时，代价函数的值，遍历所有可能，选取代价函数最小时对应的点作为新的 <code>medoids</code></p>
<p>4) 重复2-3的过程，直到所有的 <code>medoids</code> 点不再发生变化或已达到设定的最大迭代次数</p>
<p>5) 产出最终确定的 <code>k</code> 个类</p>
<p><strong>k-medoids对噪声鲁棒性好。</strong></p>
<p>例：当一个 <code>cluster</code> 样本点只有少数几个，如（1,1）（1,2）（2,1）（1000,1000）。其中（1000,1000）是噪声。如果按照 <code>k-means</code> 质心大致会处在（1,1）（1000,1000）中间，这显然不是我们想要的。这时 <code>k-medoids</code> 就可以避免这种情况，他会在（1,1）（1,2）（2,1）（1000,1000）中选出一个样本点使 <code>cluster</code> 的绝对误差最小，计算可知一定会在前三个点中选取。</p>
<p><code>k-medoids</code> 只能对小样本起作用，样本大，速度就太慢了，当样本多的时候，少数几个噪音对 <code>k-means</code> 的质心影响也没有想象中的那么重，所以 <code>k-means</code> 的应用明显比 <code>k-medoids</code> 多。</p>
<h3 id="5-6-Kernel-k-means（了解）"><a href="#5-6-Kernel-k-means（了解）" class="headerlink" title="5.6 Kernel k-means（了解）"></a>5.6 Kernel k-means（了解）</h3><p><code>kernel k-means</code> 实际上，就是将每个样本进行一个投射到高维空间的处理，然后再将处理后的数据使用普通的 <code>k-means</code> 算法思想进行聚类。</p>
<p><img src="https://s2.ax1x.com/2020/02/24/38Qm11.png" alt="image-20190219235240810"></p>
<h3 id="5-7-ISODATA（了解）"><a href="#5-7-ISODATA（了解）" class="headerlink" title="5.7 ISODATA（了解）"></a>5.7 ISODATA（了解）</h3><p>类别数目随着聚类过程而变化；</p>
<p>对类别数会进行合并，分裂；</p>
<p>「合并」当聚类结果某一类中样本数太少，或两个类间的距离太近时</p>
<p>「分裂」当聚类结果中某一类的类内方差太大，将该类进行分裂</p>
<h3 id="5-8-Mini-Batch-K-Means（了解）"><a href="#5-8-Mini-Batch-K-Means（了解）" class="headerlink" title="5.8 Mini Batch K-Means（了解）"></a>5.8 Mini Batch K-Means（了解）</h3><p>适合大数据的聚类算法</p>
<p>大数据量是什么量级？通常当样本量大于1万做聚类时，就需要考虑选用<code>Mini Batch K-Means</code> 算法。</p>
<p><code>Mini Batch KMeans</code> 使用了 <code>Mini Batch</code>（分批处理）的方法对数据点之间的距离进行计算。</p>
<p><code>Mini Batch</code> 计算过程中不必使用所有的数据样本，而是从不同类别的样本中抽取一部分样本来代表各自类型进行计算。由于计算样本量少，所以会相应的减少运行时间，但另一方面抽样也必然会带来准确度的下降。</p>
<p>该算法的迭代步骤有两步：</p>
<p>1) 从数据集中随机抽取一些数据形成小批量，把他们分配给最近的质心</p>
<p>2) 更新质心</p>
<p>与 <code>Kmeans</code> 相比，数据的更新在每一个小的样本集上。对于每一个小批量，通过计算平均值得到更新质心，并把小批量里的数据分配给该质心，随着迭代次数的增加，这些质心的变化是逐渐减小的，直到质心稳定或者达到指定的迭代次数，停止计算。</p>
<h3 id="5-9-总结"><a href="#5-9-总结" class="headerlink" title="5.9 总结"></a>5.9 总结</h3><table>
<thead>
<tr>
<th><strong>优化方法</strong></th>
<th><strong>思路</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Canopy+kmeans</td>
<td>Canopy粗聚类配合kmeans</td>
</tr>
<tr>
<td>kmeans++</td>
<td>距离越远越容易成为新的质心</td>
</tr>
<tr>
<td>二分k-means</td>
<td>拆除SSE最大的簇</td>
</tr>
<tr>
<td>k-medoids</td>
<td>和kmeans选取中心点的方式不同</td>
</tr>
<tr>
<td>kernel kmeans</td>
<td>映射到高维空间</td>
</tr>
<tr>
<td>ISODATA</td>
<td>动态聚类</td>
</tr>
<tr>
<td>Mini-batch K-Means</td>
<td>大数据集分批聚类</td>
</tr>
</tbody></table>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法之逻辑回归</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<center>Editor：闫玉良</center>

<p>逻辑回归（<code>Logistic Regression</code>）是机器学习中的一种<strong>分类模型</strong>。虽然名字中带有「回归」，但它却不是回归算法，而是一种分类算法。由于此算法的简单和高效，在实际场景中应用非常广泛。也许有人很好奇，那为什么叫做「回归」而不是「分类」呢？</p>
<a id="more"></a>

<p><strong>答：</strong>名字中之所以包含「回归」，是因为其 <code>实质</code> ：是在线性回归的基础上，套用了一个逻辑函数。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1.应用场景"></a>1.应用场景</h2><p>1) 广告点击率</p>
<blockquote>
<p>点击率为点击者占整体浏览者的比例。整体浏览者分为点击者和非点击者。</p>
</blockquote>
<p>2) 验证垃圾邮件</p>
<blockquote>
<p>可判定邮件是垃圾邮件或者不是垃圾邮件。</p>
</blockquote>
<p>3) 患病</p>
<blockquote>
<p>是否患病。</p>
</blockquote>
<p>4) 金融诈骗</p>
<blockquote>
<p>判断此笔交易是否属于金融诈骗。</p>
</blockquote>
<p>5) 虚假账号</p>
<blockquote>
<p>是真实账号，还是虚假账号？</p>
</blockquote>
<p>通过以上示例，可以发现其特点，那就是<strong>同属于两个类别之间的判断</strong>。逻辑回归可谓是解决二分类问题的利器。</p>
<h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><p>要想熟悉逻辑回归，必须掌握以下两点：</p>
<p>1) 逻辑回归中，其输入值是什么？</p>
<p>2) 如何判断逻辑回归的输出？</p>
<h3 id="2-1-输入"><a href="#2-1-输入" class="headerlink" title="2.1 输入"></a>2.1 输入</h3><p><img src="https://s2.ax1x.com/2020/02/21/3nheuF.png" alt="逻辑回归输入.png"></p>
<p>逻辑回归的输入其实就是一个线性回归的结果。（正解决了大家对文章开始部分，介绍逻辑回归实质时那句话的疑问）</p>
<h3 id="2-2-激活函数"><a href="#2-2-激活函数" class="headerlink" title="2.2 激活函数"></a>2.2 激活函数</h3><p>1) <code>sigmoid</code> 函数</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3n4ZGt.png" alt="sigmoid公式.png"></p>
<p>2) 判断标准：回归的结果输入到 <code>sigmoid</code> 函数当中，输出结果为 [0, 1] 区间中的一个概率值，默认为0.5为阈值</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3n40Z4.png" alt="sigmoid图像.png"></p>
<blockquote>
<p>逻辑回归最终的分类是通过属于某个类别的概率值来判断是否属于这个类别，并且这个类别默认标记为1(正例)，另外的一个类别会标记为0(反例)。（方便损失计算）</p>
</blockquote>
<p><strong>输出结果解释：</strong>假设有两个类别 <code>A</code> 和 <code>B</code>，并且概率值为属于 <code>A(1)</code> 类别的概率值。现在有一个样本输入到逻辑回归，输出结果为0.6，这个概率值超过0.5，意味着训练或者预测的结果就是 <code>A(1)</code> 类别。反之，如果得出结果为0.3，那么训练或者预测结果就为 <code>B(0)</code> 类别。</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3nIaE4.png" alt="逻辑回归运算过程.png"></p>
<p>当预测结果不准确时，在线性回归中使用了均方误差衡量损失，那么对于逻辑回归，该如何去衡量此损失呢？</p>
<h2 id="3-损失及优化"><a href="#3-损失及优化" class="headerlink" title="3.损失及优化"></a>3.损失及优化</h2><h3 id="3-1-损失"><a href="#3-1-损失" class="headerlink" title="3.1 损失"></a>3.1 损失</h3><p>逻辑回归的损失，称之为<strong>对数似然损失</strong>，公式如下：</p>
<p>1) 分开类别：</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3nIoxP.png" alt="单个对数似然损失.png"></p>
<p>怎么理解单个的式子呢？此时就需要用到 <code>log</code> 的函数图像了：</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3noka4.png" alt="image-20190221142055367"></p>
<p>2) 综合完整损失函数</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3noDoQ.png" alt="完整对数似然损失.png"></p>
<blockquote>
<p>看到这个式子，其实同我们认识的信息熵类似。</p>
<p>信息熵这个词是 C.E.Shannon（香农）从热力学中借用过来的。热力学中的热熵是表示分子状态混乱程度的物理量。香农用信息熵的概念来描述信源的不确定度，把信息中排除了冗余后的平均信息量称为「信息熵」</p>
</blockquote>
<p>接下来带入激活函数位置处的例子来计算一遍，就能理解其意义了。</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3noLy6.png" alt="损失计算过程.png"></p>
<blockquote>
<p>我们已经知道，<code>log(P)</code> 中 <code>P</code> 值越大，结果越小，所以可以对着这个损失的式子去分析</p>
</blockquote>
<h3 id="3-2-优化"><a href="#3-2-优化" class="headerlink" title="3.2 优化"></a>3.2 优化</h3><p>同样使用梯度下降优化算法，去减少损失函数的值。通过更新逻辑回归前面对应算法的权重参数，<strong>提升原本属于1类别的概率，降低原本是0类别的概率。</strong></p>
<h2 id="4-分类评估方法"><a href="#4-分类评估方法" class="headerlink" title="4.分类评估方法"></a>4.分类评估方法</h2><h3 id="4-1-混淆矩阵"><a href="#4-1-混淆矩阵" class="headerlink" title="4.1 混淆矩阵"></a>4.1 混淆矩阵</h3><p>在分类任务下，预测结果(Predicted Condition)与正确标记(True Condition)之间存在四种不同的组合，构成混淆矩阵(适用于多分类)</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3n7SBT.png" alt="image-20190321103913068"></p>
<h3 id="4-2-精确率-Precision-与召回率-Recall"><a href="#4-2-精确率-Precision-与召回率-Recall" class="headerlink" title="4.2 精确率(Precision)与召回率(Recall)"></a>4.2 精确率(Precision)与召回率(Recall)</h3><p>1) <strong>精确率：</strong>预测结果为正例样本中真实为正例的比例（了解）</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3n7svq.png" alt="image-20190321103930761"></p>
<p>2) <strong>召回率：</strong>真实结果为正例的样本中预测结果为正例的比例（查得全，对正样本的区分能力）</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3n7f54.png" alt="image-20190321103947092"></p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习工程师必知的十大算法</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E7%9F%A5%E7%9A%84%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>It is no doubt that the sub-field of machine learning / artificial intelligence has increasingly gained more popularity in the past couple of years. As Big Data is the hottest trend in the tech industry at the moment, machine learning is incredibly powerful to make predictions or calculated suggestions based on large amounts of data. Some of the most common examples of machine learning are Netflix’s algorithms to make movie suggestions based on movies you have watched in the past or Amazon’s algorithms that recommend books based on books you have bought before.</p>
<p>毫无疑问，机器学习 / 人工智能的子领域在过去几年越来越受欢迎。目前大数据在科技行业已经炙手可热，而基于大量数据来进行预测或者得出建议的机器学习无疑是非常强大的。一些最常见的机器学习例子，比如 Netflix 的算法可以根据你以前看过的电影来进行电影推荐，而 Amazon 的算法则可以根据你以前买过的书来推荐书籍。</p>
<p>So if you want to learn more about machine learning, how do you start?</p>
<p>所以如果你想了解更多有关机器学习的内容，那么你该如何入门？</p>
<a id="more"></a>

<blockquote>
<p>本文由 James Le 所写的英文文章 The 10 Algorithms Machine Learning Engineers Need to Know 翻译而来</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
</blockquote>
<p>For me, my first introduction is when I took an Artificial Intelligence class when I was studying abroad in Copenhagen. My lecturer is a full-time Applied Math and CS professor at the Technical University of Denmark, in which his research areas are logic and artificial, focusing primarily on the use of logic to model human-like planning, reasoning and problem solving. The class was a mix of discussion of theory/core concepts and hands-on problem solving. The textbook that we used is one of the AI classics: <a href="https://www.amazon.com/Artificial-Intelligence-Modern-Approach-3rd/dp/0136042597" target="_blank" rel="noopener">Peter Norvig’s <em>Artificial Intelligence — A Modern Approach</em></a>, in which we covered major topics including intelligent agents, problem-solving by searching, adversarial search, probability theory, multi-agent systems, social AI, philosophy/ethics/future of AI. At the end of the class, in a team of 3, we implemented simple search-based agents solving transportation tasks in a virtual environment as a programming project.</p>
<p>对于我来说，我的入门课程是我在哥本哈根出国留学时参加的人工智能课。当时我的讲师是丹麦技术大学（Technical University of Denmark）的应用数学和计算机科学的全职教授，他的研究方向是逻辑与人工智能，侧重于使用逻辑学来对人性化的规划、推理和解决问题进行建模。这个课程包括对理论 / 核心概念的讨论和自己动手解决问题。我们使用的教材是 AI 经典之一：Peter Norvig 的 Artificial Intelligence—A Modern Approach（中文译本：<a href="https://book.douban.com/subject/6730363/" target="_blank" rel="noopener">《人工智能：一种现代的方法》</a>），这本书主要讲了智能体、搜索解决问题、对抗搜索、概率论、多智能体系统、社会AI 和AI 的哲学/ 伦理/ 未来等等。在课程结束时，我们三个人的团队实现了一个简单的编程项目，也就是基于搜索的智能体解决虚拟环境中的运输任务问题。</p>
<p>I have learned a tremendous amount of knowledge thanks to that class, and decided to keep learning about this specialized topic. In the last few weeks, I have been multiple tech talks in San Francisco on deep learning, neural networks, data architecture — and a Machine Learning conference with a lot of well-known professionals in the field. Most importantly, I enrolled in Udacity’s <a href="https://www.udacity.com/course/intro-to-machine-learning--ud120" target="_blank" rel="noopener"><em>Intro to Machine Learning</em></a> online course in the beginning of June and has just finished it a few days ago. In this post, I want to share some of the most common machine learning algorithms that I learned from the course.</p>
<p>在那门课程上我已经学到了很多知识，并决定继续学习相关的课题。在过去的几个星期里，我在旧金山参加了多次相关的技术讲座，涉及到深度学习、神经网络和数据结构，并且参加了一个有很多该领域的知名专家学者参加的机器学习会议。最重要的是，我在 6 月初参加了 Udacity 上的<a href="https://cn.udacity.com/course/intro-to-machine-learning--ud120" target="_blank" rel="noopener"> Intro to Machine Learning（机器学习入门）</a>在线课程，前几天才完成。在这篇文章中，我想分享一下我从课程中学到的一些最常用的机器学习算法。</p>
<p>Machine learning algorithms can be divided into 3 broad categories — supervised learning, unsupervised learning, and reinforcement learning.Supervised learning is useful in cases where a property (<em>label</em>) is available for a certain dataset (<em>training set</em>), but is missing and needs to be predicted for other instances. Unsupervised learning is useful in cases where the challenge is to discover implicit relationships in a given <em>unlabeled</em> dataset (items are not pre-assigned). Reinforcement learning falls between these 2 extremes — there is some form of feedback available for each predictive step or action, but no precise label or error message. Since this is an intro class, I didn’t learn about reinforcement learning, but I hope that 10 algorithms on supervised and unsupervised learning will be enough to keep you interested.</p>
<p>机器学习算法可以分为三大类：监督学习、无监督学习和强化学习。监督学习可用于一个特定的数据集（训练集）具有某一属性（标签），但是其他数据没有标签或者需要预测标签的情况。无监督学习可用于给定的没有标签的数据集（数据不是预分配好的），目的就是要找出数据间的潜在关系。强化学习位于这两者之间，每次预测都有一定形式的反馈，但是没有精确的标签或者错误信息。因为这是一个介绍课程，我没有学习过强化学习的相关内容，但是我希望以下 10 个关于监督学习和无监督学习的算法足以让你感兴趣。</p>
<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><h3 id="1-决策树（Decision-Trees）"><a href="#1-决策树（Decision-Trees）" class="headerlink" title="1. 决策树（Decision Trees）"></a>1. 决策树（Decision Trees）</h3><p>A decision tree is a decision support tool that uses a tree-like graph or model of decisions and their possible consequences, including chance-event outcomes, resource costs, and utility. Take a look at the image to get a sense of how it looks like.</p>
<p>决策树是一个决策支持工具，它使用树形图或者决策模型以及可能性序列，包括偶然事件的结果、资源成本和效用。下图是其基本原理：</p>
<p><img src="https://static001.infoq.cn/resource/image/03/2f/03196b63116045238bd90168de7fa02f.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>From a business decision point of view, a decision tree is the minimum number of yes/no questions that one has to ask, to assess the probability of making a correct decision, most of the time. As a method, it allows you to approach the problem in a structured and systematic way to arrive at a logical conclusion.</p>
<p>从业务决策的角度来看，决策树是人们必须了解的最少的是 / 否问题，这样才能评估大多数时候做出正确决策的概率。作为一种方法，它允许你以结构化和系统化的方式来解决问题，从而得出合乎逻辑的结论。</p>
<h3 id="2-朴素贝叶斯分类-Naive-Bayesian-classification"><a href="#2-朴素贝叶斯分类-Naive-Bayesian-classification" class="headerlink" title="2. 朴素贝叶斯分类 (Naive Bayesian classification)"></a>2. 朴素贝叶斯分类 (Naive Bayesian classification)</h3><p>Naive Bayes classifiers are a family of simple probabilistic classifiers based on applying Bayes’ theorem with strong (naive) independence assumptions between the features. The featured image is the equation — with P(A|B) is posterior probability, P(B|A) is likelihood, P(A) is class prior probability, and P(B) is predictor prior probability.</p>
<p>朴素贝叶斯分类器是一类简单的概率分类器，它基于贝叶斯定理和特征间的强大的（朴素的）独立假设。图中是贝叶斯公式，其中 P（A|B）是后验概率，P（B|A）是似然，P（A）是类先验概率，P（B）是预测先验概率。</p>
<p><img src="https://static001.infoq.cn/resource/image/02/82/02afc9957795347a9529a71b0df68082.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>Some of real world examples are:</p>
<ul>
<li>To mark an email as spam or not spam</li>
<li>Classify a news article about technology, politics, or sports</li>
<li>Check a piece of text expressing positive emotions, or negative emotions?</li>
<li>Used for face recognition software.</li>
</ul>
<p>一些应用例子:</p>
<ul>
<li>判断垃圾邮件</li>
<li>对新闻的类别进行分类，比如科技、政治、运动</li>
<li>判断文本表达的感情是积极的还是消极的</li>
<li>人脸识别</li>
</ul>
<h3 id="3-最小二乘法（Ordinary-Least-Squares-Regression）"><a href="#3-最小二乘法（Ordinary-Least-Squares-Regression）" class="headerlink" title="3. 最小二乘法（Ordinary Least Squares Regression）"></a>3. 最小二乘法（Ordinary Least Squares Regression）</h3><p>If you know statistics, you probably have heard of linear regression before. Least squares is a method for performing linear regression. You can think of linear regression as the task of fitting a straight line through a set of points. There are multiple possible strategies to do this, and “ordinary least squares” strategy go like this — You can draw a line, and then for each of the data points, measure the vertical distance between the point and the line, and add these up; the fitted line would be the one where this sum of distances is as small as possible.</p>
<p>如果你懂统计学的话，你可能以前听说过线性回归。最小二乘法是一种计算线性回归的方法。你可以将线性回归看做通过一组点来拟合一条直线。实现这个有很多种方法，“最小二乘法”就像这样：你可以画一条直线，然后对于每一个数据点，计算每个点到直线的垂直距离，然后把它们加起来，那么最后得到的拟合直线就是距离和尽可能小的直线。</p>
<p><img src="https://static001.infoq.cn/resource/image/52/dc/528f69da2ec5c98287f968aa8c1d31dc.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>Linear refers the kind of model you are using to fit the data, while least squares refers to the kind of error metric you are minimizing over.</p>
<p>线性指的是你用来拟合数据的模型，而最小二乘法指的是你最小化的误差度量。</p>
<h3 id="4-逻辑回归-Logistic-Regression"><a href="#4-逻辑回归-Logistic-Regression" class="headerlink" title="4. 逻辑回归 (Logistic Regression)"></a>4. 逻辑回归 (Logistic Regression)</h3><p>Logistic regression is a powerful statistical way of modeling a binomial outcome with one or more explanatory variables. It measures the relationship between the categorical dependent variable and one or more independent variables by estimating probabilities using a logistic function, which is the cumulative logistic distribution.</p>
<p>逻辑回归是一个强大的统计学方法，它可以用一个或多个解释变量来表示一个二项式结果。它通过使用逻辑函数来估计概率，从而衡量类别依赖变量和一个或多个独立变量之间的关系，后者服从累计逻辑分布。</p>
<p><img src="https://static001.infoq.cn/resource/image/f5/6c/f559c1b4f5a61b579b0c9e906a439f6c.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>In general, regressions can be used in real-world applications such as:</p>
<ul>
<li>Credit Scoring</li>
<li>Measuring the success rates of marketing campaigns</li>
<li>Predicting the revenues of a certain product</li>
<li>Is there going to be an earthquake on a particular day?</li>
</ul>
<p>总的来说，逻辑回归可以用于以下几个真实应用场景：</p>
<ul>
<li>信用评分</li>
<li>计算营销活动的成功率</li>
<li>预测某个产品的收入</li>
<li>特定的某一天是否会发生地震</li>
</ul>
<h3 id="5-支持向量机（Support-Vector-Machine，SVM）"><a href="#5-支持向量机（Support-Vector-Machine，SVM）" class="headerlink" title="5. 支持向量机（Support Vector Machine，SVM）"></a>5. 支持向量机（Support Vector Machine，SVM）</h3><p>SVM is binary classification algorithm. Given a set of points of 2 types in N dimensional place, SVM generates a (N — 1) dimensional hyperplane to separate those points into 2 groups. Say you have some points of 2 types in a paper which are linearly separable. SVM will find a straight line which separates those points into 2 types and situated as far as possible from all those points.</p>
<p>SVM 是二进制分类算法。给定 N 维坐标下两种类型的点，SVM 生成（N-1）维的超平面来将这些点分成两组。假设你在平面上有两种类型的可以线性分离的点，SVM 将找到一条直线，将这些点分成两种类型，并且这条直线尽可能远离所有这些点。</p>
<p><img src="https://static001.infoq.cn/resource/image/b8/7d/b82961e4171788ac7433c4b4e219327d.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>In terms of scale, some of the biggest problems that have been solved using SVMs (with suitably modified implementations) are display advertising, human splice site recognition, image-based gender detection, large-scale image classification…</p>
<p>从规模上看，使用 SVM（经过适当的修改）解决的一些最大的问题包括显示广告、人类剪切位点识别（human splice site recognition）、基于图像的性别检测，大规模图像分类……</p>
<h3 id="6-集成方法（Ensemble-methods）"><a href="#6-集成方法（Ensemble-methods）" class="headerlink" title="6. 集成方法（Ensemble methods）"></a>6. 集成方法（Ensemble methods）</h3><p>Ensemble methods are learning algorithms that construct a set of classifiers and then classify new data points by taking a weighted vote of their predictions. The original ensemble method is Bayesian averaging, but more recent algorithms include error-correcting output coding, bagging, and boosting.</p>
<p>集成方法是学习算法，它通过构建一组分类器，然后通过它们的预测结果进行加权投票来对新的数据点进行分类。原始的集成方法是贝叶斯平均，但是最近的算法包括纠错输出编码、Bagging 和 Boosting。</p>
<p><img src="https://static001.infoq.cn/resource/image/3f/30/3f398562a900001e21e141085b286530.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>So how do ensemble methods work and why are they superior to individual models?</p>
<ul>
<li>They average out biases: If you average a bunch of democratic-leaning polls and republican-leaning polls together, you will get an average something that isn’t leaning either way.</li>
<li>They reduce the variance: The aggregate opinion of a bunch of models is less noisy than the single opinion of one of the models. In finance, this is called diversification — a mixed portfolio of many stocks will be much less variable than just one of the stocks alone. This is why your models will be better with more data points rather than fewer.</li>
<li>They are unlikely to over-fit: If you have individual models that didn’t over-fit, and you are combining the predictions from each model in a simple way (average, weighted average, logistic regression), then there’s no room for over-fitting.</li>
</ul>
<p>那么集成方法如何工作？并且为什么它们要优于单个模型？</p>
<ul>
<li>它们平均了单个模型的偏差：如果你将民主党的民意调查和共和党的民意调查在一起平均化，那么你将得到一个均衡的结果，不偏向任何一方。</li>
<li>它们减少了方差：一组模型的总体意见比其中任何一个模型的单一意见更加统一。在金融领域，这就是所谓的多元化，有许多股票的组合比一个单独的股票的不确定性更少，这也为什么你的模型在数据多的情况下会更好的原因。</li>
<li>它们不太可能过拟合：如果你有单个的模型没有过拟合，那么把这些模型的预测简单结合起来（平均、加权平均、逻辑回归），那么最后得到的模型也不会过拟合。</li>
</ul>
<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><h3 id="7-聚类算法（Clustering-Algorithms）"><a href="#7-聚类算法（Clustering-Algorithms）" class="headerlink" title="7. 聚类算法（Clustering Algorithms）"></a>7. 聚类算法（Clustering Algorithms）</h3><p>Clustering is the task of grouping a set of objects such that objects in the same group (<em>cluster</em>) are more similar to each other than to those in other groups.</p>
<p>聚类是将一系列对象分组的任务，目标是使相同组（集群）中的对象之间比其他组的对象更相似。</p>
<p><img src="https://static001.infoq.cn/resource/image/f9/0a/f9262a91a2fdb75ef398a082dc71c00a.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>Every clustering algorithm is different, and here are a couple of them:</p>
<ul>
<li>Centroid-based algorithms</li>
<li>Connectivity-based algorithms</li>
<li>Density-based algorithms</li>
<li>Probabilistic</li>
<li>Dimensionality Reduction</li>
<li>Neural networks / Deep Learning</li>
</ul>
<p>每一种聚类算法都不相同，下面是一些例子：</p>
<ul>
<li>基于质心的算法</li>
<li>基于连接的算法</li>
<li>基于密度的算法</li>
<li>概率</li>
<li>降维</li>
<li>神经网络 / 深度学习</li>
</ul>
<h3 id="8-主成分分析（Principal-Component-Analysis，PCA）"><a href="#8-主成分分析（Principal-Component-Analysis，PCA）" class="headerlink" title="8. 主成分分析（Principal Component Analysis，PCA）"></a>8. 主成分分析（Principal Component Analysis，PCA）</h3><p>PCA is a statistical procedure that uses an orthogonal transformation to convert a set of observations of possibly correlated variables into a set of values of linearly uncorrelated variables called principal components.</p>
<p>PCA 是一个统计学过程，它通过使用正交变换将一组可能存在相关性的变量的观测值转换为一组线性不相关的变量的值，转换后的变量就是所谓的主分量。</p>
<p><img src="https://static001.infoq.cn/resource/image/9e/92/9ec810f0a300d725e7226750e8d09e92.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>Some of the applications of PCA include compression, simplifying data for easier learning, visualization. Notice that domain knowledge is very important while choosing whether to go forward with PCA or not. It is not suitable in cases where data is noisy (all the components of PCA have quite a high variance).</p>
<p>PCA 的一些应用包括压缩、简化数据便于学习、可视化等。请注意，领域知识在选择是否继续使用 PCA 时非常重要。 数据嘈杂的情况（PCA 的所有成分具有很高的方差）并不适用。</p>
<h3 id="9-奇异值分解（Singular-Value-Decomposition，SVD）"><a href="#9-奇异值分解（Singular-Value-Decomposition，SVD）" class="headerlink" title="9. 奇异值分解（Singular Value Decomposition，SVD）"></a>9. 奇异值分解（Singular Value Decomposition，SVD）</h3><p>In linear algebra, SVD is a factorization of a real complex matrix. For a given <em>m \</em> n* matrix M, there exists a decomposition such that M = UΣV, where U and V are unitary matrices and Σ is a diagonal matrix.</p>
<p>在线性代数中，SVD 是复杂矩阵的因式分解。对于给定的 m * n 矩阵 M，存在分解使得 M=UΣV，其中 U 和 V 是酉矩阵，Σ是对角矩阵。</p>
<p><img src="https://static001.infoq.cn/resource/image/a2/f8/a254a50da32558e12f4c170a32ecdcf8.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>PCA is actually a simple application of SVD. In computer vision, the 1st face recognition algorithms used PCA and SVD in order to represent faces as a linear combination of “eigenfaces”, do dimensionality reduction, and then match faces to identities via simple methods; although modern methods are much more sophisticated, many still depend on similar techniques.</p>
<p>实际上，PCA 是 SVD 的一个简单应用。在计算机视觉中，第一个人脸识别算法使用 PCA 和 SVD 来将面部表示为“特征面”的线性组合，进行降维，然后通过简单的方法将面部匹配到身份，虽然现代方法更复杂，但很多方面仍然依赖于类似的技术。</p>
<h3 id="10-独立成分分析（Independent-Component-Analysis，ICA）"><a href="#10-独立成分分析（Independent-Component-Analysis，ICA）" class="headerlink" title="10. 独立成分分析（Independent Component Analysis，ICA）"></a>10. 独立成分分析（Independent Component Analysis，ICA）</h3><p>ICA is a statistical technique for revealing hidden factors that underlie sets of random variables, measurements, or signals. ICA defines a generative model for the observed multivariate data, which is typically given as a large database of samples. In the model, the data variables are assumed to be linear mixtures of some unknown latent variables, and the mixing system is also unknown. The latent variables are assumed non-gaussian and mutually independent, and they are called independent components of the observed data.</p>
<p>ICA 是一种统计技术，主要用于揭示随机变量、测量值或信号集中的隐藏因素。ICA 对观测到的多变量数据定义了一个生成模型，这通常是作为样本的一个大的数据库。在模型中，假设数据变量由一些未知的潜在变量线性混合，混合方式也是未知的。潜在变量被假定为非高斯分布并且相互独立，它们被称为观测数据的独立分量。</p>
<p><img src="https://static001.infoq.cn/resource/image/00/a1/007e627062309d6f80e25e1f935d11a1.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>ICA is related to PCA, but it is a much more powerful technique that is capable of finding the underlying factors of sources when these classic methods fail completely. Its applications include digital images, document databases, economic indicators and psychometric measurements.</p>
<p>ICA 与 PCA 有关，但是当这些经典方法完全失效时，它是一种更强大的技术，能够找出源的潜在因素。 其应用包括数字图像、文档数据库、经济指标和心理测量。</p>
<p>Now go forth and wield your understanding of algorithms to create machine learning applications that make better experiences for people everywhere.</p>
<p>现在运用你对这些算法的理解去创造机器学习应用，为世界各地的人们带来更好的体验吧。</p>
<blockquote>
<p>本文译者：尚剑</p>
<p>本文编辑：闫玉良</p>
<p>中文地址：<a href="https://www.infoq.cn/article/10-algorithms-machine-learning-engineers-need-to-know/" target="_blank" rel="noopener">https://www.infoq.cn/article/10-algorithms-machine-learning-engineers-need-to-know/</a></p>
<p><strong>查看英文原文：<a href="http://www.kdnuggets.com/2016/08/10-algorithms-machine-learning-engineers.html/2" target="_blank" rel="noopener"> The 10 Algorithms Machine Learning Engineers Need to Know</a></strong></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法之集成学习</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B9%8B%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<center>Editor：闫玉良</center>

<p>分类算法中有一种极其重要的算法「集成学习」</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-集成学习算法简介"><a href="#1-集成学习算法简介" class="headerlink" title="1.集成学习算法简介"></a>1.集成学习算法简介</h2><h3 id="1-1-什么是集成学习"><a href="#1-1-什么是集成学习" class="headerlink" title="1.1 什么是集成学习"></a>1.1 什么是集成学习</h3><p><img src="https://s2.ax1x.com/2020/02/23/3lrA4x.png" alt="image-20190214154128155"></p>
<p>集成学习通过建立几个模型来解决单一预测问题。它的工作原理是<strong>生成多个 分类器/模型 **，各自独立地学习和作出预测。</strong>这些预测最后结合成组合预测，因此优于任何一个单分类的做出预测。**</p>
<h3 id="1-2-复习：机器学习的两个核心任务"><a href="#1-2-复习：机器学习的两个核心任务" class="headerlink" title="1.2 复习：机器学习的两个核心任务"></a>1.2 复习：机器学习的两个核心任务</h3><p><img src="https://s2.ax1x.com/2020/02/23/3lrmvD.png" alt="image-20190214155454695"></p>
<h3 id="1-3-集成学习中-boosting-和-Bagging"><a href="#1-3-集成学习中-boosting-和-Bagging" class="headerlink" title="1.3 集成学习中 boosting 和 Bagging"></a>1.3 集成学习中 boosting 和 Bagging</h3><p><img src="https://s2.ax1x.com/2020/02/23/3lr1UI.png" alt="image-20190214155522366"></p>
<p>只要单分类器的表现不太差，集成学习的结果总是要好于单分类器的.</p>
<h2 id="2-Bagging-和-随机森林"><a href="#2-Bagging-和-随机森林" class="headerlink" title="2.Bagging 和 随机森林"></a>2.Bagging 和 随机森林</h2><h3 id="2-1-Bagging-集成原理"><a href="#2-1-Bagging-集成原理" class="headerlink" title="2.1 Bagging 集成原理"></a>2.1 Bagging 集成原理</h3><p><strong>目标：</strong>把下面的圈和方块进行分类</p>
<p><img src="https://s2.ax1x.com/2020/02/23/3lrLse.png" alt="image-20190214160011298"></p>
<p><strong>实现过程：</strong></p>
<p>1) 采样不同数据集</p>
<p><img src="https://s2.ax1x.com/2020/02/23/3lsSit.png" alt="image-20190214160047813"></p>
<p>2) 训练分类器</p>
<p><img src="https://s2.ax1x.com/2020/02/23/3lsuWV.png" alt="image-20190214160135609"></p>
<p>3) 平权投票，获取最终结果</p>
<p><img src="https://s2.ax1x.com/2020/02/23/3lsBOe.png" alt="image-20190214160208609"></p>
<p>4) 主要实现过程小结</p>
<p><img src="https://s2.ax1x.com/2020/02/23/3ls2fP.png" alt="image-20190214160248137"></p>
<h3 id="2-2-随机森林构造过程"><a href="#2-2-随机森林构造过程" class="headerlink" title="2.2 随机森林构造过程"></a>2.2 随机森林构造过程</h3><p>在机器学习中，<strong>随机森林是一个包含多个决策树的分类器</strong>，并且其输出的类别是由个别树输出的类别的众数而定。</p>
<p><strong>随机森林</strong> <strong>= Bagging +</strong> <strong>决策树</strong></p>
<p><img src="https://s2.ax1x.com/2020/02/23/3lyGjS.png" alt="image-20190214160355272"></p>
<p>例如，你训练了5棵树, 其中有4棵树的结果是 <code>True</code>，1棵树的结果是 <code>False</code>，那么最终投票结果就是 <code>True</code></p>
<p><strong>随机森林够造过程中的关键步骤</strong>（用 <code>N</code> 来表示训练用例(样本)的个数，<code>M</code> 表示特征数目）：</p>
<p><strong>1）一次随机选出一个样本，有放回的抽样，重复 <code>N</code> 次（有可能出现重复的样本）</strong></p>
<p><strong>2） 随机去选出 <code>m</code> 个特征，<code>m&lt;&lt;M</code> ，建立决策树</strong> </p>
<p><strong>思考</strong></p>
<p>1.为什么要随机抽样训练集？　　</p>
<blockquote>
<p>如果不进行随机抽样，每棵树的训练集都一样，那么最终训练出的树分类结果也是完全一样的</p>
</blockquote>
<p>2.为什么要有放回地抽样？</p>
<blockquote>
<p>如果不是有放回的抽样，那么每棵树的训练样本都是不同的，都是没有交集的，这样每棵树都是「有偏的」，都是绝对「片面的」（当然这样说可能不对），也就是说每棵树训练出来都是有很大的差异的；而随机森林最后分类取决于多棵树（弱分类器）的投票表决。</p>
</blockquote>
<h3 id="2-3-随机森林-api-介绍"><a href="#2-3-随机森林-api-介绍" class="headerlink" title="2.3 随机森林 api 介绍"></a>2.3 随机森林 api 介绍</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sklearn.ensemble.RandomForestClassifier(n_estimators=<span class="number">10</span>, criterion=<span class="string">"gini"</span>, max_depth=<span class="literal">None</span>, bootstrap=<span class="literal">True</span>, random_state=<span class="literal">None</span>, min_samples_split=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">- n_estimators：integer，optional（default = <span class="number">10</span>）森林里的树木数量<span class="number">120</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">500</span>,<span class="number">800</span>,<span class="number">1200</span></span><br><span class="line">- Criterion：string，可选（default =<span class="string">"gini"</span>）分割特征的测量方法</span><br><span class="line">- max_depth：integer或<span class="literal">None</span>，可选（默认=无）树的最大深度 <span class="number">5</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">25</span>,<span class="number">30</span></span><br><span class="line">- max_features=<span class="string">"auto”,每个决策树的最大特征数量</span></span><br><span class="line"><span class="string">  - If "</span>auto<span class="string">", then `max_features=sqrt(n_features)`.</span></span><br><span class="line"><span class="string">  - If "</span>sqrt<span class="string">", then `max_features=sqrt(n_features)`(same as "</span>auto<span class="string">").</span></span><br><span class="line"><span class="string">  - If "</span>log2<span class="string">", then `max_features=log2(n_features)`.</span></span><br><span class="line"><span class="string">  - If None, then `max_features=n_features`.</span></span><br><span class="line"><span class="string">- bootstrap：boolean，optional（default = True）是否在构建树时使用放回抽样</span></span><br><span class="line"><span class="string">- min_samples_split:节点划分最少样本数</span></span><br><span class="line"><span class="string">- min_samples_leaf:叶子节点的最小样本数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 超参数：n_estimator, max_depth, min_samples_split,min_samples_leaf</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-随机森林预测案例"><a href="#2-4-随机森林预测案例" class="headerlink" title="2.4 随机森林预测案例"></a>2.4 随机森林预测案例</h3><p>1) 实例化随机森林</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机森林去进行预测</span></span><br><span class="line">rf = RandomForestClassifier()</span><br></pre></td></tr></table></figure>

<p>2) 定义超参数的选择列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">param = &#123;<span class="string">"n_estimators"</span>: [<span class="number">120</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">500</span>,<span class="number">800</span>,<span class="number">1200</span>], <span class="string">"max_depth"</span>: [<span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">30</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>3) 使用 <code>GridSearchCV</code> 进行网格搜索</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超参数调优</span></span><br><span class="line">gc = GridSearchCV(rf, param_grid=param, cv=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">gc.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"随机森林预测的准确率为："</span>, gc.score(x_test, y_test))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：(1) 随机森林的建立过程；(2) 树的深度、树的个数等需要进行超参数调优</p>
</blockquote>
<h3 id="2-5-bagging-集成优点"><a href="#2-5-bagging-集成优点" class="headerlink" title="2.5 bagging 集成优点"></a>2.5 bagging 集成优点</h3><p><strong>Bagging + 决策树/线性回归/逻辑回归/深度学习… = bagging集成学习方法</strong></p>
<p>经过上面方式组成的集成学习方法:</p>
<p><strong>1) 均可在原有算法上提高约2%左右的泛化正确率</strong></p>
<p><strong>2) 简单, 方便, 通用</strong></p>
<h2 id="3-Boosting"><a href="#3-Boosting" class="headerlink" title="3.Boosting"></a>3.Boosting</h2><h3 id="3-1-boosting-集成原理"><a href="#3-1-boosting-集成原理" class="headerlink" title="3.1 boosting 集成原理"></a>3.1 boosting 集成原理</h3><h4 id="3-1-1-什么是-boosting"><a href="#3-1-1-什么是-boosting" class="headerlink" title="3.1.1 什么是 boosting"></a>3.1.1 什么是 boosting</h4><p><img src="https://s2.ax1x.com/2020/02/23/3lcbtA.png" alt="image-20190214160534929"></p>
<p><strong>随着学习的积累从弱到强</strong></p>
<p><strong>简而言之：每新加入一个弱学习器，整体能力就会得到提升</strong></p>
<p>代表算法：<code>Adaboost</code>，<code>GBDT</code>，<code>XGBoost</code></p>
<h4 id="3-1-2-实现过程"><a href="#3-1-2-实现过程" class="headerlink" title="3.1.2 实现过程"></a>3.1.2 实现过程</h4><h5 id="1-训练第一个学习器"><a href="#1-训练第一个学习器" class="headerlink" title="1) 训练第一个学习器"></a>1) 训练第一个学习器</h5><p><img src="https://s2.ax1x.com/2020/02/23/3lgVXT.png" alt="image-20190214160657608"></p>
<h5 id="2-调整数据分布"><a href="#2-调整数据分布" class="headerlink" title="2) 调整数据分布"></a>2) 调整数据分布</h5><p><img src="https://s2.ax1x.com/2020/02/23/3lggHg.png" alt="image-20190214160727582"></p>
<h5 id="3-训练第二个学习器"><a href="#3-训练第二个学习器" class="headerlink" title="3) 训练第二个学习器"></a>3) 训练第二个学习器</h5><p><img src="https://s2.ax1x.com/2020/02/23/3lg4Cn.png" alt="image-20190214160805813"></p>
<h5 id="4-再次调整数据分布"><a href="#4-再次调整数据分布" class="headerlink" title="4) 再次调整数据分布"></a>4) 再次调整数据分布</h5><p><img src="https://s2.ax1x.com/2020/02/23/3lgovV.png" alt="image-20190214160900951"></p>
<h5 id="5-依次训练学习器，调整数据分布"><a href="#5-依次训练学习器，调整数据分布" class="headerlink" title="5) 依次训练学习器，调整数据分布"></a>5) 依次训练学习器，调整数据分布</h5><p><img src="https://s2.ax1x.com/2020/02/23/3lgOUJ.png" alt="image-20190214160951473"></p>
<h5 id="6-整体过程实现"><a href="#6-整体过程实现" class="headerlink" title="6) 整体过程实现"></a>6) 整体过程实现</h5><p><img src="https://s2.ax1x.com/2020/02/23/3l2Z8I.png" alt="image-20190214161215163"></p>
<p><strong>关键点：如何确认投票权重？如何调整数据分布？</strong></p>
<p><img src="https://s2.ax1x.com/2020/02/23/3l2Kr8.png" alt="image-20190214161243306"></p>
<p><img src="https://s2.ax1x.com/2020/02/23/3l2Y2q.png" alt="image-20190214161305414"></p>
<h4 id="3-1-3-其他"><a href="#3-1-3-其他" class="headerlink" title="3.1.3 其他"></a>3.1.3 其他</h4><p><strong>AdaBoost 的构造过程</strong></p>
<p><img src="https://s2.ax1x.com/2020/02/23/3lWYuV.png" alt="image-20190214161432444"></p>
<p><strong>Boosting 和 AdaBoost</strong></p>
<p><code>boosting</code> 是一种集成技术，试图从多个弱分类器中创建强分类器。通过从训练数据构建一个模型，然后创建第二个模型试图纠正第一个模型中的错误。不断添加模型，直到训练集被完美地预测或者添加到最大数量。<br><code>AdaBoost</code> 是第一个为二分类开发的真正成功的提升算法。现代 <code>boosting</code> 方法建立在 <code>AdaBoost</code> 上，最著名的是随机梯度提升机（stochastic gradient boosting machines）。</p>
<blockquote>
<p>此描述转载自简书作者Bobby0322的「机器学习—提升和自适应增强（Boosting和AdaBoost）」一文。</p>
</blockquote>
<p><strong>bagging 集成与 boosting 集成的区别：</strong></p>
<p>区别一：数据方面</p>
<p>Bagging：对数据进行采样训练；</p>
<p>Boosting：根据前一轮学习结果调整数据的重要性。</p>
<p>区别二：投票方面</p>
<p>Bagging：所有学习器平权投票；</p>
<p>Boosting：对学习器进行加权投票。</p>
<p>区别三：学习顺序</p>
<p>Bagging 的学习是并行的，每个学习器没有依赖关系；</p>
<p>Boosting 学习是串行，学习有先后顺序。</p>
<p>区别四：主要作用</p>
<p>Bagging 主要用于提高泛化性能（解决过拟合，也可以说降低方差）</p>
<p>Boosting 主要用于提高训练精度 （解决欠拟合，也可以说降低偏差）</p>
<p><img src="https://s2.ax1x.com/2020/02/23/3lWgHO.png" alt="image-20190214161702237"></p>
<h3 id="3-2-GBDT-了解"><a href="#3-2-GBDT-了解" class="headerlink" title="3.2 GBDT(了解)"></a>3.2 GBDT(了解)</h3><p>梯度提升决策树(GBDT Gradient Boosting Decision Tree) <strong>是一种迭代的决策树算法</strong>，<strong>该算法由多棵决策树组成，所有树的结论累加起来做最终答案。</strong>它在被提出之初就被认为是泛化能力(<code>generalization</code>)较强的算法。近些年更因为被用于搜索排序的机器学习模型而引起大家关注。</p>
<p><strong>GBDT = 梯度下降 + Boosting + 决策树</strong></p>
<h4 id="3-2-1-梯度的概念-复习"><a href="#3-2-1-梯度的概念-复习" class="headerlink" title="3.2.1 梯度的概念(复习)"></a>3.2.1 梯度的概念(复习)</h4><p><img src="https://s2.ax1x.com/2020/02/23/3lfvdO.png" alt="image-20190307230334007"></p>
<p><img src="https://s2.ax1x.com/2020/02/23/3lh9Wd.png" alt="image-20190307230359850"></p>
<p><img src="https://s2.ax1x.com/2020/02/23/3lhMSs.png" alt="image-20190307230759175"></p>
<h4 id="3-2-2-GBDT-执行流程"><a href="#3-2-2-GBDT-执行流程" class="headerlink" title="3.2.2 GBDT 执行流程"></a>3.2.2 GBDT 执行流程</h4><p><img src="https://s2.ax1x.com/2020/02/23/3lh8mV.png" alt="image-20190307231055168"></p>
<p>如果上式中的 <code>hi(x)</code>=决策树模型，则上式就变为：</p>
<p><strong>GBDT = 梯度下降 + Boosting + 决策树</strong></p>
<h4 id="3-2-3-案例"><a href="#3-2-3-案例" class="headerlink" title="3.2.3 案例"></a>3.2.3 案例</h4><p>预测编号5的身高:</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>年龄(岁)</th>
<th>体重(KG)</th>
<th>身高(M)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>5</td>
<td>20</td>
<td>1.1</td>
</tr>
<tr>
<td>2</td>
<td>7</td>
<td>30</td>
<td>1.3</td>
</tr>
<tr>
<td>3</td>
<td>21</td>
<td>70</td>
<td>1.7</td>
</tr>
<tr>
<td>4</td>
<td>30</td>
<td>60</td>
<td>1.8</td>
</tr>
<tr>
<td>5</td>
<td>25</td>
<td>65</td>
<td>?</td>
</tr>
</tbody></table>
<p>第一步：计算损失函数，并求出第一个预测值。</p>
<p><img src="https://s2.ax1x.com/2020/02/23/3lhs0K.png" alt="image-20190307231938147"></p>
<p>第二步：求解划分点。</p>
<p><img src="https://s2.ax1x.com/2020/02/23/3lhf1A.png" alt="image-20190307232225237"></p>
<p>得出：年龄21为划分点的 方差=0.01+0.0025=0.0125</p>
<p>第三步：通过调整后目标值，求解得出<code>h1(x)</code></p>
<p><img src="https://s2.ax1x.com/2020/02/23/3lhT78.png" alt="image-20190307232510232"></p>
<p>第四步：求解 <code>h2(x)</code></p>
<p><img src="https://s2.ax1x.com/2020/02/23/3lhqhQ.png" alt="image-20190307232816506"></p>
<p>… …</p>
<p>得出结果：</p>
<p><img src="https://s2.ax1x.com/2020/02/23/3l4p7T.png" alt="image-20190307232909127"></p>
<p>编号5身高 = 1.475 + 0.03 + 0.275 = 1.78</p>
<h4 id="3-2-4-GBDT-主要执行思想"><a href="#3-2-4-GBDT-主要执行思想" class="headerlink" title="3.2.4 GBDT 主要执行思想"></a>3.2.4 GBDT 主要执行思想</h4><p>1) 使用梯度下降法优化代价函数；</p>
<p>2) 使用一层决策树作为弱学习器，负梯度作为目标值；</p>
<p>3) 利用 <code>boosting</code> 思想进行集成。</p>
<h3 id="3-3-XGBoost-了解"><a href="#3-3-XGBoost-了解" class="headerlink" title="3.3 XGBoost(了解)"></a>3.3 XGBoost(了解)</h3><p><strong>XGBoost= 二阶泰勒展开+boosting+决策树+正则化</strong></p>
<p><strong>面试题：了解 XGBoost 么，请详细说说它的原理</strong></p>
<p>回答要点：二阶泰勒展开，<code>boosting</code>，决策树，正则化</p>
<p><strong>Boosting</strong>：<code>XGBoost</code> 使用 <code>Boosting</code> 提升思想对多个弱学习器进行迭代式学习</p>
<p><strong>二阶泰勒展开</strong>：每一轮学习中，<code>XGBoost</code>对损失函数进行二阶泰勒展开，使用一阶和二阶梯度进行优化。</p>
<p><strong>决策树</strong>：在每一轮学习中，<code>XGBoost</code> 使用决策树算法作为弱学习进行优化。</p>
<p><strong>正则化</strong>：在优化过程中 <code>XGBoost</code> 为防止过拟合，在损失函数中加入惩罚项，限制决策树的叶子节点个数以及决策树叶子节点的值。</p>
<h3 id="拓展-什么是泰勒展开式"><a href="#拓展-什么是泰勒展开式" class="headerlink" title="[拓展]什么是泰勒展开式"></a>[拓展]什么是泰勒展开式</h3><p><img src="https://s2.ax1x.com/2020/02/23/3l4w4g.png" alt="image-20190307234553645"></p>
<p>泰勒展开越多，计算结果越精确。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕前端ing～</title>
    <url>/%E6%AD%BB%E7%A3%95%E5%89%8D%E7%AB%AFing%EF%BD%9E/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
这么久没有发文，很多人关心我是否离开了这个美丽的世界 ... 这些同学，是如何居心？出来，我保证不打死你们。不过很久没有更新文章，确实抱歉，我的错，我有罪 ～（小声逼逼：我又不是签约作家，还被逼出了连载的味道，也是没谁了。）

<p>今天咱们唠唠前端那点事儿，和前端死磕到底。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<blockquote>
<p>当然并不是和可爱的前端们发生争执，而是和那些标签、js、框架死磕到底。</p>
</blockquote>
<p>说起来惭愧，许久没有碰过代码（除了偶尔的脚本），<code>python</code> 生疏已久，前端的 <code>html</code> 、<code>css</code> 和 <code>javascript</code> 更是遗忘在了奈何桥的另一头。作为一个热爱学习的三好青年，怎会允许此事发生？今天咱们就先来回顾一下这些基础知识。以下内容根据 HTML 、CSS 、JS 的顺序进行回顾，文章篇幅较长，可以跳读。</p>
<h2 id="1-HTML"><a href="#1-HTML" class="headerlink" title="1.HTML"></a>1.HTML</h2><p>大家好，我是 html ，学名为超文本标记语言。在浏览器上处处可以看到我的身影。当然，我自己不会如此伟大，身后支撑有一个团队，他们是<strong>化妆师</strong> CSS 和<strong>动作指导</strong> Javascript。</p>
<p>我身上有很多的标签，经过化妆师 CSS 的修饰，才得以展现如此靓丽的一面（让一些开了美颜、瘦脸、拉长身高的小姐姐自愧不如）。那么，简单的数数我身上有哪些标签。</p>
<h3 id="1-1-标签"><a href="#1-1-标签" class="headerlink" title="1.1 标签"></a>1.1 标签</h3><p>1.<code>head</code> 标签，里面会包含一些个 <code>meta</code> 标签、<code>title</code> 标签（网页的标题就是这个小东东）。你以为这些就够了？它里面能嵌入 <code>style</code> （样式标签，内容为 CSS 代码），还可以嵌入 <code>script</code> （内容为 JavaScript 代码），内容极为丰富。</p>
<p>2.<code>body</code> 标签作为身体，大部分的页面内容就自此处啦。</p>
<p>3.<code>h</code> 是标题标签</p>
<p>4.<code>div</code> 是块状标签</p>
<p>5.<code>p</code> 是段落标签</p>
<p>6.<code>br</code> 是换行标签，它是单个出现的标签</p>
<p>7.<code>img</code> 是图片标签，他也是单个出现的标签</p>
<p>8.<code>a</code> 是超链接标签，点击可跳转其他链接</p>
<p>9.<code>ul</code> 和 <code>li</code> 组成了无序标签；而 <code>ol</code> 则是有序标签</p>
<p>10.<code>form</code> 是表单（其中 action 属性定义提交地址；method 属性则是确定表单提交的方式）</p>
<p>11.<code>label</code> 是标注标签。比如一个输入框前面标注为姓名，意思就是让用户输入姓名。</p>
<p>12.<code>input</code> 是输入框。type 属性确定其内容：text 是单行文本，password 是密码框，radio 是单选框，checkbox 是复选框，file 是上传文件，submit 是提交按钮，reset 是重置按钮，button 是普通按钮。</p>
<p>13.<code>textarea</code> 则是多行文本输入框</p>
<p>14.<code>select</code> 是下拉表单</p>
<p>15.<code>option</code> 与 <code>select</code> 配合使用，意思即下拉表单中的选项</p>
<p>16.<code>span</code> 标签则是一些特殊格式文本的标签</p>
<p>17.<code>table</code> 是表格标签，与其配合的有 <code>tr</code> 行标签， <code>th</code> 表头单元格， <code>td</code> 普通单元格</p>
<h3 id="1-2-实体符号以及注释"><a href="#1-2-实体符号以及注释" class="headerlink" title="1.2 实体符号以及注释"></a>1.2 实体符号以及注释</h3><p>大家都知道国人写文章的习惯为段首缩进两字符，如果在 <code>p</code> 标签起始位置手敲俩空格后，页面展示会发现怎么只有一个空格？？？那是因为被浏览器吃了，想要显示多个空格，就需要空格的实体符号了。那便是 <code>&amp;nbsp;</code>。</p>
<p>另外，为了防止歧义的产生，还有俩实体符合值得一提，那便是大于号和小于号。毕竟它们长得太像标签的尖括号了。小于号表示为<code>&amp;lt;</code>；大于号表示为 <code>&amp;gt;</code></p>
<p>注释为 <code>&lt;!-- xxx --&gt;</code></p>
<h3 id="1-3-行元素与行内元素"><a href="#1-3-行元素与行内元素" class="headerlink" title="1.3 行元素与行内元素"></a>1.3 行元素与行内元素</h3><p><strong>行元素</strong>就是单独占一行的标签，也就是后面再有标签去要到下一行去！咱们看看都有谁这么霸道，不要脸：标题标签 <code>h</code>（标题嘛，情有可原）；段落标签 <code>p</code> （凑合着也说的过去）；<code>div</code> 标签（这个东西就把它理解成容器吧，毕竟它没有语义，中性的很～）</p>
<p><strong>行内元素</strong>就是老实人，只占自己的位置。元素之间可以排开（设置宽高是无效的，它的宽和高是由内容撑开的）。这些老实人都有谁呢？图片标签 <code>img</code>  和通用内联容器标签 <code>span</code> 以及超链接标签  <code>a</code></p>
<h3 id="1-4-布局"><a href="#1-4-布局" class="headerlink" title="1.4 布局"></a>1.4 布局</h3><p>不想做将军的士兵，不是好士兵。论谋略、论布局，咱也有一手。</p>
<p><strong>口诀</strong>是：先行后列、先整体再局部、先大后小</p>
<p>即先按照行的方式，将页面整体分开，再给每一行进行内容填充。</p>
<h2 id="2-CSS"><a href="#2-CSS" class="headerlink" title="2.CSS"></a>2.CSS</h2><p>化妆师 CSS 就是美容整形专家了，它控制着 html 的美与丑。</p>
<blockquote>
<p>它有个名字叫做 层叠样式表</p>
</blockquote>
<h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">  属性: 值;</span><br><span class="line">  ...</span><br><span class="line">  属性: 值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择器下面会大幅介绍，所以不要担心。属性和值嘛就很简单，比如字体颜色是红色，字体是仿宋，想起了被论文支配的恐惧 …</p>
<h3 id="2-2-选择器"><a href="#2-2-选择器" class="headerlink" title="2.2 选择器"></a>2.2 选择器</h3><p>选择器其实并不复杂，它就是选择内容，然后为其添加样式，如何准确的选择要加样式的内容呢？就依靠下列选择器啦。</p>
<h4 id="2-2-1-标签选择器"><a href="#2-2-1-标签选择器" class="headerlink" title="2.2.1 标签选择器"></a>2.2.1 标签选择器</h4><p>这是最简单的选择器，直接选择标签，其影响范围之广可想而之，所以大型项目里面可是很少使用的，慎用！</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">color</span>: red&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-类选择器"><a href="#2-2-2-类选择器" class="headerlink" title="2.2.2 类选择器"></a>2.2.2 类选择器</h4><p>类这个字从何而来呢？它其实是根据标签的一个 <code>class</code> 属性命名的。多个标签想要渲染同样的效果，可设置相同的类。然后根据类名来选择元素即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.newbox</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-层级选择器"><a href="#2-2-3-层级选择器" class="headerlink" title="2.2.3 层级选择器"></a>2.2.3 层级选择器</h4><p>层级选择器则是依据标签的层级结果，即嵌套格式进行选择。它可以结合标签选择器与类选择器来一同使用。</p>
<p>比如有个 html 结构如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"new"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为 <code>span</code> 标签加个颜色：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.con</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-id-选择器"><a href="#2-2-4-id-选择器" class="headerlink" title="2.2.4 id 选择器"></a>2.2.4 id 选择器</h4><p>id 为标签的名字。在数据库中 id 一般为唯一键，此处同理。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#box</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5-组选择器"><a href="#2-2-5-组选择器" class="headerlink" title="2.2.5 组选择器"></a>2.2.5 组选择器</h4><p>组选择器便是选择一组内容，为其统一添加样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>,<span class="selector-class">.box8</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-6-伪类选择器"><a href="#2-2-6-伪类选择器" class="headerlink" title="2.2.6 伪类选择器"></a>2.2.6 伪类选择器</h4><p>有一个常用的伪类选择器，它就是 hover ，表示鼠标悬浮于元素上时的状态。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-盒子模型"><a href="#2-3-盒子模型" class="headerlink" title="2.3 盒子模型"></a>2.3 盒子模型</h3><p>提到前端，不得不提到一个东西，那便是盒子模型。也就是浏览器中常看到的下列图片：</p>
<img src="https://github.com/EthanYan6/pic/raw/master/%E6%AD%BB%E7%A3%95%E5%89%8D%E7%AB%AFing%EF%BD%9E/Snipaste_2019-12-07_15-33-11.png" alt="哟，老弟？什么年代了，网速还加载不出我的图片啊？换光纤吧！此处为盒子模型图片" style="zoom:50%;">

<p>盒子模型主要还是为了理解如下几个概念而形象化的东西。</p>
<p>前一段时间在淘宝买了个毛绒玩具（蓝胖子），收到快递，在拆解过程中：</p>
<p>1.width 装玩具的盒子的宽度</p>
<p>2.height 装玩具的盒子的宽度</p>
<p>3.border 装玩具的盒子的厚度</p>
<p>4.padding 玩具和盒子之间的距离（蓝胖子不能压瘪，要不然差评，所以它被保护的很好）</p>
<p>5.margin 我快递盒子和放快递的大盒子之间的距离</p>
<p>有个现象是，当盒子的长和宽固定后， border 和 padding 增加，都会改变整体的尺寸，为什么呢？</p>
<p>因为 padding 增加后（即玩具和盒子之间的填充泡沫太多了）盒子被撑大了；border 增加后（商家比较有良心，换了个特厚实的盒子），所以快递变大了。</p>
<h3 id="2-4-常用属性"><a href="#2-4-常用属性" class="headerlink" title="2.4 常用属性"></a>2.4 常用属性</h3><p>1.width 设置标签的宽</p>
<p>2.height 设置标签的高</p>
<p>3.background 设置标签的背景色</p>
<p>4.border 设置边框线：border-top 即上边框；同理其他为 border-left、border-right 和 border-bottom</p>
<p>5.padding 设置元素内容与边框间的距离（即蓝胖子和快递盒之间的距离）</p>
<p>6.margin 设置元素和外界的距离</p>
<p>7.float 设置元素浮动</p>
<p>8.color 设置文字颜色</p>
<p>9.font-size 设置文字大小</p>
<p>10.font-family 设置文字字体</p>
<p>11.font-weight 设置是否加粗</p>
<p>12.line-height 设置行高</p>
<p>13.text-decoration 设置文字下划线</p>
<p>14.text-align 设置文字水平对齐方式</p>
<p>15.text-indent 设置文字首行缩进</p>
<blockquote>
<p>css 中的注释为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* xxx */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>16.display 设置元素的类型与隐藏。（none 为隐藏；inline 为行内元素；block 为块元素）</p>
<p>17.overflow 设置元素溢出时的动作。（visible 为内容会难看的被显示在元素框外，溢出；hidden 去掉超出的内容，只显示元素框内内容；scroll 则是现实滚动条，可以上下滚动显示全部内容；auto 则是如果内容超出去才会显示滚动条）</p>
<h3 id="2-5-定位"><a href="#2-5-定位" class="headerlink" title="2.5 定位"></a>2.5 定位</h3><h4 id="2-5-1-绝对定位"><a href="#2-5-1-绝对定位" class="headerlink" title="2.5.1 绝对定位"></a>2.5.1 绝对定位</h4><p>找一个参照物来固定元素本身，优先去查找上一个设置了定位的元素，没有的话就是 body 了。然后根据它固定位置，脱离文档流</p>
<h4 id="2-5-2-相对定位"><a href="#2-5-2-相对定位" class="headerlink" title="2.5.2 相对定位"></a>2.5.2 相对定位</h4><p>设置相对定位的元素，一般设置父级相对定位，而子集绝对定位。</p>
<h4 id="2-5-3-固定定位"><a href="#2-5-3-固定定位" class="headerlink" title="2.5.3 固定定位"></a>2.5.3 固定定位</h4><p>以浏览器窗口为参照物，脱离文档流，以不变应万变。</p>
<blockquote>
<p>文档流就是那些标签，它们按照顺序从上往下，从左到右的排列着，当然符合块元素与行内元素的特性。脱离文档流就是飘起来了，它们怎么排列，不受文档流的影响。</p>
</blockquote>
<h3 id="2-6-权重"><a href="#2-6-权重" class="headerlink" title="2.6 权重"></a>2.6 权重</h3><p>CSS 的权重是衡量显示样式的优先级。权重值大的优先显示，如果权重值相同，后写的样式会覆盖掉前面的样式。</p>
<p>1.内联样式权重值最高，毕竟是标签的一部分，亲人嘛。权重值为 1000</p>
<p>2.ID 选择器仅次于内联样式，权重值为 100</p>
<p>3.类和伪类选择器权重值为 10</p>
<p>4.标签选择器权重值为 1</p>
<h2 id="3-Javascript"><a href="#3-Javascript" class="headerlink" title="3.Javascript"></a>3.Javascript</h2><p>希望看到这里，你还有耐心读下去。如果看不下去了，就先收藏一下，去喝杯水，休息一会。</p>
<p>Javascript 也是一种弱类型的语言，它的变量类型不像 Java、C 等需要提前声明，而是由赋的值类型决定，你给我个整数，我就是数字类型。</p>
<p>它定义变量的<strong>语法</strong>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">666</span></span><br><span class="line"><span class="keyword">var</span> sTr = <span class="string">'Ethan Yan'</span></span><br></pre></td></tr></table></figure>

<p>当然你也可以偷懒，多个变量定义，只用一个 <code>var</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">666</span>,sTr=<span class="string">'Ethan Yan'</span></span><br></pre></td></tr></table></figure>

<p>同时它有 <strong>5 种基本数据类型</strong>：</p>
<p>1.number</p>
<p>2.string</p>
<p>3.boolean</p>
<p>4.undefined</p>
<p>5.null</p>
<p>还有一种<strong>复合类型</strong>：object</p>
<p>它不严格缩进，全凭自己喜好，因为它的<strong>语句都以封号结尾</strong>，不像 python 一样，缩进错误疯狂报错。</p>
<p>它的注释如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	xxx</span></span><br><span class="line"><span class="comment">	多行注释</span></span><br><span class="line"><span class="comment">	xxx</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>然后就是<strong>命名规范</strong>，毕竟你定义 xxx 没人能够理解。</p>
<p><strong>变量、函数、属性、函数参数命名规范</strong>：</p>
<p>1.区分大小写</p>
<p>2.第一个字符必须是字母，下划线或者美元符号。（千万别以数字开头命名了，我真的很奇怪，总是有人以数字开头命名）</p>
<p>3.其他字符可以是字母、下划线、美元符号和数字</p>
<p>还有一种比较美观的命名方式，大家可以借鉴一下，那就是<strong>匈牙利命名风格</strong>：</p>
<p>1.如果是对象（Object）就写为：oDiv</p>
<p>2.如果是数组（Array）就写为：aItems</p>
<p>3.如果是浮点数（Float）就写为：fPrice</p>
<p>规律即：变量类型小写首字母加上变量名</p>
<h3 id="3-1-函数"><a href="#3-1-函数" class="headerlink" title="3.1 函数"></a>3.1 函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnAlert</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数执行</span></span><br><span class="line">fnAlert()</span><br></pre></td></tr></table></figure>

<p>上面的函数就是弹出一句话 <code>hello!</code></p>
<p>如果想给函数传参数，则可以使用如下方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnAlert</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  alert(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">alert(<span class="number">222222</span>)</span><br></pre></td></tr></table></figure>

<p>具有返回值的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnAdd</span>(<span class="params">iNum01,iNum02</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> iRs = iNum01 + iNum02;</span><br><span class="line">  <span class="keyword">return</span> iRs;</span><br><span class="line">  alert(<span class="string">'complete!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iCount = fnAdd(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">alert(iCount); <span class="comment">// 弹出7</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-1-变量和函数的预解析"><a href="#3-1-1-变量和函数的预解析" class="headerlink" title="3.1.1 变量和函数的预解析"></a>3.1.1 变量和函数的预解析</h4><p>1.js <strong>底层解析过程</strong>分为两个阶段，那就是编译阶段和执行阶段。所以会发生一件有意思的事情，那就是你在定义一个函数之前，调用这个函数，同样执行正确。为什么？因为编译阶段已经将函数定义过了。（是不是很不可思议）</p>
<p>2.变量如果先调用再定义，为什么不回出现相同的现象？因为变量在编译阶段，会先将其赋值为 undefined 类型，所以先使用变量，再声明变量也不会报错，但是会得到一个 undefined 类型的变量。</p>
<h3 id="3-2-条件语句"><a href="#3-2-条件语句" class="headerlink" title="3.2 条件语句"></a>3.2 条件语句</h3><h4 id="3-2-1-if-else"><a href="#3-2-1-if-else" class="headerlink" title="3.2.1 if-else"></a>3.2.1 if-else</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> iNum2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> sTr;</span><br><span class="line"><span class="keyword">if</span>(iNum1&gt;iNum2)&#123;</span><br><span class="line">  sTr = <span class="string">'大于'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  sTr = <span class="string">'小于'</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(sTr);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-if-elseif-else"><a href="#3-2-2-if-elseif-else" class="headerlink" title="3.2.2 if-elseif-else"></a>3.2.2 if-elseif-else</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">  xxx;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">  xxx;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-获取元素方式"><a href="#3-3-获取元素方式" class="headerlink" title="3.3 获取元素方式"></a>3.3 获取元素方式</h3><p>如果一个元素定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"div1"</span>&gt;这是一个div元素&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>想要获取该元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意获取到的变量是一个对象，并不是值。想要取值，使用<code>oDiv.innerHTML</code> 即可做到</p>
</blockquote>
<p>对了，写 js 时，有一个问题需要注意：</p>
<p>如果 script 标签内容（要获取某一个元素的值）在元素之前，那么获取不到，因为未被声明（代码从上往下执行，而且得到的结果不是 undefined 而是 null）。如果你非要这么变态的写，当然也有办法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">'div2'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>window.onload</code> 函数会在页面加载完之后执行，所以你将你的变态代码扔进去，js 写在哪里都正确。</p>
<h3 id="3-4-操作元素的属性"><a href="#3-4-操作元素的属性" class="headerlink" title="3.4 操作元素的属性"></a>3.4 操作元素的属性</h3><p>语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 = 元素.属性名  <span class="comment">// 读取属性</span></span><br><span class="line">元素.属性名 = 新属性值   <span class="comment">// 改写属性</span></span><br></pre></td></tr></table></figure>

<p>读取属性名时的属性名写法可有些讲究了：</p>
<p>1.普通属性，即 html 中的属性，直接写就完事了</p>
<p>2.class 类属性需要改写。如：className</p>
<p>3.style 属性有横杠的也需要改写。如 font-size 改写为 .fontSize</p>
<h3 id="3-5-事件属性以及匿名函数"><a href="#3-5-事件属性以及匿名函数" class="headerlink" title="3.5 事件属性以及匿名函数"></a>3.5 事件属性以及匿名函数</h3><h4 id="3-5-1-事件属性"><a href="#3-5-1-事件属性" class="headerlink" title="3.5.1 事件属性"></a>3.5.1 事件属性</h4><p>大家经常进行的鼠标点击、鼠标移入、鼠标移出都就是事件属性。我们可以通过将函数名赋值给元素事件属性的方式将事件和函数关联起来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oBtn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"></span><br><span class="line">oBtn.onclick = myalert;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myalert</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'ok!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-2-匿名函数"><a href="#3-5-2-匿名函数" class="headerlink" title="3.5.2 匿名函数"></a>3.5.2 匿名函数</h4><p>js 中匿名函数很好写，我们改写上一段代码为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oBtn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意下面写法</span></span><br><span class="line">oBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'ok!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-数组及操作方法"><a href="#3-6-数组及操作方法" class="headerlink" title="3.6 数组及操作方法"></a>3.6 数组及操作方法</h3><p>如同 python 中的列表，定义数组可以有下面两种方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aList = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> aList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组的长度</span></span><br><span class="line">alert(aList.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用下标取出数组的0号数据</span></span><br><span class="line">alert(aList[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组成员通过一个分隔符合并成字符串</span></span><br><span class="line"><span class="comment">// 弹出 1-2-3</span></span><br><span class="line">alert(aList.join(<span class="string">'-'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组最后增加成员3</span></span><br><span class="line">aList.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组最后删除成员</span></span><br><span class="line">aList.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组反转</span></span><br><span class="line">aList.reverse();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组中元素第一次出现的1的索引值</span></span><br><span class="line">aList.indexOf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第2个元素开始，删除1个元素，然后在此位置增加'7,8,9'三个元素</span></span><br><span class="line">aList.aplice(<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-7-循环语句"><a href="#3-7-循环语句" class="headerlink" title="3.7 循环语句"></a>3.7 循环语句</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 0 开始，只要 i 小于 len 就会一直执行，没执行一次代码，i 进行加 1 操作。</p>
<h3 id="3-8-字符串相关方法"><a href="#3-8-字符串相关方法" class="headerlink" title="3.8 字符串相关方法"></a>3.8 字符串相关方法</h3><p>1.直接用 <code>+</code> 进行拼接操作</p>
<p>2.parseInt() 将数字字符串转化为整数</p>
<p>3.parseFloat() 将数字字符串转化为小数</p>
<p>4.split() 把一个字符串分隔成字符串组成的数组</p>
<p>5.indexOf() 查找字符串是否含有某字符</p>
<p>6.substring() 截取字符串 </p>
<blockquote>
<p>用法： substring(start,end)（不包括end）</p>
</blockquote>
<p><strong>字符串反转</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &#39;asdfj12jlsdkf098&#39;;</span><br><span class="line">var str2 &#x3D; str.split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line"></span><br><span class="line">alert(str2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先转化成数组，再利用数组的反转方法即可实现</p>
</blockquote>
<h3 id="3-9-定时器"><a href="#3-9-定时器" class="headerlink" title="3.9 定时器"></a>3.9 定时器</h3><p>setTimeout  只执行一次的定时器 </p>
<p>clearTimeout 关闭只执行一次的定时器</p>
<p>setInterval  反复执行的定时器</p>
<p>clearInterval 关闭反复执行的定时器</p>
<h3 id="3-10-封闭函数"><a href="#3-10-封闭函数" class="headerlink" title="3.10 封闭函数"></a>3.10 封闭函数</h3><p>封闭函数的三种写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>其实也属于匿名函数，即创建完函数立即调用，省略了函数名。</p>
<p>当然它并不是没事干，定义这么个东西好玩儿，它是为了防止命名冲突。</p>
<blockquote>
<p>封闭函数可以创造一个独立的空间，在封闭函数内定义的变量和函数不会影响外部同名的函数和变量，可以避免命名冲突，在页面上引入多个js文件时，用这种方式添加js文件比较安全.</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>菜鸟去面试之一</title>
    <url>/%E8%8F%9C%E9%B8%9F%E5%8E%BB%E9%9D%A2%E8%AF%95%E4%B9%8B%E4%B8%80/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>春天到了，那颗躁动不安的心又踏上了面试之旅，菜鸟在前方探路，返回一手资料供你参考。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-python基础"><a href="#1-python基础" class="headerlink" title="1.python基础"></a>1.python基础</h2><h3 id="1-1-dict"><a href="#1-1-dict" class="headerlink" title="1.1 dict"></a>1.1 dict</h3><p>问：有这样一个需求，为字典添加一个键，如果已存在则不做任何操作；如果不存在，添加后需要设置默认值。请使用字典自带的一个方法完成此操作。</p>
<p>答：<code>setdefault</code> 方法可完成此操作。示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mydict = &#123;<span class="string">"1"</span>:<span class="string">"小闫"</span>, <span class="string">"2"</span>:<span class="string">"小良"</span>&#125;</span><br><span class="line">mydict.setdefault(<span class="string">'1'</span>, <span class="string">'xx'</span>)</span><br><span class="line">print(mydict)</span><br><span class="line"><span class="comment"># 结果为 &#123;'1': '小闫', '2': '小良'&#125;</span></span><br><span class="line">mydict.setdefault(<span class="string">'3'</span>, <span class="string">'xx'</span>)</span><br><span class="line">print(mydict)</span><br><span class="line"><span class="comment"># 结果为 &#123;'1': '小闫', '2': '小良', '3': 'xx'&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-str"><a href="#1-2-str" class="headerlink" title="1.2 str"></a>1.2 str</h3><p>问：请问字符串的方法 <code>join</code> 与操作符 <code>+</code> ，哪一个效率高？</p>
<p>答：如果需要拼接大量的字符串，如几万个 ，那么 <code>join</code> 类型的效率要远高于操作符 <code>+</code>；如果仅仅是一两个字符串拼接的话，操作符会更加实用。下面从源码的角度去解析一下原因：</p>
<p>字符串底层是由 <code>C</code> 语言中 <code>PyStringObject</code> 对象所实现，此对象不可变，这就导致了如果要使用操作符 <code>+</code> ，就需要不断的重新申请地址空间去存放拼接后的字符串，在数量庞大的基础上，效率可想而知多么低。<code>join</code> 就不一样了，它是对列表等可迭代对象进行操作，因为操作对象是可变的，因此只需申请一次内存即可。所以结论就是 <code>join</code> 类型效率要高的多。</p>
<h2 id="2-Git"><a href="#2-Git" class="headerlink" title="2.Git"></a>2.Git</h2><h3 id="1-1-分支"><a href="#1-1-分支" class="headerlink" title="1.1 分支"></a>1.1 分支</h3><p>1.查看当前所属分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>2.删除分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除本地分支</span><br><span class="line">git branch -d [分支名称]</span><br><span class="line"># 删除远程分支</span><br><span class="line">git push origin --delete [分支名称]</span><br></pre></td></tr></table></figure>

<h2 id="3-MVT"><a href="#3-MVT" class="headerlink" title="3.MVT"></a>3.MVT</h2><p>问：谈一谈你对 <code>MVT</code> 模式的了解？</p>
<p>答：首先介绍一下这三个字母所代表的的内容，<code>M</code> 是 <code>Model</code> 代表模型类，与数据库进行交互；<code>V</code> 是 <code>View</code> 代表视图，是对请求进行处理并与数据库模板等进行交互；<code>T</code> 是 <code>Template</code> 代表模板，是负责填充数据产生前端页面。其大体<strong>流程</strong>为：客户端发起一个请求，视图接收后，根据内容进行处理，过程中如果涉及到数据库，会进行查询保存等操作并将结果返回给视图，然后模板进行填充并返回给视图一个 <code>html</code> 页面，最后视图将页面返回给客户端进行渲染展示。 </p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>生产环境隐藏敏感配置信息方案</title>
    <url>/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%9A%90%E8%97%8F%E6%95%8F%E6%84%9F%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>项目上线时需要切换生产环境配置信息，这些信息可以直接被保存在项目中吗？如果保存下来，不小心提交到仓库或被破解查看，生产环境岂不是裸奔？那么该如何解决？</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-演示环境"><a href="#1-演示环境" class="headerlink" title="1.演示环境"></a>1.演示环境</h2><p>本文以 <code>Flask</code> 项目为例说明，简单环境信息：</p>
<p>1) <code>Flask</code> + <code>Flask-RESTful</code></p>
<p>2) <code>CentOS</code></p>
<h2 id="2-方案"><a href="#2-方案" class="headerlink" title="2.方案"></a>2.方案</h2><p>一般配置信息都保存在指定目录下，分为测试、开发以及生产。其中测试与开发配置文件的保留，问题不大，关键就是生产环境配置信息如何处理。</p>
<p>1) 可以在 <code>.gitignore</code> 文件中添加忽略文件，使其不被提交到仓库。</p>
<blockquote>
<p>虽然不在仓库内，但是配置文件仍然在项目中</p>
</blockquote>
<p>2) 可以通过添加环境变量的方式解决。推荐指数5颗星 ~ </p>
<h2 id="3-方案实施"><a href="#3-方案实施" class="headerlink" title="3.方案实施"></a>3.方案实施</h2><p>可以保留项目中开发（测试）环境配置文件，将需要修改的数据库配置项等单独在生产环境配置文件中重写，并配置环境变量（生产配置文件路径）。然后在项目加载默认配置信息后，通过环境变量引入生产配置信息，从而覆盖掉无用配置，隐藏敏感信息。这样我们的生产信息既不在仓库内，也不在项目中，而是在服务器某个角落。项目中的配置信息都是本地配置项，被人知道也无妨，保留后还能造成迷惑。</p>
<h3 id="3-1-在服务器任意目录下存放生产环境配置信息"><a href="#3-1-在服务器任意目录下存放生产环境配置信息" class="headerlink" title="3.1 在服务器任意目录下存放生产环境配置信息"></a>3.1 在服务器任意目录下存放生产环境配置信息</h3><p>生产配置文件 <code>app_deploy.py</code> 中既可以保存 <code>MySQL</code> 、<code>Redis</code> 和 <code>Elasticsearch</code> 数据库集群信息，还可以保存私钥等敏感信息。</p>
<p>比如我们将其存放在如下路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/root/config/app_deploy.py</span><br></pre></td></tr></table></figure>

<h3 id="3-2-配置环境变量"><a href="#3-2-配置环境变量" class="headerlink" title="3.2 配置环境变量"></a>3.2 配置环境变量</h3><p>在部署项目的 <code>shell</code> 脚本中添加如下信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export TOUTIAO_APP_SETTING=/root/config/app_deploy.py</span><br></pre></td></tr></table></figure>

<h3 id="3-3-设置常量保存环境变量名"><a href="#3-3-设置常量保存环境变量名" class="headerlink" title="3.3 设置常量保存环境变量名"></a>3.3 设置常量保存环境变量名</h3><p>在项目如下文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.../common/utils/constants.py</span><br></pre></td></tr></table></figure>

<p>添加常量信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GLOBAL_SETTING_ENV_NAME = 'TOUTIAO_APP_SETTING'</span><br></pre></td></tr></table></figure>

<h3 id="3-4-在项目初始化文件中加载环境变量"><a href="#3-4-在项目初始化文件中加载环境变量" class="headerlink" title="3.4 在项目初始化文件中加载环境变量"></a>3.4 在项目初始化文件中加载环境变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_flask_app</span><span class="params">(config, enable_config_file=False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    创建 Flask 应用</span></span><br><span class="line"><span class="string">    :param config: 配置信息对象</span></span><br><span class="line"><span class="string">    :param enable_config_file: 是否允许运行环境中的配置文件覆盖已加载的配置信息</span></span><br><span class="line"><span class="string">    :return: Flask 应用</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    app.config.from_object(config)</span><br><span class="line">    <span class="keyword">if</span> enable_config_file:</span><br><span class="line">        <span class="keyword">from</span> utils <span class="keyword">import</span> constants</span><br><span class="line">        app.config.from_envvar(constants.GLOBAL_SETTING_ENV_NAME, silent=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure>

<p>以上只是本人在实际项目中的一个小应用，可以类比去设置 <code>Django</code> 项目。当然，如果你有更好方法可以后台给小闫留言，不胜感激。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>还在拧螺丝？是时候学习造航母了！</title>
    <url>/%E8%BF%98%E5%9C%A8%E6%8B%A7%E8%9E%BA%E4%B8%9D%EF%BC%9F%E6%98%AF%E6%97%B6%E5%80%99%E5%AD%A6%E4%B9%A0%E9%80%A0%E8%88%AA%E6%AF%8D%E4%BA%86%EF%BC%81/</url>
    <content><![CDATA[<center>Author：闫玉良</center>
面试造航母，实际拧螺丝。这是大部分互联网人面对的实际情境，如何跳出舒适的圈子，撤离局部，俯览大局？

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>限制自己的不是外界，而是内心。你之所以没听过这句话，是因为它出自小闫同学（鹅鹅鹅～笑出了鹅叫声）为了避免三年螺丝工，还是提升一下自己，为造航母做准备吧。一些架构知识，既可以培养全局观，又可以助你深层次认识『螺丝』。</p>
<h2 id="一、架构演变"><a href="#一、架构演变" class="headerlink" title="一、架构演变"></a>一、架构演变</h2><p>一般来说，任何一个项目至少有三层内容来组成：<strong>web访问层、数据库层、存储层</strong></p>
<h3 id="1-1-初级阶段"><a href="#1-1-初级阶段" class="headerlink" title="1.1 初级阶段"></a>1.1 初级阶段</h3><p>在初级阶段又会人为细分为如下几个阶段：</p>
<h4 id="1-1-1-单体阶段"><a href="#1-1-1-单体阶段" class="headerlink" title="1.1.1 单体阶段"></a>1.1.1 单体阶段</h4><p><strong>常见场景：</strong>项目初期 </p>
<p><strong>部署特点：</strong>所有应用服务都在一台主机 </p>
<p><strong>应用特点：</strong>开发简单</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%841.png" alt="单体阶段"></p>
<h4 id="1-1-2-应用-数据分离阶段"><a href="#1-1-2-应用-数据分离阶段" class="headerlink" title="1.1.2 应用/数据分离阶段"></a>1.1.2 应用/数据分离阶段</h4><p><strong>常见场景：</strong>项目初期，用户访问数据库有压力 </p>
<p><strong>部署特点：</strong>应用和数据库单独部署 </p>
<p><strong>应用特点：</strong>开发简单</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%842.png" alt="应用/数据分离阶段"></p>
<h4 id="1-1-3-页面动静分离阶段"><a href="#1-1-3-页面动静分离阶段" class="headerlink" title="1.1.3 页面动静分离阶段"></a>1.1.3 页面动静分离阶段</h4><p><strong>常见场景：</strong>项目初期，用户访问页面有压力</p>
<p><strong>部署特点：</strong>剥离用户读请求和写请求操作</p>
<p><strong>应用特点：</strong>开发简单</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%843.png" alt="页面动静分离阶段"></p>
<h4 id="1-1-4-页面-数据缓存阶段"><a href="#1-1-4-页面-数据缓存阶段" class="headerlink" title="1.1.4 页面/数据缓存阶段"></a>1.1.4 页面/数据缓存阶段</h4><p><strong>常见场景：</strong>项目初期，用户访问有压力 </p>
<p><strong>部署特点：</strong>代理和数据库前面增加缓存组件 </p>
<p><strong>应用特点：</strong>开发简单</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%844.png" alt="页面/数据缓存阶段"></p>
<h3 id="1-2-中期阶段"><a href="#1-2-中期阶段" class="headerlink" title="1.2 中期阶段"></a>1.2 中期阶段</h3><h4 id="1-2-1-应用服务集群阶段"><a href="#1-2-1-应用服务集群阶段" class="headerlink" title="1.2.1 应用服务集群阶段"></a>1.2.1 应用服务集群阶段</h4><p><strong>常见场景：</strong>项目初期，用户访问有压力</p>
<p><strong>部署特点：</strong>应用服务所在主机做集群负载均衡 </p>
<p><strong>应用特点：</strong>业务中等</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%845.png" alt="应用服务集群阶段"></p>
<h4 id="1-2-2-数据库读写分离化"><a href="#1-2-2-数据库读写分离化" class="headerlink" title="1.2.2 数据库读写分离化"></a>1.2.2 数据库读写分离化</h4><p><strong>常见场景：</strong>项目初期，用户访问数据有压力</p>
<p><strong>部署特点：</strong>对数据库集群做读写分离，静态文件做共享存储</p>
<p><strong>应用特点：</strong>业务中等</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%846.png" alt="数据库读写分离化"></p>
<h4 id="1-2-3-存储分布式"><a href="#1-2-3-存储分布式" class="headerlink" title="1.2.3 存储分布式"></a>1.2.3 存储分布式</h4><p><strong>常见场景：</strong>项目中期，数据存储有压力</p>
<p><strong>部署特点：</strong>对数据库分库/分表扩展，数据文件使用分布式存储</p>
<p><strong>应用特点：</strong>业务中等</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%847.png" alt="存储分布式"></p>
<h4 id="1-2-4-业务应用拆分"><a href="#1-2-4-业务应用拆分" class="headerlink" title="1.2.4 业务应用拆分"></a>1.2.4 业务应用拆分</h4><p><strong>常见场景：</strong>项目中期，业务访问/团队管理有压力</p>
<p><strong>部署特点：</strong>项目应用进行拆分</p>
<p><strong>应用特点：</strong>业务复杂</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%848.png" alt="业务应用拆分"></p>
<h3 id="1-3-中后期阶段"><a href="#1-3-中后期阶段" class="headerlink" title="1.3 中后期阶段"></a>1.3 中后期阶段</h3><h4 id="1-3-1-业务拆分"><a href="#1-3-1-业务拆分" class="headerlink" title="1.3.1 业务拆分"></a>1.3.1 业务拆分</h4><p><strong>常见场景：</strong>项目中后期，业务处理有压力</p>
<p><strong>部署特点：</strong>所有功能以服务形式单独部署，引入配置管理管理中心、消息中间件，搜索引擎等功能</p>
<p><strong>应用特点：</strong>业务复杂</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%849.png" alt="业务拆分"></p>
<h3 id="1-4-后期阶段"><a href="#1-4-后期阶段" class="headerlink" title="1.4 后期阶段"></a>1.4 后期阶段</h3><h4 id="1-4-1-微服务阶段"><a href="#1-4-1-微服务阶段" class="headerlink" title="1.4.1 微服务阶段"></a>1.4.1 微服务阶段</h4><p><strong>常见场景：</strong>项目后期，精益求精</p>
<p><strong>部署特点：</strong>所有业务都可以自由部署</p>
<p><strong>应用特点：</strong>业务复杂</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%8410.png" alt="微服务阶段"></p>
<h2 id="二、架构部署"><a href="#二、架构部署" class="headerlink" title="二、架构部署"></a>二、架构部署</h2><h3 id="2-1通用架构"><a href="#2-1通用架构" class="headerlink" title="2.1通用架构"></a>2.1通用架构</h3><p><strong>一级定位：</strong>核心组成部分 （web 、数据库、存储层 ）</p>
<p><strong>二级定位：</strong>功能增强部分 （web缓存、代理、数据库缓存）</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%8411.png" alt="通用架构"></p>
<h3 id="2-2部署项目"><a href="#2-2部署项目" class="headerlink" title="2.2部署项目"></a>2.2部署项目</h3><p>部署项目的时候，要遵循主次原则：</p>
<p>1.对于架构层中的一级角色，我们的<strong>部署原则</strong>是：站在用户访问资源角度，从后向前依次部署。 </p>
<p>2.对于架构层中的二级角色，我们的<strong>部署原则</strong>是：站在用户访问资源压力角度，需要部署哪里，就部署哪里，注意前后的信息交流。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>菜鸟去面试之三</title>
    <url>/%E8%8F%9C%E9%B8%9F%E5%8E%BB%E9%9D%A2%E8%AF%95%E4%B9%8B%E4%B8%89/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>受疫情影响，让互联网的寒冬更加寒冷，金三银四也凄凄惨惨戚戚。但在这几个月小闫发现，虽然初中级工程师岗位变少，但是高级工程师岗位却依然火爆，丝毫不受影响。让小闫不经想起大四实习时，总经理曾说「社会缺少的并不是人，而是人才。如何提升自己的核心竞争力才是破局之道，强者从不受寒冬影响」当然原话已经记不清，大概就是这么个意思，你懂的 ~</p>
<p>言归正传，今天为大家再带来一些面试题，祝大家事随人愿。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h3 id="1-通过装饰器装饰的函数如何不改变其自身相关信息"><a href="#1-通过装饰器装饰的函数如何不改变其自身相关信息" class="headerlink" title="1.通过装饰器装饰的函数如何不改变其自身相关信息"></a>1.通过装饰器装饰的函数如何不改变其自身相关信息</h3><p>答：可以使用模块 <code>functools</code> 中的 <code>wraps</code> 装饰器来装饰自定义装饰器的内函数。（有点绕口，下面查看示例）正常情况下被装饰的函数，虽然可以使用原函数名进行调用，但实际上此时的函数名指向了装饰器的内函数，可以通过打印 <code>__name__</code> 以及 <code>__doc__</code> 属性来验证。使用 <code>wraps</code> 后，被装饰的函数相关信息就会全部保留。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps  <span class="comment"># &lt;-- 导入模块</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eg_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)    # &lt;-- 使用装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwds)</span>:</span></span><br><span class="line">        <span class="string">"""内函数"""</span></span><br><span class="line">        print(<span class="string">'我是装饰器啊...'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwds)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用定义的装饰器装饰函数</span></span><br><span class="line"><span class="meta">@eg_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">noname</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    函数自身</span></span><br><span class="line"><span class="string">    :return: 无返回</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">'我是示例函数噻...'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">noname()</span><br><span class="line"><span class="comment"># 打印函数的 __name__ 属性</span></span><br><span class="line">print(noname.__name__)</span><br><span class="line"><span class="comment"># 打印函数的文档字符串</span></span><br><span class="line">print(noname.__doc__)</span><br></pre></td></tr></table></figure>

<p>然后查看输出结果进行验证：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">我是装饰器啊...</span><br><span class="line">我是示例函数噻...</span><br><span class="line">noname</span><br><span class="line"></span><br><span class="line">    函数自身</span><br><span class="line">    :<span class="keyword">return</span>: 无返回</span><br></pre></td></tr></table></figure>

<h3 id="2-手写一个类，可以连接-redis-并实现-get-和-set-方法"><a href="#2-手写一个类，可以连接-redis-并实现-get-和-set-方法" class="headerlink" title="2.手写一个类，可以连接 redis 并实现 get 和 set 方法"></a>2.手写一个类，可以连接 redis 并实现 get 和 set 方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisTest</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ip: str, port: int)</span>:</span></span><br><span class="line">        self.conn = redis.Redis(host=ip, port=port, decode_responses=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> self.conn.get(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self.conn.set(key, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis_obj = RedisTest(<span class="string">'127.0.0.1'</span>, <span class="number">6379</span>)</span><br><span class="line">redis_obj.set(<span class="string">'name'</span>, <span class="string">'ethanyan'</span>)</span><br><span class="line">name = redis_obj.get(<span class="string">'name'</span>)</span><br><span class="line">print(name) <span class="comment"># b'ethanyan'</span></span><br></pre></td></tr></table></figure>

<h3 id="3-elasticsearch-二次查询"><a href="#3-elasticsearch-二次查询" class="headerlink" title="3.elasticsearch 二次查询"></a>3.elasticsearch 二次查询</h3><p>答：<code>elasticsearch</code> 中可以通过 <code>terms lookup</code> （跨索引查询）实现二次查询。例如查询某个用户关注列表中所有用户发表的主帖，如果是拆开查询，需要两步：先查出关注列表，再查询发表的主帖。而使用 <code>terms lookup</code> 查询只需要一步即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">POST my-index-post/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"terms"</span>: &#123;</span><br><span class="line">            <span class="string">"user_item_id"</span>: &#123;</span><br><span class="line">              <span class="string">"index"</span>: <span class="string">"my-index-user"</span>,</span><br><span class="line">              <span class="string">"type"</span>: <span class="string">"user"</span>,</span><br><span class="line">              <span class="string">"id"</span>: <span class="string">"0f42d65be1f5287e1c9c26e3728814aa"</span>,</span><br><span class="line">              <span class="string">"path"</span>: <span class="string">"friends"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此示例来源于 <code>https://www.playpi.org/2019060601.html</code>。</p>
</blockquote>
<p>分析一下上面的 <code>DSL</code> 语句，它先利用 <code>id</code> 查询用户索引<code>my-index-user/user</code>，返回关注列表 <code>friends</code> 中的所有 <code>item_id</code>；然后利用上一步骤中返回的 <code>itemt_id</code> 列表，去匹配主帖的 <code>user_item_id</code> 字段，从而查询所有的主帖。</p>
<h3 id="4-语法糖-property"><a href="#4-语法糖-property" class="headerlink" title="4.语法糖 property"></a>4.语法糖 property</h3><p>答：<code>python</code> 中提供了一个装饰器 <code>property</code> ，在使用对象的私有属性时，可以不再使用属性的函数的调用方式，而像普通的公有属性一样去使用属性。简单进行举例，假设一个类中有一些私有属性，我们可以通过 <code>set/get</code> 方法，专门来为这些私有属性提供访问接口以及设置属性时的校验操作，增加程序的健壮性和安全性，但这样操作后接口调用比较繁琐，使用装饰器 <code>property</code> 后，再去设置或访问私有属性时，如同正常公有属性一样实现无感操作。</p>
<p>如果需要设计一个「银行账户类」，只需提供姓名和余额的访问与设置操作即可。首先看一下传统的 <code>set/get</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, money)</span>:</span></span><br><span class="line">        <span class="comment"># 为了安全性考虑，不能向外部直接暴露私密信息</span></span><br><span class="line">        self.__name = name  <span class="comment"># 帐户人姓名</span></span><br><span class="line">        self.__balance = money  <span class="comment"># 帐户余额</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_balance</span><span class="params">(self, money)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(money, int):</span><br><span class="line">            <span class="keyword">if</span> money &gt;= <span class="number">0</span>:</span><br><span class="line">                self.__balance = money</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">'输入的金额不正确'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'输入的金额不是数字'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_balance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__balance</span><br></pre></td></tr></table></figure>

<p>如果需要设置账户的余额，就需要调用方法 <code>set_balance</code>，而使用装饰器后，则大大进行了简化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, money)</span>:</span></span><br><span class="line">        self.__name = name  <span class="comment"># 帐户人姓名</span></span><br><span class="line">        self.__balance = money  <span class="comment"># 帐户余额</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># property 只能对获取方法装饰，并且获取方法不需要再写 get</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果 property 装饰的属性还有 set 方法，需要写到 get方法后定义</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__balance</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实现 set 方法， 格式： @xxx.setter ,xxx 要和property装饰的方法名一致</span></span><br><span class="line"><span class="meta">    @balance.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span><span class="params">(self, money)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(money, int):</span><br><span class="line">            <span class="keyword">if</span> money &gt;= <span class="number">0</span>:</span><br><span class="line">                self.__balance = money</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">'输入的金额不正确'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'输入的金额不是数字'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以像共有属性一样进行访问与设置</span></span><br><span class="line">ac = Account(<span class="string">'tom'</span>, <span class="number">10</span>)</span><br><span class="line">print(ac.name)</span><br><span class="line">print(ac.balance)</span><br><span class="line">ac.balance = <span class="number">1000</span></span><br><span class="line">print(ac.balance)</span><br></pre></td></tr></table></figure>

<h3 id="5-简单介绍一下-with-语句"><a href="#5-简单介绍一下-with-语句" class="headerlink" title="5.简单介绍一下 with 语句"></a>5.简单介绍一下 with 语句</h3><p>答：<code>with</code> 语句是一种简化的语法，适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的「清理」操作，释放资源。比如在连接数据库并进行相关操作后可以自动关闭，无需手动调用。其原理为自动调用了上下文管理器中的关闭语句，内部主要有两个方法构成 <code>__enter__</code> 和 <code>__exit__</code>。<code>__enter__</code> 方法会在执行 <code>with</code> 后面的语句时执行，一般用来处理操作前的内容。比如一些创建对象，初始化等。<code>__exit__</code> 方法会在 <code>with</code> 内的代码执行完毕后执行，一般用来处理一些善后收尾工作，比如文件的关闭，数据库的关闭等。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>继续死磕前端</title>
    <url>/%E7%BB%A7%E7%BB%AD%E6%AD%BB%E7%A3%95%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
昨天将所有的基础知识进行了回顾，今天继续磕，不死不休～

<p>今天要说的便是 jquery 这个函数库，毕竟它影响范围之广，不会都不好意说自己会前端？</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h2><p>long long ago ～ 人们发现了一个好用的工具，它涵盖了常用的所有功能，还提供了很多相当方便的设计（如 Ajax）。因此，它的面世，如星星之火燎原之势迅猛发展，以至于微软公司把它作为官方库。</p>
<p>这个小小的 js 文件，你可以说他是插件，也可以称其为框架，随你喜欢，只要知道一点，它很好用就可以了。肯定有人会问如何下载之类的问题，其实我很不愿意回答，毕竟这些随意百度到的东西很浪费时间和文字，但是秉承着服务的宗旨，贴出以下链接：</p>
<p>1、<a href="http://jquery.com/" target="_blank" rel="noopener">http://jquery.com/</a> 官方网站</p>
<p>2、<a href="https://code.jquery.com/" target="_blank" rel="noopener">https://code.jquery.com/</a> 版本下载</p>
<h3 id="1-简单入门"><a href="#1-简单入门" class="headerlink" title="1.简单入门"></a>1.简单入门</h3><p>还记得上篇文章反复强调的一个问题嘛？就是 js 代码放在何处执行的问题。要么老老实实放置在所需应用样式的标签后面，要么将其丢到 window.onload 方法内部。</p>
<p>jquery 提供了一种速度更快，使用更便捷的方式，那便是 ready 方法。它长成了下面美丽的样子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>嫌弃它的臃肿，可以简写为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  xxx</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在是否顺眼了许多？</p>
<h4 id="1-1-jquery-选择器"><a href="#1-1-jquery-选择器" class="headerlink" title="1.1 jquery 选择器"></a>1.1 jquery 选择器</h4><p>还记到大明湖畔（CSS）的夏雨荷（选择器）吗？选择器可以快速定位到元素并为其应用样式效果。jquery 选择器的选择规则与 CSS 相同，只是目的是为其添加操作。</p>
<p>不要有任何心理负担，它相当简单，如下：</p>
<p>1.选择 id 为 Ethan 的元素（类比 id 选择器）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#Ethan'</span>)</span><br></pre></td></tr></table></figure>

<p>2.选择 class 为  Yan 的元素（类比类选择器）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.Yan'</span>)</span><br></pre></td></tr></table></figure>

<p>3.选择所有的 p 标签（类比标签选择器）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'p'</span>)</span><br></pre></td></tr></table></figure>

<p>4.选择 id 为 mylist 的元素下所有 li 标签下的 span 元素（类比层级选择器）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#mylist li span'</span>)</span><br></pre></td></tr></table></figure>

<p>5.选择 name 属性为 yan 的 input 元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'input[name=yan]'</span>)</span><br></pre></td></tr></table></figure>

<p>如果一类元素范围太广，需要更精确一些呢？可以使用如下的过滤条件：</p>
<p>1.has 包含条件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).has(<span class="string">'p'</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>包含 p 元素的 div 元素</p>
</blockquote>
<p>2.判等条件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).eq(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第 5 个 div 元素</p>
</blockquote>
<p>3.寻找条件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#box'</span>).find(<span class="string">'.myClass'</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>选择 id 是 box 元素中 class 为 myClass 的元素</p>
</blockquote>
<p>4.前一个元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#box'</span>).prev();</span><br></pre></td></tr></table></figure>

<p>5.后一个元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#box'</span>).next();</span><br></pre></td></tr></table></figure>

<p>已经知道了如何定位某个元素，那么如何定位一个精确的集合呢？这个也不难：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择id是box的元素之前所有的同辈元素</span></span><br><span class="line">$(<span class="string">'#box'</span>).prevAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择id是box的元素后面所有的同辈元素</span></span><br><span class="line">$(<span class="string">'#box'</span>).nextAll(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//选择id是box的元素的父元素</span></span><br><span class="line">$(<span class="string">'#box'</span>).parent(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//选择id是box的元素的所有子元素</span></span><br><span class="line">$(<span class="string">'#box'</span>).children(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//选择id是box的元素的同级元素</span></span><br><span class="line">$(<span class="string">'#box'</span>).siblings();</span><br></pre></td></tr></table></figure>

<p>有人会想，如果我写错了，没找到报错怎么办？大可放心，jquery 有容错机制，即使没有找到元素，也不会出错。还为你提供了验证是否找到的方法，那便是 length 属性。length 值为 0 时代表没选择到想要元素；为 1 则代表选择到了相应的元素。</p>
<p>除了选择元素，还可以选择样式呢！啥都能找到，强不强？既然都能找到了，重新赋值也必须到位！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取div的样式</span></span><br><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"width"</span>);</span><br><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"color"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"width"</span>,<span class="string">"20px"</span>);</span><br><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"color"</span>,<span class="string">"red"</span>);</span><br></pre></td></tr></table></figure>

<p>如果你足够的细心，你也许会问，选择器一般都选择多个元素，那么你获取到的是哪一个元素的值呢？</p>
<p>答：第一个。</p>
<p>再看看其他操作样式的类名吧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为id为div1的对象追加样式divClass2</span></span><br><span class="line">$(<span class="string">"#div1"</span>).addClass(<span class="string">"divClass2"</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除id为div1的对象的class名为divClass的样式</span></span><br><span class="line">$(<span class="string">"#div1"</span>).removeClass(<span class="string">"divClass"</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除多个样式</span></span><br><span class="line">$(<span class="string">"#div1"</span>).removeClass(<span class="string">"divClass divClass2"</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 重复切换anotherClass样式</span></span><br><span class="line">$(<span class="string">"#div1"</span>).toggleClass(<span class="string">"anotherClass"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-绑定点击事件"><a href="#1-2-绑定点击事件" class="headerlink" title="1.2 绑定点击事件"></a>1.2 绑定点击事件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#btn'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 内部的 this 指的是原生对象</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 使用 jquery 对象用 $(this)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>js 对象与 jquery 对象有些许不同，jquery 对象是对 js 对象的封装，然后让其拥有了 jquery 的操作方法。他俩之间可以相互转换。</p>
<p>DOM 对象转 jquery 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(js对象)</span><br></pre></td></tr></table></figure>

<p>jquery 对象转 DOM 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery对象[index];    <span class="comment">//方式1 （推荐使用）</span></span><br><span class="line"></span><br><span class="line">jQuery对象.get(index); <span class="comment">//方式2</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>获取元素的索引值可以使用 index() 方法</p>
<h4 id="1-3-jquery-动画"><a href="#1-3-jquery-动画" class="headerlink" title="1.3 jquery 动画"></a>1.3 jquery 动画</h4><p>通过 animate 方法可以设置元素某属性值上的动画，动画执行完后会执行一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#div1'</span>).animate(&#123;</span><br><span class="line">    width:<span class="number">300</span>,</span><br><span class="line">    height:<span class="number">300</span></span><br><span class="line">&#125;,<span class="number">1000</span>,<span class="string">'swing'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'done!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>animate 参数详解</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    animate参数：</span></span><br><span class="line"><span class="comment">    参数一：要改变的样式属性值，写成字典的形式</span></span><br><span class="line"><span class="comment">    参数二：动画持续的时间，单位为毫秒，一般不写单位</span></span><br><span class="line"><span class="comment">    参数三：动画曲线，默认为‘swing’，缓冲运动，还可以设置为‘linear’，匀速运动</span></span><br><span class="line"><span class="comment">    参数四：动画回调函数，动画完成后执行的匿名函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-进阶"><a href="#2-进阶" class="headerlink" title="2.进阶"></a>2.进阶</h3><h4 id="2-1-特殊效果"><a href="#2-1-特殊效果" class="headerlink" title="2.1 特殊效果"></a>2.1 特殊效果</h4><p>1.<code>fadeIn()</code> 淡入</p>
<p>2.<code>fadeOut()</code> 淡出</p>
<p>3.<code>hide()</code> 隐藏</p>
<p>4.<code>show()</code> 显示</p>
<p>5.<code>toggle()</code> 切换元素的可见状态</p>
<p>6.<code>slideDown()</code> 向下展开</p>
<p>7.<code>slideUp()</code> 向上卷起</p>
<p>8.<code>slideToggle()</code> 依次展开或卷起某个元素</p>
<p><strong>Example</strong>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$btn.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">'#div1'</span>).fadeIn(<span class="number">1000</span>,</span><br><span class="line">                   <span class="string">'swing'</span>,</span><br><span class="line">                   <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    									alert(<span class="string">'done'</span>);</span><br><span class="line">  								&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在看过很多属性时，不知道大家是否发现了一个规律：凡是成对出现的属性，一般都有一个组合属性，名字带有 <code>toggle</code></p>
</blockquote>
<h4 id="2-2-链式调用"><a href="#2-2-链式调用" class="headerlink" title="2.2 链式调用"></a>2.2 链式调用</h4><p>链式调用，其实就是将多个方法一直拼接在对象后面，像链条一样调用。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#div1'</span>) <span class="comment">// id为div1的元素</span></span><br><span class="line">.children(<span class="string">'ul'</span>) <span class="comment">//该元素下面的ul子元素</span></span><br><span class="line">.slideDown(<span class="string">'fast'</span>) <span class="comment">//高度从零变到实际高度来显示ul元素</span></span><br><span class="line">.parent()  <span class="comment">//跳到ul的父元素，也就是id为div1的元素</span></span><br><span class="line">.siblings()  <span class="comment">//跳到div1元素平级的所有兄弟元素</span></span><br><span class="line">.children(<span class="string">'ul'</span>) <span class="comment">//这些兄弟元素中的ul子元素</span></span><br><span class="line">.slideUp(<span class="string">'fast'</span>);  <span class="comment">//高度实际高度变换到零来隐藏ul元素</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>换行是为了加注释解释每一个方法，其实它为一行。</p>
</blockquote>
<h4 id="2-3-属性操作"><a href="#2-3-属性操作" class="headerlink" title="2.3 属性操作"></a>2.3 属性操作</h4><p>还记得昨天总结中 js 对象如何获取元素内容嘛？没错，是 <code>innerHTML</code>。jquery 中则是使用 html() 方法获取和设置 html 内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line"><span class="keyword">var</span> $htm = $(<span class="string">'#div1'</span>).html();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 html 内容</span></span><br><span class="line">$(<span class="string">'#div1'</span>).html(<span class="string">'&lt;span&gt;xxx&lt;/span&gt;'</span>);</span><br></pre></td></tr></table></figure>

<p>jquery 中获取或者设置某个属性值时可以使用如下方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取出图片的地址</span></span><br><span class="line"><span class="keyword">var</span> $src = $(<span class="string">'#img1'</span>).prop(<span class="string">'src'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置图片的地址和alt属性</span></span><br><span class="line">$(<span class="string">'#img1'</span>).prop(&#123;<span class="attr">src</span>: <span class="string">"test.jpg"</span>, <span class="attr">alt</span>: <span class="string">"Test Image"</span> &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-4-事件"><a href="#2-4-事件" class="headerlink" title="2.4 事件"></a>2.4 事件</h4><p><strong>常用的一些事件函数</strong>：</p>
<p>1.<code>blur()</code> 元素失去焦点</p>
<p>2.<code>focus()</code> 元素获得焦点</p>
<p>3.<code>click()</code> 鼠标单击</p>
<p>4.<code>mouseover()</code> 鼠标进入（进入子元素也触发）</p>
<p>5.<code>mouseout()</code> 鼠标离开（离开子元素也触发）</p>
<p>6.<code>mouseenter()</code> 鼠标进入（进入子元素不触发）</p>
<p>7.<code>mouseleave()</code> 鼠标离开（离开子元素不触发）</p>
<p>8.<code>hover()</code> 同时为mouseenter和mouseleave事件指定处理函数</p>
<p>9.<code>ready()</code> DOM加载完成</p>
<p>10.<code>submit()</code> 用户递交表单</p>
<h4 id="2-5-正则表达式-表单验证"><a href="#2-5-正则表达式-表单验证" class="headerlink" title="2.5 正则表达式-表单验证"></a>2.5 正则表达式-表单验证</h4><p>正则表达式无比强大，处处可以看见其身影。当我们验证邮箱格式、手机号、身份证号时必不可少，那么 jquery 中如何使用呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'规则'</span>, <span class="string">'可选参数'</span>);</span><br><span class="line"><span class="keyword">var</span> re=<span class="regexp">/规则/</span>参数;</span><br></pre></td></tr></table></figure>

<p>大家可以看到，其由规则与参数两部分组成。其中规则老生常谈，我们再复习一遍：</p>
<p><code>\d</code> 匹配一个数字，即0-9</p>
<p><code>\D</code> 匹配一个非数字，即除了0-9</p>
<p><code>\w</code> 匹配一个单词字符（字母、数字、下划线）</p>
<p><code>\W</code> 匹配任何非单词字符。等价于<code>[^A-Za-z0-9_]</code></p>
<p><code>\s</code> 匹配一个空白符</p>
<p><code>\S</code> 匹配一个非空白符</p>
<p><code>\b</code> 匹配单词边界</p>
<p><code>\B</code> 匹配非单词边界</p>
<p><code>.</code> 匹配一个任意字符</p>
<p><strong>量词</strong>：</p>
<p><code>?</code> 出现零次或一次（最多出现一次）</p>
<p><code>+</code> 出现一次或多次（至少出现一次）</p>
<p><code>*</code> 出现零次或多次（任意次）</p>
<p><code>{n}</code> 出现n次</p>
<p><code>{n,m}</code> 出现n到m次</p>
<p><code>{n,}</code> 至少出现n次</p>
<p><strong>范围</strong>：使用中括号将可选内容列出，代表内容中任意一个</p>
<p><code>[abc123]</code> : 匹配‘abc123’中的任意一个字符</p>
<p><code>[a-z0-9]</code> : 匹配a到z或者0到9中的任意一个字符</p>
<p><strong>限制开头与结尾</strong>：</p>
<p><code>^</code> 以紧挨的元素开头</p>
<p><code>$</code> 以紧挨的元素结尾</p>
<p>那么<strong>参数</strong>部分，常用的有：</p>
<p><code>g</code>： global，全文搜索，默认搜索到第一个结果接停止</p>
<p><code>i</code>： ingore case，忽略大小写，默认大小写敏感</p>
<p>还有常用的<strong>函数</strong></p>
<p><code>test</code></p>
<p>用法：<code>正则.test(字符串)</code> 匹配成功，就返回真，否则就返回假</p>
<p><strong>正则默认规则</strong> </p>
<p>匹配成功就结束，不会继续匹配，区分大小写</p>
<p>下面给大家个福利，总结了常用的正则表达式，直接复制粘贴即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户名验证：(数字字母或下划线6到20位)</span></span><br><span class="line"><span class="keyword">var</span> reUser = <span class="regexp">/^\w&#123;6,20&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邮箱验证：        </span></span><br><span class="line"><span class="keyword">var</span> reMail = <span class="regexp">/^[a-z0-9][\w\.\-]*@[a-z0-9\-]+(\.[a-z]&#123;2,5&#125;)&#123;1,2&#125;$/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//密码验证：</span></span><br><span class="line"><span class="keyword">var</span> rePass = <span class="regexp">/^[\w!@#$%^&amp;*]&#123;6,20&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手机号码验证：</span></span><br><span class="line"><span class="keyword">var</span> rePhone = <span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>;</span><br></pre></td></tr></table></figure>


<h3 id="3-高级"><a href="#3-高级" class="headerlink" title="3.高级"></a>3.高级</h3><h4 id="3-1-事件冒泡"><a href="#3-1-事件冒泡" class="headerlink" title="3.1 事件冒泡"></a>3.1 事件冒泡</h4><p>先来看看什么是事件冒泡：</p>
<blockquote>
<p>在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。</p>
</blockquote>
<p>就这样一层一层往上冒的效果，我们形象的称为冒泡。那么它有什么作用呢？</p>
<p>答：事件冒泡允许多个操作被集中处理（把事件处理器添加到一个父级元素上，避免把事件处理器添加到多个子级元素上），它还可以让你在对象层的不同级别捕获事件。</p>
<p>这只是一种机制，但是我们并不是任何情况下都需要，那么可以将其关掉。通过：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.stopPropagation();</span><br></pre></td></tr></table></figure>

<p>既然说起阻止事件冒泡了，那么我们也提一下如何阻止表单提交吧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure>

<p>实际开发中其实常常将其混合使用，也就是两句话写在一起使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// event.stopPropagation();</span></span><br><span class="line"><span class="comment">// event.preventDefault();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并写法：</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-事件委托"><a href="#3-2-事件委托" class="headerlink" title="3.2 事件委托"></a>3.2 事件委托</h4><p>同样，先来看定义：</p>
<blockquote>
<p>事件委托就是利用冒泡的原理，把事件加到父级上，通过判断事件来源的子集，执行相应的操作，事件委托首先可以极大减少事件绑定次数，提高性能；其次可以让新加入的子元素也可以拥有相同的操作。</p>
</blockquote>
<p><strong>一般绑定事件的写法</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">    $ali &#x3D; $(&#39;#list li&#39;);</span><br><span class="line">    $ali.click(function() &#123;</span><br><span class="line">        $(this).css(&#123;background:&#39;red&#39;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line">&lt;ul id&#x3D;&quot;list&quot;&gt;</span><br><span class="line">    &lt;li&gt;1&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;4&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;5&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>

<p><strong>事件委托的写法</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">    $list &#x3D; $(&#39;#list&#39;);</span><br><span class="line">    $list.delegate(&#39;li&#39;, &#39;click&#39;, function() &#123;</span><br><span class="line">        $(this).css(&#123;background:&#39;red&#39;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line">&lt;ul id&#x3D;&quot;list&quot;&gt;</span><br><span class="line">    &lt;li&gt;1&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;4&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;5&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-Dom-操作"><a href="#3-3-Dom-操作" class="headerlink" title="3.3 Dom 操作"></a>3.3 Dom 操作</h4><p>Dom 操作也叫做元素节点操作，它指的是改变html的标签结构，它有两种情况：</p>
<p>1、移动现有标签的位置</p>
<p>2、将新创建的标签插入到现有的标签中 </p>
<p><strong>创建新标签</strong> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $div = $(<span class="string">'&lt;div&gt;'</span>); <span class="comment">//创建一个空的div</span></span><br><span class="line"><span class="keyword">var</span> $div2 = $(<span class="string">'&lt;div&gt;这是一个div元素&lt;/div&gt;'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>移动或者插入标签的方法</strong> </p>
<p>1、<code>append()</code> 和 <code>appendTo()</code>：在现存元素的内部，从后面放入元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $span = $(<span class="string">'&lt;span&gt;这是一个span元素&lt;/span&gt;'</span>);</span><br><span class="line">$(<span class="string">'#div1'</span>).append($span);</span><br><span class="line">......</span><br><span class="line">&lt;div id=<span class="string">"div1"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、<code>prepend()</code> 和 <code>prependTo()</code>：在现存元素的内部，从前面放入元素</p>
<p>3、<code>after()</code> 和 <code>insertAfter()</code>：在现存元素的外部，从后面放入元素</p>
<p>4、<code>before()</code> 和 <code>insertBefore()</code>：在现存元素的外部，从前面放入元素</p>
<p><strong>删除标签</strong> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#div1'</span>).remove();</span><br></pre></td></tr></table></figure>

<h4 id="3-4-对象"><a href="#3-4-对象" class="headerlink" title="3.4 对象"></a>3.4 对象</h4><p>JavaScript 的对象，可以简单的理解为一个键值对的集合，也就是 python 中的字典，键就是调用每个值的名称，值就是变量、函数、对象这些。</p>
<p>面向对象编程深入人心，有着 python 、java 的基础，大家应该不难理解。接下来说一下 js 中如何创建一个对象，并对其进行操作。</p>
<p>1.创建一个对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Ethan'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello'</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.添加属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.name = <span class="string">'tom'</span>;</span><br><span class="line">person.age = <span class="string">'99'</span>;</span><br></pre></td></tr></table></figure>

<p>3.添加方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name + <span class="string">'你好'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.调用方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.sayHello();</span><br><span class="line">person.age;</span><br></pre></td></tr></table></figure>

<h3 id="4-Ajax"><a href="#4-Ajax" class="headerlink" title="4.Ajax"></a>4.Ajax</h3><p>ajax一个前后台配合的技术，它可以让 javascript 发送 http 请求，与后台通信，获取数据和信息。ajax 技术的原理是实例化 xmlhttp 对象，使用此对象与后台通信。jquery 将它封装成了一个函数 <code>$.ajax()</code>，我们可以直接用这个函数来执行ajax请求。</p>
<p>此部分<strong>超级重要！超级重要！超级重要！</strong></p>
<blockquote>
<p>ajax需要在服务器环境下运行。</p>
</blockquote>
<p>先来看一个示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/change_data'</span>,</span><br><span class="line">    type: <span class="string">'GET'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    data:&#123;<span class="string">'code'</span>:<span class="number">300268</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.done(<span class="function"><span class="keyword">function</span>(<span class="params">dat</span>) </span>&#123;</span><br><span class="line">    alert(dat.name);</span><br><span class="line">&#125;)</span><br><span class="line">.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'服务器超时，请重试！'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后看一下其中的参数：</p>
<p>1、<code>url</code> 请求地址</p>
<p>2、<code>type</code> 请求方式，默认是 <code>GET</code>，常用的还有 <code>POST</code></p>
<p>3、<code>dataType</code> 设置返回的数据格式，常用的是 <code>json</code> 格式，也可以设置为<code>html</code></p>
<p>4、<code>data</code> 设置发送给服务器的数据</p>
<p>5、<code>success</code> 设置请求成功后的回调函数</p>
<p>6、<code>error</code> 设置请求失败后的回调函数</p>
<p>7、<code>async</code> 设置是否异步，默认值是 <code>true</code>，表示异步</p>
<p>简写方式：</p>
<p><code>$.ajax</code> 按照请求方式可以简写成 <code>$.get</code> 或者 <code>$.post</code> 方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="keyword">get</span>("/change_data", &#123;<span class="string">'code'</span>:<span class="number">300268</span>&#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">dat,status</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(status==<span class="string">'success'</span>)&#123;</span><br><span class="line">    	alert(dat.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">'json'</span>);</span><br><span class="line"></span><br><span class="line">$.post(<span class="string">"/change_data"</span>, &#123;<span class="string">'code'</span>:<span class="number">300268</span>&#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">dat</span>)</span>&#123;</span><br><span class="line">    alert(dat.name);</span><br><span class="line">&#125;,<span class="string">'json'</span>);</span><br></pre></td></tr></table></figure>

<p>我们经常会听到两个词：局部刷新 和 无刷新。这是什么意思呢？</p>
<p>答：ajax可以实现局部刷新，也叫做无刷新，无刷新指的是整个页面不刷新，只是局部刷新，ajax可以自己发送http请求，不用通过浏览器的地址栏，所以页面整体不会刷新，ajax获取到后台数据，更新页面显示数据的部分，就做到了页面局部刷新。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>菜鸟去面试之二</title>
    <url>/%E8%8F%9C%E9%B8%9F%E5%8E%BB%E9%9D%A2%E8%AF%95%E4%B9%8B%E4%BA%8C/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>今天是华为进行的复试，明天还有综合面试。快来看一下今天的题目吧。</p>
<blockquote>
<p>关于项目以及灵活的题目此处并未体现，只将一些记忆深刻的通用题目汇总展示，希望可以帮助到大家。</p>
</blockquote>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-Python"><a href="#1-Python" class="headerlink" title="1.Python"></a>1.Python</h2><h3 id="1-1-字符串的-find-和-index-方法有什么区别"><a href="#1-1-字符串的-find-和-index-方法有什么区别" class="headerlink" title="1.1 字符串的 find 和 index 方法有什么区别"></a>1.1 字符串的 find 和 index 方法有什么区别</h3><p>答：<code>find</code> 方法会检测某一字符串片段是否在指定字符串中，如果在内，会返回开始的索引值，不存在则返回 -1；<code>index</code> 方法与 <code>find</code> 作用相同，只不过在不存在的情况下会抛出异常。</p>
<h3 id="1-2-元祖不使用下标的情况下如何取值"><a href="#1-2-元祖不使用下标的情况下如何取值" class="headerlink" title="1.2 元祖不使用下标的情况下如何取值"></a>1.2 元祖不使用下标的情况下如何取值</h3><p>答：可以采用如下类似字典的取值方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mytuple = ((<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'b'</span>,<span class="number">2</span>))</span><br><span class="line">value = dict(mytuple).get(<span class="string">'a'</span>)</span><br><span class="line">print(value)</span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这道题当时并未做出，无具体答案</p>
</blockquote>
<h3 id="1-3-列表推导式"><a href="#1-3-列表推导式" class="headerlink" title="1.3 列表推导式"></a>1.3 列表推导式</h3><p>问：已知列表 [‘a’, ‘b’, ‘c’]，需要得到列表 [‘aa’, ‘bb’, ‘cc’]。采用列表推导式的方式如何实现？</p>
<p>答：代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">newlist = [x+x <span class="keyword">for</span> x <span class="keyword">in</span> alist]</span><br><span class="line">print(newlist)</span><br><span class="line"><span class="comment"># ['aa', 'bb', 'cc']</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-三目运算符"><a href="#1-4-三目运算符" class="headerlink" title="1.4 三目运算符"></a>1.4 三目运算符</h3><p>问：<code>C</code> 语言中的如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">表达式<span class="number">1</span> ? 表达式<span class="number">2</span> : 表达式<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>在 <code>python</code> 中如何实现？</p>
<p>答：代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">表达式<span class="number">1</span> <span class="keyword">if</span> 表达式<span class="number">2</span> <span class="keyword">else</span> 表达式<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="1-5-不定长参数如何定义与取值"><a href="#1-5-不定长参数如何定义与取值" class="headerlink" title="1.5 不定长参数如何定义与取值"></a>1.5 不定长参数如何定义与取值</h3><p>答：下面定义一个函数，使用不定长参数并在函数内部获取参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name, age, *args, **kwargs)</span>:</span></span><br><span class="line">    print(name)</span><br><span class="line">    print(age)</span><br><span class="line">    print(<span class="string">"args is &#123;&#125;"</span>.format(args))</span><br><span class="line">    print(<span class="string">"kwargs is"</span>)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        print(<span class="string">"'&#123;&#125;': &#123;&#125;"</span>.format(k, v))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(<span class="string">'Ethan'</span>, <span class="number">18</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, m=<span class="number">1</span>, n=<span class="number">2</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Ethan</span></span><br><span class="line"><span class="string">18</span></span><br><span class="line"><span class="string">args is (2, 3, 4)</span></span><br><span class="line"><span class="string">kwargs is</span></span><br><span class="line"><span class="string">'m': 1</span></span><br><span class="line"><span class="string">'n': 2</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h3 id="1-6-多进程"><a href="#1-6-多进程" class="headerlink" title="1.6 多进程"></a>1.6 多进程</h3><p>问：如何开启一个进程？</p>
<p>答：在 <code>python</code> 中可以使用模块 <code>multiprocessing</code> 的 <code>Process</code> 方法开启多进程。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""子进程要执行的代码"""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"----2----"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建子进程</span></span><br><span class="line">    sub_process = multiprocessing.Process(target=run_proc)</span><br><span class="line">    <span class="comment"># 启动子进程</span></span><br><span class="line">    sub_process.start()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"----1----"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">---<span class="number">-1</span>----</span><br><span class="line">---<span class="number">-2</span>----</span><br><span class="line">---<span class="number">-2</span>----</span><br><span class="line">---<span class="number">-1</span>----</span><br><span class="line">---<span class="number">-2</span>----</span><br><span class="line">---<span class="number">-1</span>----</span><br><span class="line">---<span class="number">-2</span>----</span><br><span class="line">---<span class="number">-1</span>----</span><br></pre></td></tr></table></figure>

<h2 id="2-Django"><a href="#2-Django" class="headerlink" title="2.Django"></a>2.Django</h2><h3 id="2-1-Django-如何执行原生-sql-语句"><a href="#2-1-Django-如何执行原生-sql-语句" class="headerlink" title="2.1 Django 如何执行原生 sql 语句"></a>2.1 Django 如何执行原生 sql 语句</h3><p>答：可以使用游标的方式，也可以使用 <code>raw</code> 方法或者 <code>extra</code> 方法。</p>
<blockquote>
<p>游标以及 <code>raw</code> 为官方文档提示的用法，另外一种来源于网络。</p>
</blockquote>
<h4 id="2-1-1-游标"><a href="#2-1-1-游标" class="headerlink" title="2.1.1 游标"></a>2.1.1 游标</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection，connections</span><br><span class="line"></span><br><span class="line"><span class="comment"># cursor = connection.cursor()</span></span><br><span class="line"><span class="comment"># cursor = connections['数据库的名字，setting设置的'].cursor()</span></span><br><span class="line"><span class="keyword">with</span> connection.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">    cursor.execute(<span class="string">"要执行的sql语句"</span>)</span><br><span class="line">    row = cursor.fetchall()  <span class="comment"># fetchone,dictfetchall(cursor)</span></span><br><span class="line">    print(row)</span><br><span class="line">    <span class="comment"># ((xxx,xxx),(xxx,xxx)...)</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-raw"><a href="#2-1-2-raw" class="headerlink" title="2.1.2 raw"></a>2.1.2 raw</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = 模型类.objects.raw(<span class="string">"原生sql"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-extra"><a href="#2-1-3-extra" class="headerlink" title="2.1.3 extra"></a>2.1.3 extra</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">模型类.objects.extra(可选择执行select后条件还是直接执行where后条件)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Entry.objects.extra(select=&#123;<span class="string">'new_id'</span>: <span class="string">"select col from sometable where othercol &gt; %s"</span>&#125;, select_params=(<span class="number">1</span>,))</span><br><span class="line"> </span><br><span class="line">Entry.objects.extra(where=[<span class="string">"foo='a' OR bar = 'a'"</span>, <span class="string">"baz = 'a'"</span>])</span><br><span class="line"> </span><br><span class="line">Entry.objects.extra(select=&#123;<span class="string">'new_id'</span>: <span class="string">"select id from tb where id &gt; %s"</span>&#125;, select_params=(<span class="number">1</span>,), order_by=[<span class="string">'-nid'</span>])</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「日上フブキ」的原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/DeskyAki/article/details/<span class="number">89070360</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-如果需要给数据库插入1000条数据，如何操作"><a href="#2-2-如果需要给数据库插入1000条数据，如何操作" class="headerlink" title="2.2 如果需要给数据库插入1000条数据，如何操作"></a>2.2 如果需要给数据库插入1000条数据，如何操作</h3><blockquote>
<p>我回答使用循环，面试官轻蔑一笑我只能投降。</p>
</blockquote>
<p>答：可以使用模块 <code>pymysql</code> 中游标的一个方法 <code>executemany</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">execute(sql)</span><br><span class="line"></span><br><span class="line">    - 可接受一条语句从而执行</span><br><span class="line"></span><br><span class="line">executemany(templet,args)</span><br><span class="line"></span><br><span class="line">    - 能同时执行多条语句，执行同样多的sql语句比execute()快得多，强烈建议执行多条语句时使用executemany</span><br><span class="line"></span><br><span class="line">    - templet：sql模板字符串</span><br><span class="line"></span><br><span class="line">        - 例如： ‘insert into table(id,name) values(%s,%s)’</span><br><span class="line"></span><br><span class="line">    - args:模板字符串中的参数，是一个列表，列表中的每一个元素必须是元组！！！</span><br><span class="line"></span><br><span class="line">        - 例如：[(<span class="number">1</span>,<span class="string">'小明'</span>),(<span class="number">2</span>,<span class="string">'小红'</span>),(<span class="number">3</span>,<span class="string">'琦琦'</span>),(<span class="number">4</span>,<span class="string">'韩梅梅'</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="2-3-Django-一个请求的执行过程"><a href="#2-3-Django-一个请求的执行过程" class="headerlink" title="2.3 Django 一个请求的执行过程"></a>2.3 Django 一个请求的执行过程</h3><p>答：当请求访问后端服务器时，会先根据 <code>url</code> 在项目总的 <code>urls.py</code> 文件中进行匹配，然后截取剩余路径到单个应用的 <code>urls.py</code> 文件中进行匹配（如果匹配不到直接返回404）。路由到具体视图后，可以与模型类进行交互，也可以与模板进行交互填充等。在完成具体的业务逻辑后，视图将填充好的页面返回给客户端进行渲染展示。</p>
<blockquote>
<p>可以结合 <code>MVT</code> 进行说明，也可以具体到代码细节进行阐释。</p>
</blockquote>
<h3 id="2-4-Django-获取参数的两种方法"><a href="#2-4-Django-获取参数的两种方法" class="headerlink" title="2.4 Django 获取参数的两种方法"></a>2.4 Django 获取参数的两种方法</h3><p>问：现在有两种方式向服务器传递参数，一种是路径方式传递，一种是表单类型传递。请说明一下在视图中如何取到这些参数，假设参数为 <code>a</code> 和 <code>b</code>。</p>
<p>答：如果是路径方式传递的参数，可以使用如下方式获取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url(<span class="string">r'^example/(?P&lt;a&gt;[a-z]+)/(?P&lt;b&gt;\d&#123;4&#125;)/$'</span>, views.example),</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">(request, a, b)</span>:</span></span><br><span class="line">    print(<span class="string">'a=%s'</span> % a)</span><br><span class="line">    print(<span class="string">'b=%s'</span> % b)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'OK'</span>)</span><br></pre></td></tr></table></figure>

<p>如果是表单类型传递，则利用下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_body</span><span class="params">(request)</span>:</span></span><br><span class="line">    a = request.POST.get(<span class="string">'a'</span>)</span><br><span class="line">    b = request.POST.get(<span class="string">'b'</span>)</span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'OK'</span>)</span><br></pre></td></tr></table></figure>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点总结</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>《计算机网络》第五版 谢希仁</strong> 知识点大汇总</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-OSI、TCP-IP、五层协议的体系结构以及各层协议"><a href="#1-OSI、TCP-IP、五层协议的体系结构以及各层协议" class="headerlink" title="1.OSI、TCP/IP、五层协议的体系结构以及各层协议"></a>1.OSI、TCP/IP、五层协议的体系结构以及各层协议</h2><p><img src="https://github.com/EthanYan6/pic/raw/master/1.png" alt="img"></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/2.png" alt="img"></p>
<p><strong>OSI分层（7层）</strong>：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p><strong>TCP/IP分层（4层）</strong>：网络接口层、网际层、运输层、应用层。</p>
<p><strong>五层协议（5层）</strong>：物理层、数据链路层、网络层、运输层、应用层。</p>
<p><strong><em>每一层的协议如下：</em></strong></p>
<p><strong>物理层：</strong><code>RJ45</code>、<code>CLOCK</code>、<code>IEEE802.3</code>   （中继器，集线器，网关）</p>
<p><strong>数据链路：</strong><code>PPP</code>、<code>FR</code>、<code>HDLC</code>、<code>VLAN</code>、<code>MAC</code>  （网桥，交换机）</p>
<p><strong>网络层：</strong><code>IP</code>、<code>ICMP</code>、<code>ARP</code>、<code>RARP</code>、<code>OSPF</code>、<code>IPX</code>、<code>RIP</code>、<code>IGRP</code> （路由器）</p>
<p><strong>传输层：</strong><code>TCP</code>、<code>UDP</code>、<code>SPX</code></p>
<p><strong>会话层：</strong><code>NFS</code>、<code>SQL</code>、<code>NETBIOS</code>、<code>RPC</code></p>
<p><strong>表示层：</strong><code>JPEG</code>、<code>MPEG</code>、<code>ASII</code></p>
<p><strong>应用层：</strong><code>FTP</code>、<code>DNS</code>、<code>Telnet</code>、<code>SMTP</code>、<code>HTTP</code>、<code>WWW</code>、<code>NFS</code></p>
<p><strong><em>每一层的作用如下：</em></strong></p>
<p><strong>物理层：</strong>通过媒介传输比特,确定机械及电气规范（比特 <code>Bit</code>）</p>
<p><strong>数据链路层</strong>：将比特组装成帧和点到点的传递（帧 <code>Frame</code>）</p>
<p><strong>网络层</strong>：负责数据包从源到宿的传递和网际互连（包 <code>PackeT</code>）</p>
<p><strong>传输层</strong>：提供端到端的可靠报文传递和错误恢复（段 <code>Segment</code>）</p>
<p><strong>会话层</strong>：建立、管理和终止会话（会话协议数据单元 <code>SPDU</code>）</p>
<p><strong>表示层</strong>：对数据进行翻译、加密和压缩（表示协议数据单元 <code>PPDU</code>）</p>
<p><strong>应用层</strong>：允许访问 <code>OSI</code> 环境的手段（应用协议数据单元 <code>APDU</code>）</p>
<h2 id="2-IP地址分类"><a href="#2-IP地址分类" class="headerlink" title="2.IP地址分类"></a>2.IP地址分类</h2><p>　　<code>IP</code> 地址是32位的二进制数值，用于在 <code>TCP/IP</code> 通讯协议中标记每台计算机的地址。通常我们使用点式十进制来表示，如192.168.0.5等等。</p>
<p>　　每个 <code>IP</code> 地址又可分为两部分。即网络号部分和主机号部分：网络号表示其所属的网络段编号，主机号则表示该网段中该主机的地址编号。按照网络规模的大小，<code>IP</code> 地址可以分为 <code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>、<code>E</code> 五类。</p>
<p>A类地址：以0开头，第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）；</p>
<p>B类地址：以10开头，第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；</p>
<p>C类地址：以110开头，第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类别         网络号                  &#x2F;占位数      主机号             &#x2F;    占位数    用途</span><br><span class="line"></span><br><span class="line">A（以0开头）  1～126                 &#x2F;  8      0～255 0～255 1～254 &#x2F;     24      国家级</span><br><span class="line"></span><br><span class="line">B（以10开头） 128～191 0～255        &#x2F;  16     0～255 1～254        &#x2F;     16      跨过组织</span><br><span class="line"></span><br><span class="line">C（以110开头）192～223 0～255 0～255 &#x2F;  24     1～254               &#x2F;     8       企业组织</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>1）以下是留用的内部私有地址，<code>Internet</code> 上没使用的地址</p>
<p><code>A</code> 类 10.0.0.0–10.255.255.255</p>
<p><code>B</code> 类 172.16.0.0–172.31.255.255</p>
<p><code>C</code> 类 192.168.0.0–192.168.255.255</p>
<p>2）<code>IP</code> 地址与子网掩码相与得到网络号</p>
<p>3）主机号，全为0的是网络号（例如：192.168.2.0），主机号全为1的为广播地址（192.168.2.255）</p>
<h2 id="3-ARP是地址解析协议，简单语言解释一下工作原理"><a href="#3-ARP是地址解析协议，简单语言解释一下工作原理" class="headerlink" title="3.ARP是地址解析协议，简单语言解释一下工作原理"></a>3.ARP是地址解析协议，简单语言解释一下工作原理</h2><p>地址解析协议，即 <code>ARP</code>（<code>Address Resolution Protocol</code>），是根据 <code>IP</code> 地址获取物理地址的一个 <code>TCP/IP</code> 协议。</p>
<p>1.首先，每个主机都会在自己的 <code>ARP</code> 缓冲区中建立一个 <code>ARP</code> 列表，以表示 <code>IP</code> 地址和 <code>MAC</code> 地址之间的对应关系。</p>
<p>2.当源主机要发送数据时，首先检查ARP列表中是否有对应 <code>IP</code> 地址的目的主机的 <code>MAC</code> 地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送 <code>ARP</code> 数据包，该数据包包括的内容有：源主机<code>IP</code>地址，源主机 <code>MAC</code> 地址，目的主机的 <code>IP</code> 地址</p>
<p>3.当本网络的所有主机收到该 <code>ARP</code> 数据包时，首先检查数据包中的 <code>IP</code> 地址是否是自己的 <code>IP</code> 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 <code>IP</code> 和 <code>MAC</code> 地址写入到 <code>ARP</code> 列表中，如果已经存在，则覆盖，然后将自己的 <code>MAC</code> 地址写入 <code>ARP</code> 响应包中，告诉源主机自己是它想要找的 <code>MAC</code> 地址。</p>
<p>4.源主机收到 <code>ARP</code> 响应包后。将目的主机的 <code>IP</code> 和 <code>MAC</code> 地址写入 <code>ARP</code> 列表，并利用此信息发送数据。如果源主机一直没有收到 <code>ARP</code> 响应数据包，表示 <code>ARP</code> 查询失败。</p>
<p><strong>注意：广播（255.255.255.255）发送 <code>ARP</code> 请求，单播发送 <code>ARP</code> 响应。</strong></p>
<h2 id="4-简单介绍几种协议"><a href="#4-简单介绍几种协议" class="headerlink" title="4.简单介绍几种协议"></a>4.简单介绍几种协议</h2><p><code>ICMP</code> 协议： 因特网控制报文协议。它是 <code>TCP/IP</code> 协议族的一个子协议，用于在 <code>IP</code> 主机、路由器之间传递控制消息</p>
<p><code>TFTP</code> 协议： 是 <code>TCP/IP</code> 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</p>
<p><code>HTTP</code> 协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统</p>
<p><code>NAT</code> 协议：网络地址转换属接入广域网( <code>WAN</code> )技术，是一种将私有（保留）地址转化为合法 <code>IP</code> 地址的转换技术</p>
<p><code>DHCP</code> 协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段，使用 <code>UDP</code> 协议工作。<strong>具体用途</strong>：给内部网络或网络服务供应商自动分配 <code>IP</code> 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<h2 id="5-TCP三次握手四次挥手"><a href="#5-TCP三次握手四次挥手" class="headerlink" title="5.TCP三次握手四次挥手"></a>5.TCP三次握手四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次握手：客户端发送 <code>syn</code> 包( <code>seq=x</code> )到服务器，并进入 <code>SYN_SEND</code> (发送)状态，等待服务器确认；</p>
<p>第二次握手：服务器收到 <code>syn</code>包，必须确认客户的 <code>SYN</code>（<code>ack=x+1</code>），同时自己也发送一个 <code>SYN</code> 包（<code>seq=y</code> ），即 <code>SYN+ACK</code> 包，此时服务器进入 <code>SYN_RECV</code>（接收）状态；</p>
<p>第三次握手：客户端收到服务器的 <code>SYN＋ACK</code> 包，向服务器发送确认包 <code>ACK</code> ( <code>ack=y+1</code> )，此包发送完毕，客户端和服务器进入 <code>ESTABLISHED</code>（已建立）状态，完成三次握手。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/3.png" alt="img"></p>
<p><strong>说明：</strong><br>1）<code>SYN</code> 和 <code>ACK</code> 是标志位（0/1）（<code>ACK=1</code>表明 <code>ack</code> 有效），<code>seq</code> 是序列号，<code>ack</code> 是确认号。</p>
<p>2）给对方的确认方式就是把对方传来的 <code>seq+1</code> 并赋给 <code>ack</code>。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>第一次挥手：主动关闭方发送一个 <code>FIN</code>，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在 <code>fin</code> 包之前发送出去的数据，如果没有收到对应的 <code>ack</code> 确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p>
<p>第二次挥手：被动关闭方收到 <code>FIN</code> 包后，发送一个 <code>ACK</code> 给对方，确认序号为收到序号 +1。</p>
<p>第三次挥手：被动关闭方发送一个 <code>FIN</code>，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
<p>第四次挥手：主动关闭方收到 <code>FIN</code> 后，发送一个 <code>ACK</code> 给被动关闭方，确认序号为收到序号 +1，至此，完成四次挥手。</p>
<p><strong>说明：</strong></p>
<p>1）<strong>SYN攻击：用众多伪造ip地址向服务器发送SYN=1（请求连接）</strong>，让服务器处于<strong>SYN-RCVD状态</strong>，但都无法第三次握手（因为伪造 <code>ip</code> 不存在）</p>
<p>2）4次挥手中的 <code>FIN</code> 就相当于三次握手中的 <code>SYN</code>。</p>
<p>3）序号 <code>seq</code>，确认序号 <code>ack</code>，确认标志位 <code>ACK</code> 作用还是一样的，就是确认作用（把 <code>seq</code> 加上1赋给 <code>ack</code>，并把 <code>ACK</code> 置1）</p>
<p>4）为什么一个3次1个4次不一样？</p>
<p>因为两端的数据并不是同时发送完，所以两端谁发送完数据都需要自己告诉对方一次，并且对方确认一次。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/4.png" alt="img"></p>
<h2 id="6-在浏览器中输入www-baidu-com后执行的全部过程"><a href="#6-在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="6.在浏览器中输入www.baidu.com后执行的全部过程"></a>6.在浏览器中输入<a href="http://www.baidu.com后执行的全部过程" target="_blank" rel="noopener">www.baidu.com后执行的全部过程</a></h2><p>1、客户端浏览器通过 <code>DNS</code> 解析到<a href="http://www.baidu.com的" target="_blank" rel="noopener">www.baidu.com的</a> <code>IP</code> 地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个 <code>HTTP</code> 会话到 220.161.27.48，然后通过 <code>TCP</code> 进行封装数据包，输入到网络层。</p>
<p> 2、在客户端的<strong>传输层(添加TCP头)</strong>，把 <code>HTTP</code> 会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的 5000 端口。然后使用IP层的IP地址查找目的端。</p>
<p> 3、客户端的<strong>网络层（添加IP头）</strong>不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
<p> 4、客户端的<strong>链路层（添加MAC头）</strong>包通过链路层发送到路由器，通过邻居协议查找给定 <code>IP</code> 地址的 <code>MAC</code> 地址，然后发送 <code>ARP</code> 请求查找目的地址，如果得到回应后就可以使用 <code>ARP</code> 的请求应答交换的 <code>IP</code> 数据包现在就可以传输了，然后发送 <code>IP</code> 数据包到达服务器的地址。</p>
<h2 id="7-TCP和UDP的区别"><a href="#7-TCP和UDP的区别" class="headerlink" title="7.TCP和UDP的区别"></a>7.TCP和UDP的区别</h2><p><strong>这是传输层的两个协议，先说一下传输层的两大功能：</strong></p>
<ol>
<li><strong>复用：</strong>在发送端，多个应用进程公用一个传输层；</li>
<li><strong>分用：</strong>在接收端，传输层会根据端口号将数据分给不同的应用进程。 </li>
</ol>
<p><strong>传输层和网络层的区别：</strong></p>
<ol>
<li>网络层为不同的<strong>主机</strong>提供通信服务，传输层为不同应用<strong>进程</strong>提供通信服务。</li>
<li>网络层只对报文头部进行差错检测，而传输层对整个报文进行差错检测。</li>
</ol>
<p><strong>UDP（User Data Protocol）用户数据报协议</strong></p>
<ol>
<li>无连接</li>
<li>不可靠（不能保证都送达）</li>
<li>面向报文（<code>UDP</code> 数据传输单位是报文，不会对数据进行拆分和拼接操作，只是给上层传来的数据加个 <code>UDP</code> 头或者给下层来的数据去掉 <code>UDP</code> 头）</li>
<li>没有拥塞控制，始终以恒定速率发送数据</li>
<li>支持一对一、一对多、多对多、多对一</li>
<li>首部开销小，只有8字节</li>
</ol>
<p><strong>TCP（Transmission Control Protocol）传输控制协议</strong></p>
<ol>
<li>有连接</li>
<li>可靠的</li>
<li>面向字节流</li>
<li>全双工通信，<code>TCP</code> 两端既可以作为发送端也可以作为接收端</li>
<li>连接的两端只能是两个端点，即一对一，不能一对多</li>
<li>至少20个字节，比 <code>UDP</code> 大的多</li>
</ol>
<p><strong>什么是TCP连接</strong></p>
<p><code>TCP</code> 连接是一种抽象的概念，表示一条可以通信的链路。<br>每个 <code>TCP</code> 连接有且仅有两个端点，表示通信的双方，且双方在任意时刻都可以作为发送者和接受者。</p>
<p><strong>什么是套接字</strong></p>
<p>一条 <code>TCP</code> 连接的两端就是两个套接字。<br>套接字 = <code>IP</code> 地址:端口号<br>因此，<code>TCP</code> 连接 = （套接字1，套接字2）= （<code>IP1</code>：端口号1，<code>IP2</code>：端口号2）</p>
<h2 id="8-TCP对应的协议和UDP对应的协议"><a href="#8-TCP对应的协议和UDP对应的协议" class="headerlink" title="8.TCP对应的协议和UDP对应的协议"></a>8.TCP对应的协议和UDP对应的协议</h2><p><strong>TCP对应的协议：</strong></p>
<p>（1） <strong>FTP</strong>：定义了文件传输协议，使用<strong>21</strong>端口。</p>
<p>（2） <strong>Telnet</strong>：一种用于远程登陆的端口，使用<strong>23</strong>端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。</p>
<p>（3） <strong>SMTP</strong>：邮件传送协议，用于发送邮件。服务器开放的是<strong>25</strong>号端口。</p>
<p>（4） <strong>POP3</strong>：它是和 <code>SMTP</code> 对应，<code>POP3</code> 用于接收邮件。<code>POP3</code> 协议所用的是<strong>110</strong>端口。</p>
<p>（5）<strong>HTTP</strong>：是从 <code>Web</code> 服务器传输超文本到本地浏览器的传送协议。</p>
<p><strong>UDP对应的协议：</strong></p>
<p>（1） <strong>DNS</strong>：用于域名解析服务，将域名地址转换为IP地址。DNS用的是<strong>53</strong>号端口。</p>
<p>（2） <strong>SNMP</strong>：简单网络管理协议，使用<strong>161</strong>号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>
<p>（3） <strong>TFTP</strong>(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口<strong>69</strong>上使用UDP服务。</p>
<h2 id="9-DNS域名系统，简单描述其工作原理。"><a href="#9-DNS域名系统，简单描述其工作原理。" class="headerlink" title="9.DNS域名系统，简单描述其工作原理。"></a>9.DNS域名系统，简单描述其工作原理。</h2><p>　　当 <code>DNS</code> 客户机需要在程序中使用名称时，它会查询 <code>DNS</code> 服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的 <code>DNS</code> 域名，指定的查询类型，<code>DNS</code> 域名的指定类别。基于 <code>UDP</code> 服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如 <code>HTTP</code>，<code>SMTP</code>等在其中需要完成主机名到IP地址的转换。</p>
<h2 id="10-面向连接和非面向连接的服务的特点是什么？"><a href="#10-面向连接和非面向连接的服务的特点是什么？" class="headerlink" title="10.面向连接和非面向连接的服务的特点是什么？"></a>10.面向连接和非面向连接的服务的特点是什么？</h2><ul>
<li><p>面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。</p>
</li>
<li><p>非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。</p>
</li>
</ul>
<h2 id="11-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"><a href="#11-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？" class="headerlink" title="11.TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"></a>11.TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</h2><p>答：建立连接的过程是利用客户服务器模式，假设主机 <code>A</code> 为客户端，主机 <code>B</code> 为服务器端。</p>
<p>（1）<code>TCP</code> 的三次握手过程：主机 <code>A</code> 向 <code>B</code> 发送连接请求；主机 <code>B</code> 对收到的主机 <code>A</code> 的报文段进行确认；主机 <code>A</code> 再次对主机 <code>B</code> 的确认进行确认。</p>
<p>（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机 <code>B</code>，因而产生错误。失效的连接请求报文段是指：<strong>主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。</strong>考虑这样一种特殊情况，主机 <code>A</code> 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 <code>B</code>，<strong>主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会</strong>，主机 <code>B</code> 就一直在等待主机 <code>A</code> 发送数据，导致主机 <code>B</code> 的资源浪费。（这就是缺少第三次握手( <code>A</code> 再给 <code>B</code> 确认））</p>
<p>（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。</p>
<h2 id="12-了解交换机、路由器、网关的概念，并知道各自的用途"><a href="#12-了解交换机、路由器、网关的概念，并知道各自的用途" class="headerlink" title="12.了解交换机、路由器、网关的概念，并知道各自的用途"></a>12.了解交换机、路由器、网关的概念，并知道各自的用途</h2><p><strong>1）交换机</strong></p>
<p>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，当控制电路收到数据包以后，<strong>处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上</strong>，通过内部 交换矩阵迅速将数据包传送到目的端口。目的 <code>MAC</code> 若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。</p>
<p><strong>交换机工作于OSI参考模型的第二层，即数据链路层</strong>。交换机内部的 <code>CPU</code> 会在每个端口成功连接时，通过 <code>ARP</code> 协议学习它的 <code>MAC</code> 地址，保存成一张 <code>ARP</code>表。在今后的通讯中，发往该 <code>MAC</code> 地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。</p>
<p>交换机被广泛应用于二层网络交换，俗称“二层交换机”。</p>
<p>交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在 <code>OSI</code> 七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。</p>
<p><strong>2）路由器</strong></p>
<p><strong>路由器</strong>（<strong>Router</strong>）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（ <code>host</code> 到 <code>host</code> 之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转送。路由工作在<strong>OSI模型的第三层——即网络层</strong>，例如网际协议。</p>
<p><strong>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。</strong> 路由器与交换器的差别，路由器是属于 <code>OSI</code> 第三层的产品，交换器是 <code>OSI</code> 第二层的产品(这里特指二层交换机)。</p>
<p><strong>3）网关</strong></p>
<p><strong>网关</strong>（<code>Gateway</code>），<strong>网关</strong>顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关<code>TCP/IP</code> 的文献曾经把网络层使用的路由器（<code>Router</code>）称为网关，<strong>在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP</strong>），经常在家庭中或者小型企业网络中使用，用于连接局域网和 <code>Internet</code>。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。</p>
<blockquote>
<p>文章来源于网络</p>
<p>原文链接：<a href="https://www.cnblogs.com/xdyixia/p/9275246.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdyixia/p/9275246.html</a></p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
