<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git仓库上传了个无法点开的空文件夹是什么鬼？</title>
    <url>/2020/02/09/git%E4%BB%93%E5%BA%93%E4%B8%8A%E4%BC%A0%E4%BA%86%E4%B8%AA%E6%97%A0%E6%B3%95%E7%82%B9%E5%BC%80%E7%9A%84%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 

<p>诡异之事年年有，只是今年有点多，在仓库上传到 GitHub 后，偶然在 GitHub 中瞄了一眼，我的天？这个图标不像文件夹啊？这个怎么点不开？git 上传正常啊？本地工作区和暂存区都是干净的了啊？</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>本地仓库提交后，<code>GitHub</code> 中某文件夹无法正常点击，内容无法显示。</p>
<h2 id="二、原因分析"><a href="#二、原因分析" class="headerlink" title="二、原因分析"></a>二、原因分析</h2><p>经排查，定位到原因：之前仓库中包含了一个特殊的文件夹（此文件夹是另外一个 <code>git</code> 仓库），在执行下面语句时：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>提示仓库中包含其他仓库，需要解决此问题。本人操作是删除掉此文件夹中的 <code>.git</code> 配置目录，然后依次执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m 'add the new file'</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>顺利推送仓库到远程，过程中并无报错。这个过程或许是导致问题的原因。</p>
<h2 id="三、解决办法"><a href="#三、解决办法" class="headerlink" title="三、解决办法"></a>三、解决办法</h2><p>现在问题是本地工作区与暂存区干净如新，远程仓库有问题。该如何解决？这时用到了一个命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;dir_name&gt;</span><br></pre></td></tr></table></figure>

<p>我们先来看一下手册：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usage: git rm [&lt;options&gt;] [--] &lt;file&gt;...</span><br><span class="line"></span><br><span class="line">    -n, --dry-run         dry run</span><br><span class="line">    -q, --quiet           do not list removed files</span><br><span class="line">    --cached              only remove from the index</span><br><span class="line">    -f, --force           override the up-to-date check</span><br><span class="line">    -r                    allow recursive removal</span><br><span class="line">    --ignore-unmatch      exit with a zero status even if nothing matched</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>--cached</code> 的作用：将文件仅仅从索引中移除，翻译成人能看懂的话便是 「之前已经提交，现在将此目录释放掉，恢复到工作区，未被追踪的状态，即 <code>git add .</code> 命令之前的状态」</p>
<p>我们执行完此命令之后使用如下命令查看所有改变后的文件状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>发现出问题的目录已经变成了红色未被追踪的状态，此时将出问题的目录中所有包含 <code>git</code> 信息的文件和目录都删除，然后再依次执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m 'add the new file'</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>去远程仓库中查看后发现问题解决。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>当出现未知问题致使远程仓库同预期结果不一致时，本地可以将问题目录恢复到未被追踪状态，核查完问题之后再次提交最新结果，操作步骤如下：</p>
<p>1.删除缓存，释放目录，恢复到未被追踪状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;dir_name&gt;</span><br></pre></td></tr></table></figure>

<p>2.依次执行如下操作再次提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m 'Information you need to submit'</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>3.完美解决问题。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch中join类型数据如何进行父子文档查询</title>
    <url>/2020/02/07/elasticsearch%E4%B8%ADjoin%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%88%B6%E5%AD%90%E6%96%87%E6%A1%A3%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 

<p>ES 中 join 类型数据如何根据父文档查询全部子文档？又如何根据子文档查询其父文档呢？</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-join-简介"><a href="#1-join-简介" class="headerlink" title="1.join 简介"></a>1.join 简介</h2><p>在 <code>ES</code> 中有一种特殊的数据类型『<code>join</code>』，被形象地称为父子文档。它是一种可以在同一索引中存放两种有关系数据的数据类型，类似于关系数据库中让两张表发生关系的<strong>外键 <code>FOREIGN KEY</code></strong> 。</p>
<p>在官方文档中这样介绍：<code>join</code> 数据类型的字段是一个特殊字段，它可以在同一个索引的文档中创建 <code>父子关系</code> 。通过参数 <code>relations</code> 定义可能存在关系的一组文档，这个关系的参数由 <code>父名</code> 和 <code>子名</code> 构成。下方是原文档描述：</p>
<p>The <code>join</code> datatype is a special field that creates parent/child relation within documents of the same index. The <code>relations</code> section defines a set of possible relations within the documents, each relation being a parent name and a child name. </p>
<h2 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义"></a>2.定义</h2><p>我们需要在设置 <code>mapping</code> 时将其关系定义好，如下示例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT 索引名称</span><br><span class="line">&#123;</span><br><span class="line">  "mappings": &#123;</span><br><span class="line">    "properties": &#123;</span><br><span class="line">      "join类型的字段名称": &#123; </span><br><span class="line">        "type": "join",</span><br><span class="line">        "relations": &#123;</span><br><span class="line">          "父文档标示字段名": "子文档标示字段名" </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-1-父文档"><a href="#2-1-父文档" class="headerlink" title="2.1 父文档"></a>2.1 父文档</h3><p>构建父文档时可以通过如下方法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT 索引名称/类型/文档id?refresh</span><br><span class="line">&#123;</span><br><span class="line">  "text": "EthanYan",</span><br><span class="line">  ...		// 父文档中其他的字段与值</span><br><span class="line">  "join类型的字段名称": &#123;</span><br><span class="line">    "name": "父文档标示字段名" </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式是为了便于理解，与下方子文档中构建方式对应。当你运用熟练后，有一种简便的构建方法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT 索引名称/类型/文档id?refresh</span><br><span class="line">&#123;</span><br><span class="line">  "text": "EthanYan",</span><br><span class="line">  ...		// 父文档中其他的字段与值</span><br><span class="line">  "join类型的字段名称": "父文档标示字段名" </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-子文档"><a href="#2-2-子文档" class="headerlink" title="2.2 子文档"></a>2.2 子文档</h3><p>构建子文档时可以通过如下方法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT 索引名称/类型/文档id?routing=父文档id&amp;refresh </span><br><span class="line">&#123;</span><br><span class="line">  "text": "xiaoyan",</span><br><span class="line">  ...		// 子文档中其他的字段与值</span><br><span class="line">  "join类型的字段名称": &#123;</span><br><span class="line">    "name": "子文档标示字段名", </span><br><span class="line">    "parent": "父文档id" </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>构建子文档时与父文档有些许不同，以下几点需要特别注意：</p>
<p>1.<code>url</code> 中可以看到有一个参数 <code>routing</code> ，<strong>此参数必须设置</strong>，因为我们需要保证父文档与子文档在同一分片中。其原文描述为：The routing value is mandatory because parent and child documents must be indexed on the same shard.</p>
<p>2.我们可以看到子文档在 <code>join</code> 类型字段中除了参数 <code>name</code> 外，还多了一个参数 <code>parent</code> ，故名思义，此字段为了指明父文档的所在，其值填写为父文档的 <code>id</code></p>
<h2 id="3-查询"><a href="#3-查询" class="headerlink" title="3.查询"></a>3.查询</h2><p>此字段类型当然是为了查询而存在，要不然没有灵魂。下面举例进行说明。索引名为 <code>sales_org</code></p>
<p>有一个父文档为下方示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"node_name_cn"</span>: <span class="string">"川渝"</span>,</span><br><span class="line">  <span class="attr">"node_code"</span>: <span class="string">"LP.IIB.RW.CTU"</span>,</span><br><span class="line">  <span class="attr">"node_type"</span>: <span class="string">"办事处"</span>,</span><br><span class="line">  <span class="attr">"node_id_fqdn"</span>: <span class="string">"SI/LP/LP.IIB.RW/LP.IIB.RW.CTU"</span>,</span><br><span class="line">  <span class="attr">"node_name_fqdn"</span>: <span class="string">"SI/LP//川渝"</span>,</span><br><span class="line">  <span class="attr">"node_name_en"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"mgmt_territory"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"node_tree_level"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">"node_name_short"</span>: <span class="string">"LP.IIB.RW.CTU"</span>,</span><br><span class="line">  <span class="attr">"node_info"</span>: <span class="string">"node_parent"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个子文档示例如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;	</span><br><span class="line">  <span class="attr">"empl_id"</span>: <span class="string">"*******"</span>,</span><br><span class="line">  <span class="attr">"email_addr"</span>: <span class="string">"*****@fafa.com"</span>,</span><br><span class="line">  <span class="attr">"dept_id"</span>: <span class="string">"LP.IIB.RW.CTU"</span>,</span><br><span class="line">  <span class="attr">"name_cn"</span>: <span class="string">"Nie Cong"</span>,</span><br><span class="line">  <span class="attr">"node_info"</span>: &#123;</span><br><span class="line">    <span class="attr">"parent"</span>: <span class="string">"LP.IIB.RW.CTU"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"node_child"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>join</code> 类型字段名为 <code>node_info</code> ，父文档标示字段名为 <code>node_parent</code> ，子文档标示字段名为 <code>node_child</code> 。</p>
<h3 id="3-1-基于父文档查询全部子文档"><a href="#3-1-基于父文档查询全部子文档" class="headerlink" title="3.1 基于父文档查询全部子文档"></a>3.1 基于父文档查询全部子文档</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST sales_org/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "has_parent": &#123;</span><br><span class="line">      "parent_type": "node_parent",		// 填写父文档标示字段名</span><br><span class="line">      "query": &#123;		// 填写查询条件，注意填写的查询条件是查询父文档，该查询条件是为定位到要基于的父文档</span><br><span class="line">        "match": &#123;</span><br><span class="line">          "_id": "LP.IIB.RW.CTU"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-基于子文档查询其父文档"><a href="#3-2-基于子文档查询其父文档" class="headerlink" title="3.2 基于子文档查询其父文档"></a>3.2 基于子文档查询其父文档</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "has_child": &#123;</span><br><span class="line">      "type": "node_child",		// 填写子文档标示字段名</span><br><span class="line">      "query": &#123;		// 填写查询条件，注意填写的查询条件是查询子文档，该查询条件是为定位到要基于的子文档</span><br><span class="line">        "match": &#123;</span><br><span class="line">          "dept_id": "LP.IIB.RW.CTU"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点总结</title>
    <url>/2020/02/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>《计算机网络》第五版 谢希仁</strong> 知识点大汇总</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-OSI、TCP-IP、五层协议的体系结构以及各层协议"><a href="#1-OSI、TCP-IP、五层协议的体系结构以及各层协议" class="headerlink" title="1.OSI、TCP/IP、五层协议的体系结构以及各层协议"></a>1.OSI、TCP/IP、五层协议的体系结构以及各层协议</h2><p><img src="https://github.com/EthanYan6/pic/raw/master/1.png" alt="img"></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/2.png" alt="img"></p>
<p><strong>OSI分层（7层）</strong>：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p><strong>TCP/IP分层（4层）</strong>：网络接口层、网际层、运输层、应用层。</p>
<p><strong>五层协议（5层）</strong>：物理层、数据链路层、网络层、运输层、应用层。</p>
<p><strong><em>每一层的协议如下：</em></strong></p>
<p><strong>物理层：</strong><code>RJ45</code>、<code>CLOCK</code>、<code>IEEE802.3</code>   （中继器，集线器，网关）</p>
<p><strong>数据链路：</strong><code>PPP</code>、<code>FR</code>、<code>HDLC</code>、<code>VLAN</code>、<code>MAC</code>  （网桥，交换机）</p>
<p><strong>网络层：</strong><code>IP</code>、<code>ICMP</code>、<code>ARP</code>、<code>RARP</code>、<code>OSPF</code>、<code>IPX</code>、<code>RIP</code>、<code>IGRP</code> （路由器）</p>
<p><strong>传输层：</strong><code>TCP</code>、<code>UDP</code>、<code>SPX</code></p>
<p><strong>会话层：</strong><code>NFS</code>、<code>SQL</code>、<code>NETBIOS</code>、<code>RPC</code></p>
<p><strong>表示层：</strong><code>JPEG</code>、<code>MPEG</code>、<code>ASII</code></p>
<p><strong>应用层：</strong><code>FTP</code>、<code>DNS</code>、<code>Telnet</code>、<code>SMTP</code>、<code>HTTP</code>、<code>WWW</code>、<code>NFS</code></p>
<p><strong><em>每一层的作用如下：</em></strong></p>
<p><strong>物理层：</strong>通过媒介传输比特,确定机械及电气规范（比特 <code>Bit</code>）</p>
<p><strong>数据链路层</strong>：将比特组装成帧和点到点的传递（帧 <code>Frame</code>）</p>
<p><strong>网络层</strong>：负责数据包从源到宿的传递和网际互连（包 <code>PackeT</code>）</p>
<p><strong>传输层</strong>：提供端到端的可靠报文传递和错误恢复（段 <code>Segment</code>）</p>
<p><strong>会话层</strong>：建立、管理和终止会话（会话协议数据单元 <code>SPDU</code>）</p>
<p><strong>表示层</strong>：对数据进行翻译、加密和压缩（表示协议数据单元 <code>PPDU</code>）</p>
<p><strong>应用层</strong>：允许访问 <code>OSI</code> 环境的手段（应用协议数据单元 <code>APDU</code>）</p>
<h2 id="2-IP地址分类"><a href="#2-IP地址分类" class="headerlink" title="2.IP地址分类"></a>2.IP地址分类</h2><p>　　<code>IP</code> 地址是32位的二进制数值，用于在 <code>TCP/IP</code> 通讯协议中标记每台计算机的地址。通常我们使用点式十进制来表示，如192.168.0.5等等。</p>
<p>　　每个 <code>IP</code> 地址又可分为两部分。即网络号部分和主机号部分：网络号表示其所属的网络段编号，主机号则表示该网段中该主机的地址编号。按照网络规模的大小，<code>IP</code> 地址可以分为 <code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>、<code>E</code> 五类。</p>
<p>A类地址：以0开头，第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）；</p>
<p>B类地址：以10开头，第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；</p>
<p>C类地址：以110开头，第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类别         网络号                  /占位数      主机号             /    占位数    用途</span><br><span class="line"></span><br><span class="line">A（以0开头）  1～126                 /  8      0～255 0～255 1～254 /     24      国家级</span><br><span class="line"></span><br><span class="line">B（以10开头） 128～191 0～255        /  16     0～255 1～254        /     16      跨过组织</span><br><span class="line"></span><br><span class="line">C（以110开头）192～223 0～255 0～255 /  24     1～254               /     8       企业组织</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>1）以下是留用的内部私有地址，<code>Internet</code> 上没使用的地址</p>
<p><code>A</code> 类 10.0.0.0–10.255.255.255</p>
<p><code>B</code> 类 172.16.0.0–172.31.255.255</p>
<p><code>C</code> 类 192.168.0.0–192.168.255.255</p>
<p>2）<code>IP</code> 地址与子网掩码相与得到网络号</p>
<p>3）主机号，全为0的是网络号（例如：192.168.2.0），主机号全为1的为广播地址（192.168.2.255）</p>
<h2 id="3-ARP是地址解析协议，简单语言解释一下工作原理"><a href="#3-ARP是地址解析协议，简单语言解释一下工作原理" class="headerlink" title="3.ARP是地址解析协议，简单语言解释一下工作原理"></a>3.ARP是地址解析协议，简单语言解释一下工作原理</h2><p>地址解析协议，即 <code>ARP</code>（<code>Address Resolution Protocol</code>），是根据 <code>IP</code> 地址获取物理地址的一个 <code>TCP/IP</code> 协议。</p>
<p>1.首先，每个主机都会在自己的 <code>ARP</code> 缓冲区中建立一个 <code>ARP</code> 列表，以表示 <code>IP</code> 地址和 <code>MAC</code> 地址之间的对应关系。</p>
<p>2.当源主机要发送数据时，首先检查ARP列表中是否有对应 <code>IP</code> 地址的目的主机的 <code>MAC</code> 地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送 <code>ARP</code> 数据包，该数据包包括的内容有：源主机<code>IP</code>地址，源主机 <code>MAC</code> 地址，目的主机的 <code>IP</code> 地址</p>
<p>3.当本网络的所有主机收到该 <code>ARP</code> 数据包时，首先检查数据包中的 <code>IP</code> 地址是否是自己的 <code>IP</code> 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 <code>IP</code> 和 <code>MAC</code> 地址写入到 <code>ARP</code> 列表中，如果已经存在，则覆盖，然后将自己的 <code>MAC</code> 地址写入 <code>ARP</code> 响应包中，告诉源主机自己是它想要找的 <code>MAC</code> 地址。</p>
<p>4.源主机收到 <code>ARP</code> 响应包后。将目的主机的 <code>IP</code> 和 <code>MAC</code> 地址写入 <code>ARP</code> 列表，并利用此信息发送数据。如果源主机一直没有收到 <code>ARP</code> 响应数据包，表示 <code>ARP</code> 查询失败。</p>
<p><strong>注意：广播（255.255.255.255）发送 <code>ARP</code> 请求，单播发送 <code>ARP</code> 响应。</strong></p>
<h2 id="4-简单介绍几种协议"><a href="#4-简单介绍几种协议" class="headerlink" title="4.简单介绍几种协议"></a>4.简单介绍几种协议</h2><p><code>ICMP</code> 协议： 因特网控制报文协议。它是 <code>TCP/IP</code> 协议族的一个子协议，用于在 <code>IP</code> 主机、路由器之间传递控制消息</p>
<p><code>TFTP</code> 协议： 是 <code>TCP/IP</code> 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</p>
<p><code>HTTP</code> 协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统</p>
<p><code>NAT</code> 协议：网络地址转换属接入广域网( <code>WAN</code> )技术，是一种将私有（保留）地址转化为合法 <code>IP</code> 地址的转换技术</p>
<p><code>DHCP</code> 协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段，使用 <code>UDP</code> 协议工作。<strong>具体用途</strong>：给内部网络或网络服务供应商自动分配 <code>IP</code> 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<h2 id="5-TCP三次握手四次挥手"><a href="#5-TCP三次握手四次挥手" class="headerlink" title="5.TCP三次握手四次挥手"></a>5.TCP三次握手四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次握手：客户端发送 <code>syn</code> 包( <code>seq=x</code> )到服务器，并进入 <code>SYN_SEND</code> (发送)状态，等待服务器确认；</p>
<p>第二次握手：服务器收到 <code>syn</code>包，必须确认客户的 <code>SYN</code>（<code>ack=x+1</code>），同时自己也发送一个 <code>SYN</code> 包（<code>seq=y</code> ），即 <code>SYN+ACK</code> 包，此时服务器进入 <code>SYN_RECV</code>（接收）状态；</p>
<p>第三次握手：客户端收到服务器的 <code>SYN＋ACK</code> 包，向服务器发送确认包 <code>ACK</code> ( <code>ack=y+1</code> )，此包发送完毕，客户端和服务器进入 <code>ESTABLISHED</code>（已建立）状态，完成三次握手。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/3.png" alt="img"></p>
<p><strong>说明：</strong><br>1）<code>SYN</code> 和 <code>ACK</code> 是标志位（0/1）（<code>ACK=1</code>表明 <code>ack</code> 有效），<code>seq</code> 是序列号，<code>ack</code> 是确认号。</p>
<p>2）给对方的确认方式就是把对方传来的 <code>seq+1</code> 并赋给 <code>ack</code>。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>第一次挥手：主动关闭方发送一个 <code>FIN</code>，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在 <code>fin</code> 包之前发送出去的数据，如果没有收到对应的 <code>ack</code> 确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p>
<p>第二次挥手：被动关闭方收到 <code>FIN</code> 包后，发送一个 <code>ACK</code> 给对方，确认序号为收到序号 +1。</p>
<p>第三次挥手：被动关闭方发送一个 <code>FIN</code>，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
<p>第四次挥手：主动关闭方收到 <code>FIN</code> 后，发送一个 <code>ACK</code> 给被动关闭方，确认序号为收到序号 +1，至此，完成四次挥手。</p>
<p><strong>说明：</strong></p>
<p>1）<strong>SYN攻击：用众多伪造ip地址向服务器发送SYN=1（请求连接）</strong>，让服务器处于<strong>SYN-RCVD状态</strong>，但都无法第三次握手（因为伪造 <code>ip</code> 不存在）</p>
<p>2）4次挥手中的 <code>FIN</code> 就相当于三次握手中的 <code>SYN</code>。</p>
<p>3）序号 <code>seq</code>，确认序号 <code>ack</code>，确认标志位 <code>ACK</code> 作用还是一样的，就是确认作用（把 <code>seq</code> 加上1赋给 <code>ack</code>，并把 <code>ACK</code> 置1）</p>
<p>4）为什么一个3次1个4次不一样？</p>
<p>因为两端的数据并不是同时发送完，所以两端谁发送完数据都需要自己告诉对方一次，并且对方确认一次。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/4.png" alt="img"></p>
<h2 id="6-在浏览器中输入www-baidu-com后执行的全部过程"><a href="#6-在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="6.在浏览器中输入www.baidu.com后执行的全部过程"></a>6.在浏览器中输入<a href="http://www.baidu.com后执行的全部过程" target="_blank" rel="noopener">www.baidu.com后执行的全部过程</a></h2><p>1、客户端浏览器通过 <code>DNS</code> 解析到<a href="http://www.baidu.com的" target="_blank" rel="noopener">www.baidu.com的</a> <code>IP</code> 地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个 <code>HTTP</code> 会话到 220.161.27.48，然后通过 <code>TCP</code> 进行封装数据包，输入到网络层。</p>
<p> 2、在客户端的<strong>传输层(添加TCP头)</strong>，把 <code>HTTP</code> 会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的 5000 端口。然后使用IP层的IP地址查找目的端。</p>
<p> 3、客户端的<strong>网络层（添加IP头）</strong>不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
<p> 4、客户端的<strong>链路层（添加MAC头）</strong>包通过链路层发送到路由器，通过邻居协议查找给定 <code>IP</code> 地址的 <code>MAC</code> 地址，然后发送 <code>ARP</code> 请求查找目的地址，如果得到回应后就可以使用 <code>ARP</code> 的请求应答交换的 <code>IP</code> 数据包现在就可以传输了，然后发送 <code>IP</code> 数据包到达服务器的地址。</p>
<h2 id="7-TCP和UDP的区别"><a href="#7-TCP和UDP的区别" class="headerlink" title="7.TCP和UDP的区别"></a>7.TCP和UDP的区别</h2><p><strong>这是传输层的两个协议，先说一下传输层的两大功能：</strong></p>
<ol>
<li><strong>复用：</strong>在发送端，多个应用进程公用一个传输层；</li>
<li><strong>分用：</strong>在接收端，传输层会根据端口号将数据分给不同的应用进程。 </li>
</ol>
<p><strong>传输层和网络层的区别：</strong></p>
<ol>
<li>网络层为不同的<strong>主机</strong>提供通信服务，传输层为不同应用<strong>进程</strong>提供通信服务。</li>
<li>网络层只对报文头部进行差错检测，而传输层对整个报文进行差错检测。</li>
</ol>
<p><strong>UDP（User Data Protocol）用户数据报协议</strong></p>
<ol>
<li>无连接</li>
<li>不可靠（不能保证都送达）</li>
<li>面向报文（<code>UDP</code> 数据传输单位是报文，不会对数据进行拆分和拼接操作，只是给上层传来的数据加个 <code>UDP</code> 头或者给下层来的数据去掉 <code>UDP</code> 头）</li>
<li>没有拥塞控制，始终以恒定速率发送数据</li>
<li>支持一对一、一对多、多对多、多对一</li>
<li>首部开销小，只有8字节</li>
</ol>
<p><strong>TCP（Transmission Control Protocol）传输控制协议</strong></p>
<ol>
<li>有连接</li>
<li>可靠的</li>
<li>面向字节流</li>
<li>全双工通信，<code>TCP</code> 两端既可以作为发送端也可以作为接收端</li>
<li>连接的两端只能是两个端点，即一对一，不能一对多</li>
<li>至少20个字节，比 <code>UDP</code> 大的多</li>
</ol>
<p><strong>什么是TCP连接</strong></p>
<p><code>TCP</code> 连接是一种抽象的概念，表示一条可以通信的链路。<br>每个 <code>TCP</code> 连接有且仅有两个端点，表示通信的双方，且双方在任意时刻都可以作为发送者和接受者。</p>
<p><strong>什么是套接字</strong></p>
<p>一条 <code>TCP</code> 连接的两端就是两个套接字。<br>套接字 = <code>IP</code> 地址:端口号<br>因此，<code>TCP</code> 连接 = （套接字1，套接字2）= （<code>IP1</code>：端口号1，<code>IP2</code>：端口号2）</p>
<h2 id="8-TCP对应的协议和UDP对应的协议"><a href="#8-TCP对应的协议和UDP对应的协议" class="headerlink" title="8.TCP对应的协议和UDP对应的协议"></a>8.TCP对应的协议和UDP对应的协议</h2><p><strong>TCP对应的协议：</strong></p>
<p>（1） <strong>FTP</strong>：定义了文件传输协议，使用<strong>21</strong>端口。</p>
<p>（2） <strong>Telnet</strong>：一种用于远程登陆的端口，使用<strong>23</strong>端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。</p>
<p>（3） <strong>SMTP</strong>：邮件传送协议，用于发送邮件。服务器开放的是<strong>25</strong>号端口。</p>
<p>（4） <strong>POP3</strong>：它是和 <code>SMTP</code> 对应，<code>POP3</code> 用于接收邮件。<code>POP3</code> 协议所用的是<strong>110</strong>端口。</p>
<p>（5）<strong>HTTP</strong>：是从 <code>Web</code> 服务器传输超文本到本地浏览器的传送协议。</p>
<p><strong>UDP对应的协议：</strong></p>
<p>（1） <strong>DNS</strong>：用于域名解析服务，将域名地址转换为IP地址。DNS用的是<strong>53</strong>号端口。</p>
<p>（2） <strong>SNMP</strong>：简单网络管理协议，使用<strong>161</strong>号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>
<p>（3） <strong>TFTP</strong>(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口<strong>69</strong>上使用UDP服务。</p>
<h2 id="9-DNS域名系统，简单描述其工作原理。"><a href="#9-DNS域名系统，简单描述其工作原理。" class="headerlink" title="9.DNS域名系统，简单描述其工作原理。"></a>9.DNS域名系统，简单描述其工作原理。</h2><p>　　当 <code>DNS</code> 客户机需要在程序中使用名称时，它会查询 <code>DNS</code> 服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的 <code>DNS</code> 域名，指定的查询类型，<code>DNS</code> 域名的指定类别。基于 <code>UDP</code> 服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如 <code>HTTP</code>，<code>SMTP</code>等在其中需要完成主机名到IP地址的转换。</p>
<h2 id="10-面向连接和非面向连接的服务的特点是什么？"><a href="#10-面向连接和非面向连接的服务的特点是什么？" class="headerlink" title="10.面向连接和非面向连接的服务的特点是什么？"></a>10.面向连接和非面向连接的服务的特点是什么？</h2><ul>
<li><p>面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。</p>
</li>
<li><p>非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。</p>
</li>
</ul>
<h2 id="11-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"><a href="#11-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？" class="headerlink" title="11.TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"></a>11.TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</h2><p>答：建立连接的过程是利用客户服务器模式，假设主机 <code>A</code> 为客户端，主机 <code>B</code> 为服务器端。</p>
<p>（1）<code>TCP</code> 的三次握手过程：主机 <code>A</code> 向 <code>B</code> 发送连接请求；主机 <code>B</code> 对收到的主机 <code>A</code> 的报文段进行确认；主机 <code>A</code> 再次对主机 <code>B</code> 的确认进行确认。</p>
<p>（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机 <code>B</code>，因而产生错误。失效的连接请求报文段是指：<strong>主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。</strong>考虑这样一种特殊情况，主机 <code>A</code> 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 <code>B</code>，<strong>主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会</strong>，主机 <code>B</code> 就一直在等待主机 <code>A</code> 发送数据，导致主机 <code>B</code> 的资源浪费。（这就是缺少第三次握手( <code>A</code> 再给 <code>B</code> 确认））</p>
<p>（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。</p>
<h2 id="12-了解交换机、路由器、网关的概念，并知道各自的用途"><a href="#12-了解交换机、路由器、网关的概念，并知道各自的用途" class="headerlink" title="12.了解交换机、路由器、网关的概念，并知道各自的用途"></a>12.了解交换机、路由器、网关的概念，并知道各自的用途</h2><p><strong>1）交换机</strong></p>
<p>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，当控制电路收到数据包以后，<strong>处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上</strong>，通过内部 交换矩阵迅速将数据包传送到目的端口。目的 <code>MAC</code> 若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。</p>
<p><strong>交换机工作于OSI参考模型的第二层，即数据链路层</strong>。交换机内部的 <code>CPU</code> 会在每个端口成功连接时，通过 <code>ARP</code> 协议学习它的 <code>MAC</code> 地址，保存成一张 <code>ARP</code>表。在今后的通讯中，发往该 <code>MAC</code> 地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。</p>
<p>交换机被广泛应用于二层网络交换，俗称“二层交换机”。</p>
<p>交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在 <code>OSI</code> 七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。</p>
<p><strong>2）路由器</strong></p>
<p><strong>路由器</strong>（<strong>Router</strong>）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（ <code>host</code> 到 <code>host</code> 之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转送。路由工作在<strong>OSI模型的第三层——即网络层</strong>，例如网际协议。</p>
<p><strong>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。</strong> 路由器与交换器的差别，路由器是属于 <code>OSI</code> 第三层的产品，交换器是 <code>OSI</code> 第二层的产品(这里特指二层交换机)。</p>
<p><strong>3）网关</strong></p>
<p><strong>网关</strong>（<code>Gateway</code>），<strong>网关</strong>顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关<code>TCP/IP</code> 的文献曾经把网络层使用的路由器（<code>Router</code>）称为网关，<strong>在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP</strong>），经常在家庭中或者小型企业网络中使用，用于连接局域网和 <code>Internet</code>。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。</p>
<blockquote>
<p>文章来源于网络</p>
<p>原文链接：<a href="https://www.cnblogs.com/xdyixia/p/9275246.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdyixia/p/9275246.html</a></p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch的一些小知识点</title>
    <url>/2020/01/31/elasticsearch%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>这个假期有多少人新添了一份职业「云监工」，又有多少人干起了小区保安的工作（统计着进出小区的车辆），还有一些人无聊到数火龙果的「黑芝麻」…… 实不相瞒，我也一样，只不过无聊之际，偶尔看看书。之前对于 elasticsearch 介绍过一些常用的 API ，今天再做一些额外的补充。</p>
<blockquote>
<p>「云监工」：网络流行词，来源于央视频直播武汉开建的防治传染病医院火神山医院的建设工地，网友们虽然不能到现场出把力，但也给自己加了一个身份：云监工，通过直播镜头去“监督”医院的建设进度。</p>
<p>小区保安工作：很多人在家无聊，自觉统计着出入小区人员车辆数量，以帮助监督是否有人在疫情期间四处乱逛。</p>
<p>数火龙果的籽：这个起源于网友晒出的图片，为一个火龙果所有的籽标上了序号。</p>
</blockquote>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-短语搜索"><a href="#1-短语搜索" class="headerlink" title="1.短语搜索"></a>1.短语搜索</h2><p>之前向大家介绍了模糊搜索 <code>match</code> ，现在又有了很多复杂的需求：确切的匹配若干个单词（同一字段的值中包含多个词）或者短语。这就用到了一个新的方法 <code>match_phrase</code>，官方示例如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match_phrase"</span> : &#123;</span><br><span class="line">            <span class="attr">"about"</span> : <span class="string">"rock climbing"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述语句查询 <code>about</code> 字段中同时包含 <code>rock</code> 和 <code>climbing</code>（并且是相邻的）的员工记录。<code>match_phrase</code> 方法也可以用于匹配<strong>短语(phrases)</strong></p>
<p>有一些新来的小伙伴，可能对于上面的表达不是十分清楚，下面详细介绍一下。<code>GET</code> 表示请求方式，<code>/megacorp/employee/_search</code> 表示访问路径 <code>PATH</code>，大括号中的内容即 <code>DSL</code> 语句。</p>
<h3 id="1-1-API-访问方式"><a href="#1-1-API-访问方式" class="headerlink" title="1.1 API 访问方式"></a>1.1 API 访问方式</h3><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p>与 <code>elasticsearch</code> 进行交互时，可以通过 <code>crul</code> 方式，与其他普通的 <code>HTTP</code> 请求相同：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X&lt;VERB&gt; '&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;' -d '&lt;BODY&gt;'</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>VERB</strong> 表示请求方式：<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>HEAD</code>, <code>DELETE</code></p>
<p><strong>PROTOCOL</strong> 表示访问协议，如 <code>HTTP</code> / <code>HTTPS</code> （只有在 <code>Elasticsearch</code> 前面有 <code>https</code> 代理的时候可用）</p>
<p><strong>HOST</strong> 表示 <code>Elasticsearch</code> 集群中的任何一个节点的主机名，如果是在本地的节点，那么就叫 <code>localhost</code></p>
<p><strong>PORT</strong> 表示 <code>Elasticsearch HTTP</code> 服务所在的端口，默认为 9200</p>
<p><strong>PATH</strong> 表示 <code>API</code> 路径，也就是示例中的 <code>/megacorp/employee/_search</code></p>
<p><strong>QUERY_STRING</strong> 表示一些可选的查询请求参数，例如 <code>?pretty</code> 参数使得返回 <code>JSON</code> 数据更加美观易读。</p>
<p><strong>BODY</strong> 一个 <code>JSON</code> 格式的请求主体（如果请求需要的话）</p>
</blockquote>
<h4 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h4><p>大家经常使用到的工具，通过输入请求 <code>url</code> 以及根据需要填写 <code>DSL</code> 语句做为请求体，进行访问。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>任何其他发送 <code>HTTP</code> 请求的方式</p>
<h2 id="2-搜索结果高亮"><a href="#2-搜索结果高亮" class="headerlink" title="2.搜索结果高亮"></a>2.搜索结果高亮</h2><p>故名思义，我们可以将搜索到的文档中匹配到的关键词进行高亮显示。它最大的作用就是醒目，让你一眼发现这个文档被匹配的原因。语句也很简单，只需要在之前的查询语句上增加 <code>highlight</code>参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"match_phrase"</span> : &#123;</span><br><span class="line">            <span class="string">"about"</span> : <span class="string">"rock climbing"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"highlight"</span>: &#123;</span><br><span class="line">        <span class="string">"fields"</span> : &#123;</span><br><span class="line">            <span class="string">"about"</span> : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们运行这个语句时，会命中与之前相同的结果，但是在返回结果中会有一个新的部分叫做 <code>highlight</code>，这里包含了来自<code>about</code>字段中的文本，并且用 <code>&lt;em&gt;&lt;/em&gt;</code>来标识匹配到的单词。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="string">"hits"</span>: &#123;</span><br><span class="line">      <span class="string">"total"</span>:      <span class="number">1</span>,</span><br><span class="line">      <span class="string">"max_score"</span>:  <span class="number">0.23013961</span>,</span><br><span class="line">      <span class="string">"hits"</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="string">"_score"</span>:         <span class="number">0.23013961</span>,</span><br><span class="line">            <span class="string">"_source"</span>: &#123;</span><br><span class="line">               <span class="string">"first_name"</span>:  <span class="string">"John"</span>,</span><br><span class="line">               <span class="string">"last_name"</span>:   <span class="string">"Smith"</span>,</span><br><span class="line">               <span class="string">"age"</span>:         <span class="number">25</span>,</span><br><span class="line">               <span class="string">"about"</span>:       <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">               <span class="string">"interests"</span>: [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"highlight"</span>: &#123;</span><br><span class="line">               <span class="string">"about"</span>: [</span><br><span class="line">                  <span class="string">"I love to go &lt;em&gt;rock&lt;/em&gt; &lt;em&gt;climbing&lt;/em&gt;"</span> &lt;<span class="number">1</span>&gt;</span><br><span class="line">               ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&lt;1&gt; 原有文本中高亮的片段</p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>还在拧螺丝？是时候学习造航母了！</title>
    <url>/2020/01/30/%E8%BF%98%E5%9C%A8%E6%8B%A7%E8%9E%BA%E4%B8%9D%EF%BC%9F%E6%98%AF%E6%97%B6%E5%80%99%E5%AD%A6%E4%B9%A0%E9%80%A0%E8%88%AA%E6%AF%8D%E4%BA%86%EF%BC%81/</url>
    <content><![CDATA[<center>Author：闫玉良</center>
面试造航母，实际拧螺丝。这是大部分互联网人面对的实际情境，如何跳出舒适的圈子，撤离局部，俯览大局？

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>限制自己的不是外界，而是内心。你之所以没听过这句话，是因为它出自小闫同学（鹅鹅鹅～笑出了鹅叫声）为了避免三年螺丝工，还是提升一下自己，为造航母做准备吧。一些架构知识，既可以培养全局观，又可以助你深层次认识『螺丝』。</p>
<h2 id="一、架构演变"><a href="#一、架构演变" class="headerlink" title="一、架构演变"></a>一、架构演变</h2><p>一般来说，任何一个项目至少有三层内容来组成：<strong>web访问层、数据库层、存储层</strong></p>
<h3 id="1-1-初级阶段"><a href="#1-1-初级阶段" class="headerlink" title="1.1 初级阶段"></a>1.1 初级阶段</h3><p>在初级阶段又会人为细分为如下几个阶段：</p>
<h4 id="1-1-1-单体阶段"><a href="#1-1-1-单体阶段" class="headerlink" title="1.1.1 单体阶段"></a>1.1.1 单体阶段</h4><p><strong>常见场景：</strong>项目初期 </p>
<p><strong>部署特点：</strong>所有应用服务都在一台主机 </p>
<p><strong>应用特点：</strong>开发简单</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%841.png" alt="单体阶段"></p>
<h4 id="1-1-2-应用-数据分离阶段"><a href="#1-1-2-应用-数据分离阶段" class="headerlink" title="1.1.2 应用/数据分离阶段"></a>1.1.2 应用/数据分离阶段</h4><p><strong>常见场景：</strong>项目初期，用户访问数据库有压力 </p>
<p><strong>部署特点：</strong>应用和数据库单独部署 </p>
<p><strong>应用特点：</strong>开发简单</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%842.png" alt="应用/数据分离阶段"></p>
<h4 id="1-1-3-页面动静分离阶段"><a href="#1-1-3-页面动静分离阶段" class="headerlink" title="1.1.3 页面动静分离阶段"></a>1.1.3 页面动静分离阶段</h4><p><strong>常见场景：</strong>项目初期，用户访问页面有压力</p>
<p><strong>部署特点：</strong>剥离用户读请求和写请求操作</p>
<p><strong>应用特点：</strong>开发简单</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%843.png" alt="页面动静分离阶段"></p>
<h4 id="1-1-4-页面-数据缓存阶段"><a href="#1-1-4-页面-数据缓存阶段" class="headerlink" title="1.1.4 页面/数据缓存阶段"></a>1.1.4 页面/数据缓存阶段</h4><p><strong>常见场景：</strong>项目初期，用户访问有压力 </p>
<p><strong>部署特点：</strong>代理和数据库前面增加缓存组件 </p>
<p><strong>应用特点：</strong>开发简单</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%844.png" alt="页面/数据缓存阶段"></p>
<h3 id="1-2-中期阶段"><a href="#1-2-中期阶段" class="headerlink" title="1.2 中期阶段"></a>1.2 中期阶段</h3><h4 id="1-2-1-应用服务集群阶段"><a href="#1-2-1-应用服务集群阶段" class="headerlink" title="1.2.1 应用服务集群阶段"></a>1.2.1 应用服务集群阶段</h4><p><strong>常见场景：</strong>项目初期，用户访问有压力</p>
<p><strong>部署特点：</strong>应用服务所在主机做集群负载均衡 </p>
<p><strong>应用特点：</strong>业务中等</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%845.png" alt="应用服务集群阶段"></p>
<h4 id="1-2-2-数据库读写分离化"><a href="#1-2-2-数据库读写分离化" class="headerlink" title="1.2.2 数据库读写分离化"></a>1.2.2 数据库读写分离化</h4><p><strong>常见场景：</strong>项目初期，用户访问数据有压力</p>
<p><strong>部署特点：</strong>对数据库集群做读写分离，静态文件做共享存储</p>
<p><strong>应用特点：</strong>业务中等</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%846.png" alt="数据库读写分离化"></p>
<h4 id="1-2-3-存储分布式"><a href="#1-2-3-存储分布式" class="headerlink" title="1.2.3 存储分布式"></a>1.2.3 存储分布式</h4><p><strong>常见场景：</strong>项目中期，数据存储有压力</p>
<p><strong>部署特点：</strong>对数据库分库/分表扩展，数据文件使用分布式存储</p>
<p><strong>应用特点：</strong>业务中等</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%847.png" alt="存储分布式"></p>
<h4 id="1-2-4-业务应用拆分"><a href="#1-2-4-业务应用拆分" class="headerlink" title="1.2.4 业务应用拆分"></a>1.2.4 业务应用拆分</h4><p><strong>常见场景：</strong>项目中期，业务访问/团队管理有压力</p>
<p><strong>部署特点：</strong>项目应用进行拆分</p>
<p><strong>应用特点：</strong>业务复杂</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%848.png" alt="业务应用拆分"></p>
<h3 id="1-3-中后期阶段"><a href="#1-3-中后期阶段" class="headerlink" title="1.3 中后期阶段"></a>1.3 中后期阶段</h3><h4 id="1-3-1-业务拆分"><a href="#1-3-1-业务拆分" class="headerlink" title="1.3.1 业务拆分"></a>1.3.1 业务拆分</h4><p><strong>常见场景：</strong>项目中后期，业务处理有压力</p>
<p><strong>部署特点：</strong>所有功能以服务形式单独部署，引入配置管理管理中心、消息中间件，搜索引擎等功能</p>
<p><strong>应用特点：</strong>业务复杂</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%849.png" alt="业务拆分"></p>
<h3 id="1-4-后期阶段"><a href="#1-4-后期阶段" class="headerlink" title="1.4 后期阶段"></a>1.4 后期阶段</h3><h4 id="1-4-1-微服务阶段"><a href="#1-4-1-微服务阶段" class="headerlink" title="1.4.1 微服务阶段"></a>1.4.1 微服务阶段</h4><p><strong>常见场景：</strong>项目后期，精益求精</p>
<p><strong>部署特点：</strong>所有业务都可以自由部署</p>
<p><strong>应用特点：</strong>业务复杂</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%8410.png" alt="微服务阶段"></p>
<h2 id="二、架构部署"><a href="#二、架构部署" class="headerlink" title="二、架构部署"></a>二、架构部署</h2><h3 id="2-1通用架构"><a href="#2-1通用架构" class="headerlink" title="2.1通用架构"></a>2.1通用架构</h3><p><strong>一级定位：</strong>核心组成部分 （web 、数据库、存储层 ）</p>
<p><strong>二级定位：</strong>功能增强部分 （web缓存、代理、数据库缓存）</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9E%B6%E6%9E%8411.png" alt="通用架构"></p>
<h3 id="2-2部署项目"><a href="#2-2部署项目" class="headerlink" title="2.2部署项目"></a>2.2部署项目</h3><p>部署项目的时候，要遵循主次原则：</p>
<p>1.对于架构层中的一级角色，我们的<strong>部署原则</strong>是：站在用户访问资源角度，从后向前依次部署。 </p>
<p>2.对于架构层中的二级角色，我们的<strong>部署原则</strong>是：站在用户访问资源压力角度，需要部署哪里，就部署哪里，注意前后的信息交流。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>docker的一些小知识</title>
    <url>/2020/01/29/docker%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<center>Author：闫玉良</center>

<p>今天玩游戏的时候，突然想到了以前面试被问的一个小问题，特此记录，仅供参考</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-关于docker故障排除"><a href="#1-关于docker故障排除" class="headerlink" title="1.关于docker故障排除"></a>1.关于docker故障排除</h2><p>很久之前在 <code>XX航空</code> 的面试中，面试官曾问过一个问题，大体情况如下（具体描述因为时间关系已经记不清了）：</p>
<p><strong>面试官：当一个容器发生故障导致无法连接</strong>，你会如何操作？</p>
<h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><p><strong>傻小闫：</strong>重启 <code>docker服务</code> 或 <code>容器</code> ？？？</p>
<p><strong>面试官：</strong>说一下重启命令</p>
<p><strong>傻小闫：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启 docker</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启某容器</span></span><br><span class="line">docker restart 容器id或者容器name</span><br></pre></td></tr></table></figure>

<p><strong>面试官：</strong>如果 <code>docker</code> 命令不是通过 <code>systemctl</code> 管理的，怎么办？如果执行重启命令之后仍然无法重启呢？</p>
<p><strong>傻小闫：</strong>无论 <code>docker</code> 怎样进行安装，都会有相关重启命令吧？要是重启一次不管用，那就多重启两次！常言道：没有什么是重启解决不了的问题，如果有，就重启两次～</p>
<p><strong>面试官：</strong>傻小闫，<code>out</code>！</p>
<h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><p><strong>傻小闫：</strong>我会先查看 <code>docker</code> 的 <code>启停状态</code>，然后再排查该容器的相关信息，比如查看该容器的启停状态，查看该容器的 <code>日志</code> 以及 <code>进程</code> 相关信息，最后根据具体情况进行具体分析作出对应相关操作。</p>
<p><strong>面试官：</strong>那么写一下查看 <code>docker</code> 的 <code>启停状态</code> 相关命令，还有查看容器的 <code>日志</code> 以及 <code>进程</code> 的相关命令吧。</p>
<p><strong>傻小闫：</strong>好的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<p>上述命令会显示服务的运行状态以及一些简单的运行信息。接下来是查看所有容器的启停状态命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p>然后是查看容器在 <code>stdout/stderr</code> 的日志相关命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs 容器id或者容器名称</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定容器最后100行日志</span></span><br><span class="line">docker logs --tail=100 容器id或者容器名称</span><br></pre></td></tr></table></figure>

<p>如果容器运行正常，可以查看指定容器中运行的进程信息，进一步判断原因：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker top 容器id或者容器名称</span><br></pre></td></tr></table></figure>

<p>另外还有一个查看容器性能监控的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stats 容器id或者容器名称</span><br></pre></td></tr></table></figure>

<p>对了，最后再说一个查看容器配置信息和运行时状态的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id或者容器名称</span><br></pre></td></tr></table></figure>

<p><strong>面试官微微点头，进行下一轮的问题轰炸…</strong></p>
<h2 id="2-关于docker网络"><a href="#2-关于docker网络" class="headerlink" title="2.关于docker网络"></a>2.关于docker网络</h2><p>docker 中容器如何与外界进行通讯？当然是配置网络了，下面是最常用的一行命令，指定映射：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p [宿主机ip]:[宿主机端口]:[容器端口] --name [容器名字] [镜像名称]</span><br></pre></td></tr></table></figure>

<p>该命令会根据指定镜像创建一个容器，并指定容器的名称、宿主机映射到容器的地址和端口、容器对外绑定的端口。创建完成之后，宿主机就可以通过刚才宿主机指定的地址和端口访问容器指定的服务了（比如容器是一个 <code>nginx</code> ，我们将宿主机的 <code>192.168.0.33:1314</code> 映射到容器的 80 端口，宿主机访问 <code>192.168.0.33:1314</code> 即可访问 <code>nginx</code> 服务）。</p>
<blockquote>
<p>端口的范围：0 ～ 65535</p>
</blockquote>
<h3 id="2-1-网桥"><a href="#2-1-网桥" class="headerlink" title="2.1 网桥"></a>2.1 网桥</h3><p>宿主机与 <code>docker</code> 某容器之间可以进行通讯之后，那么容器之间该如何通讯呢？</p>
<p>1.仍然可以通过上面提到的方式，使用宿主机的地址和端口进行访问。但是这样做有一个弊端，那就是只能访问容器暴露出的端口所提供的服务，十分有限。（<strong>推荐指数：2颗星</strong>）</p>
<p>2.可以使用容器的 <code>ip</code> 进行访问，但是每次重启容器之后，地址的变化该如何是好？（<strong>推荐指数：1颗星</strong>）</p>
<p>3.通过 <code>link</code> 建立连接。首先这种方式官方不推荐，所以也没有选择的必要，大家简单了解即可。我们需要有一个容器A（其他容器想要访问该容器），有一个容器B（该容器要去访问容器A），容器B在创建（启动）时需要使用参数 <code>--link</code> 进行设置。然后进入容器B，直接通过参数 <code>link</code> 指定的名字去访问容器A即可。<strong>注意一点：不可反向操作！</strong>即容器A无法 <code>ping</code> 通容器B。（<strong>推荐指数：1颗星</strong>）</p>
<blockquote>
<p>而且此操作如果希望容器A重启后，容器B的链接仍然生效，还需要额外操作，修改配置文件，十分繁琐，不推荐。</p>
</blockquote>
<p>上述的手段都不推荐，那么直接引出今日主角登场『<strong>桥接网络</strong>』（<strong>推荐指数：5颗星</strong>）</p>
<p>首先需要创建一个网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create 网络名称</span><br></pre></td></tr></table></figure>

<p>然后在启动容器时，使其加入网络中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --network 创建的网络名称 其他参数设置 镜像名称 ...</span><br></pre></td></tr></table></figure>

<p>我们简单来看一下官方提供了其他的什么参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --help</span><br><span class="line">      ...</span><br><span class="line">      --network network                Connect a container to a network</span><br><span class="line">      --network-alias list             Add network-scoped alias for the container</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<p>可以看到有两个参数，按照官方描述，一个参数负责将容器链接到给定的网桥上，一个参数是为该容器添加一个网络访问的别名。</p>
<p><strong>将需要通讯的容器在创建（启动容器）时，通过参数设置都添加到同一网络桥接上即可完成容器之间的通讯。</strong></p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2020/01/27/%E5%9B%BE/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
此图非彼图，今天来学习一种十分重要，在生活中也经常使用的数据结构「图」

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="一、图"><a href="#一、图" class="headerlink" title="一、图"></a>一、图</h2><p>图就是由一些点与边组成，点之间是边，边两头有点，类似于我们所画的思维导图。根据点之间连接的边是否有具体指向区分为『有向图』和『无向图』。</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E6%9C%89%E5%90%91%E5%9B%BE.png" alt="图"></p>
<p>图可以做什么呢？它可以解决最经典的问题『寻找最短路径』。类似于地图，如想知道从别墅到公司走哪条路最短，可以通过图来建立模型，将十字路口（三叉路口等连接几条路的路口）看作是点，每条路就是边，别墅是起点，公司是终点。</p>
<p>上面只完成了第一步，有了图之后，该如何寻找最短路径呢？下面就需要再介绍一种图算法『广度优先搜索』</p>
<h2 id="二、广度优先搜索算法"><a href="#二、广度优先搜索算法" class="headerlink" title="二、广度优先搜索算法"></a>二、广度优先搜索算法</h2><p><strong>广度优先搜索算法</strong>可以通过一个例子进行描述：小明想通过走动，帮助儿子进入县一中（当地最好的学校）。于是他开始回忆自己的朋友是否有县一中的领导或者认识其领导，思考之后发现并没有，然后让朋友询问朋友的朋友是否有关系。像这样，为了在社交网络中寻找到关系，先看自己（自己肯定不是，要不然直接安排了），然后将所有朋友加入到搜索名单中，看朋友中是否有关系，如果没有，再将朋友的朋友纳入范围继续寻找 …… 直到找到需要的人，这就是广度优先搜索算法。</p>
<blockquote>
<p>因为同朋友的亲密度比同朋友的朋友之间的亲密度要高，所以先从朋友之间寻找。如果将朋友比做是第一层关系，朋友的朋友为第二层，这样一层一层下去的就是广度优先搜索。如果找到一个朋友，就寻找他的朋友中是否有这样的人，如此以深度挖掘的方式搜索下去，就是深度优先搜索。</p>
</blockquote>
<p>它常用于寻找两地点或者两样物体之间的最短距离。总结为下面两种问题：</p>
<ul>
<li>从一点可以到另一点吗？</li>
<li>从一点到另一点哪条路径最短？</li>
</ul>
<p>现实生活中的例子有：</p>
<ul>
<li>各种智能机器，比如跳棋最少走几步可以获胜</li>
<li>到目的地的最短路线</li>
</ul>
<p>在搜索的过程中，大家可能注意到，先检查朋友，后检查朋友的朋友，是有顺序的，那么如何保持顺序呢？那就需要使用到另外一种数据结构『队列』</p>
<h2 id="三、队列"><a href="#三、队列" class="headerlink" title="三、队列"></a>三、队列</h2><p>队列很简单，和生活中的排队一样，比如购票，结账时，先排队的人先买到票或者结账完成。就是有顺序，先进先出（<code>First In First Out</code>）的一种数据结构，它只有两种行为，入队和出队。类比生活中排队，有素质的人不能出现插队吧？</p>
<blockquote>
<p>队列常常与栈进行对比，栈是一种先进后出的数据结构，或描述为后进先出（<code>Last In First Out</code>）</p>
<p>深度优先搜索就常使用栈。</p>
</blockquote>
<h2 id="四、实现图"><a href="#四、实现图" class="headerlink" title="四、实现图"></a>四、实现图</h2><p>代码如何实现图呢？首先图由多个节点构成，每个节点与邻近节点相连，要表示这种关系，可以联想到『散列表』，其映射关系可以将键映射到一个值或多个值。在 <code>Python</code> 中则使用字典表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">"小明"</span>] = [<span class="string">"小花"</span>, <span class="string">"小玉"</span>, ...]</span><br><span class="line">graph[<span class="string">"小玉"</span>] = [<span class="string">"小帆"</span>, ...]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>散列表是无序的</p>
</blockquote>
<h2 id="五、实现图算法"><a href="#五、实现图算法" class="headerlink" title="五、实现图算法"></a>五、实现图算法</h2><p>还是沿用小明为儿子学校找关系的示例，实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该字典表示图，其中将小明与朋友，小明朋友与朋友的朋友之间的关系</span></span><br><span class="line">graph = &#123;......&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person_is_seller</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># 具体判断过程省略，该函数返回 true 或 false，即是或者不是</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个队列</span></span><br><span class="line">    search_queue = deque() </span><br><span class="line">    <span class="comment"># 为队列中不断添加朋友或者朋友的朋友，即要搜索的人</span></span><br><span class="line">    search_queue += graph[name] </span><br><span class="line">    <span class="comment"># 这个列表用于记录检查过的人</span></span><br><span class="line">    searched = []</span><br><span class="line">    <span class="comment"># 只要队列不为空就一直搜索下去</span></span><br><span class="line">    <span class="keyword">while</span> search_queue:</span><br><span class="line">        <span class="comment"># 取出队列中左面第一个人</span></span><br><span class="line">        person = search_queue.popleft() </span><br><span class="line">        <span class="comment"># 仅当这个人没检查过时才检查</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> person <span class="keyword">in</span> searched:</span><br><span class="line">            <span class="comment"># 看这个人是否是小明需要找的关系</span></span><br><span class="line">            <span class="keyword">if</span> person_is_seller(person):</span><br><span class="line">              	<span class="comment"># 是的话输出是要找的关系</span></span><br><span class="line">                print(person + <span class="string">" is the one you are looking for!"</span>)</span><br><span class="line">                <span class="comment"># 结束循环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              	<span class="comment"># 把这个人的朋友添加到队列中</span></span><br><span class="line">              	search_queue += graph[person] </span><br><span class="line">                <span class="comment"># 将这个人标记为检查过</span></span><br><span class="line">                searched.append(person)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">search(<span class="string">"小明"</span>)</span><br></pre></td></tr></table></figure>



<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习工程师必知的十大算法</title>
    <url>/2020/01/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E7%9F%A5%E7%9A%84%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>It is no doubt that the sub-field of machine learning / artificial intelligence has increasingly gained more popularity in the past couple of years. As Big Data is the hottest trend in the tech industry at the moment, machine learning is incredibly powerful to make predictions or calculated suggestions based on large amounts of data. Some of the most common examples of machine learning are Netflix’s algorithms to make movie suggestions based on movies you have watched in the past or Amazon’s algorithms that recommend books based on books you have bought before.</p>
<p>毫无疑问，机器学习 / 人工智能的子领域在过去几年越来越受欢迎。目前大数据在科技行业已经炙手可热，而基于大量数据来进行预测或者得出建议的机器学习无疑是非常强大的。一些最常见的机器学习例子，比如 Netflix 的算法可以根据你以前看过的电影来进行电影推荐，而 Amazon 的算法则可以根据你以前买过的书来推荐书籍。</p>
<p>So if you want to learn more about machine learning, how do you start?</p>
<p>所以如果你想了解更多有关机器学习的内容，那么你该如何入门？</p>
<a id="more"></a>

<blockquote>
<p>本文由 James Le 所写的英文文章 The 10 Algorithms Machine Learning Engineers Need to Know 翻译而来</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
</blockquote>
<p>For me, my first introduction is when I took an Artificial Intelligence class when I was studying abroad in Copenhagen. My lecturer is a full-time Applied Math and CS professor at the Technical University of Denmark, in which his research areas are logic and artificial, focusing primarily on the use of logic to model human-like planning, reasoning and problem solving. The class was a mix of discussion of theory/core concepts and hands-on problem solving. The textbook that we used is one of the AI classics: <a href="https://www.amazon.com/Artificial-Intelligence-Modern-Approach-3rd/dp/0136042597" target="_blank" rel="noopener">Peter Norvig’s <em>Artificial Intelligence — A Modern Approach</em></a>, in which we covered major topics including intelligent agents, problem-solving by searching, adversarial search, probability theory, multi-agent systems, social AI, philosophy/ethics/future of AI. At the end of the class, in a team of 3, we implemented simple search-based agents solving transportation tasks in a virtual environment as a programming project.</p>
<p>对于我来说，我的入门课程是我在哥本哈根出国留学时参加的人工智能课。当时我的讲师是丹麦技术大学（Technical University of Denmark）的应用数学和计算机科学的全职教授，他的研究方向是逻辑与人工智能，侧重于使用逻辑学来对人性化的规划、推理和解决问题进行建模。这个课程包括对理论 / 核心概念的讨论和自己动手解决问题。我们使用的教材是 AI 经典之一：Peter Norvig 的 Artificial Intelligence—A Modern Approach（中文译本：<a href="https://book.douban.com/subject/6730363/" target="_blank" rel="noopener">《人工智能：一种现代的方法》</a>），这本书主要讲了智能体、搜索解决问题、对抗搜索、概率论、多智能体系统、社会AI 和AI 的哲学/ 伦理/ 未来等等。在课程结束时，我们三个人的团队实现了一个简单的编程项目，也就是基于搜索的智能体解决虚拟环境中的运输任务问题。</p>
<p>I have learned a tremendous amount of knowledge thanks to that class, and decided to keep learning about this specialized topic. In the last few weeks, I have been multiple tech talks in San Francisco on deep learning, neural networks, data architecture — and a Machine Learning conference with a lot of well-known professionals in the field. Most importantly, I enrolled in Udacity’s <a href="https://www.udacity.com/course/intro-to-machine-learning--ud120" target="_blank" rel="noopener"><em>Intro to Machine Learning</em></a> online course in the beginning of June and has just finished it a few days ago. In this post, I want to share some of the most common machine learning algorithms that I learned from the course.</p>
<p>在那门课程上我已经学到了很多知识，并决定继续学习相关的课题。在过去的几个星期里，我在旧金山参加了多次相关的技术讲座，涉及到深度学习、神经网络和数据结构，并且参加了一个有很多该领域的知名专家学者参加的机器学习会议。最重要的是，我在 6 月初参加了 Udacity 上的<a href="https://cn.udacity.com/course/intro-to-machine-learning--ud120" target="_blank" rel="noopener"> Intro to Machine Learning（机器学习入门）</a>在线课程，前几天才完成。在这篇文章中，我想分享一下我从课程中学到的一些最常用的机器学习算法。</p>
<p>Machine learning algorithms can be divided into 3 broad categories — supervised learning, unsupervised learning, and reinforcement learning.Supervised learning is useful in cases where a property (<em>label</em>) is available for a certain dataset (<em>training set</em>), but is missing and needs to be predicted for other instances. Unsupervised learning is useful in cases where the challenge is to discover implicit relationships in a given <em>unlabeled</em> dataset (items are not pre-assigned). Reinforcement learning falls between these 2 extremes — there is some form of feedback available for each predictive step or action, but no precise label or error message. Since this is an intro class, I didn’t learn about reinforcement learning, but I hope that 10 algorithms on supervised and unsupervised learning will be enough to keep you interested.</p>
<p>机器学习算法可以分为三大类：监督学习、无监督学习和强化学习。监督学习可用于一个特定的数据集（训练集）具有某一属性（标签），但是其他数据没有标签或者需要预测标签的情况。无监督学习可用于给定的没有标签的数据集（数据不是预分配好的），目的就是要找出数据间的潜在关系。强化学习位于这两者之间，每次预测都有一定形式的反馈，但是没有精确的标签或者错误信息。因为这是一个介绍课程，我没有学习过强化学习的相关内容，但是我希望以下 10 个关于监督学习和无监督学习的算法足以让你感兴趣。</p>
<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><h3 id="1-决策树（Decision-Trees）"><a href="#1-决策树（Decision-Trees）" class="headerlink" title="1. 决策树（Decision Trees）"></a>1. 决策树（Decision Trees）</h3><p>A decision tree is a decision support tool that uses a tree-like graph or model of decisions and their possible consequences, including chance-event outcomes, resource costs, and utility. Take a look at the image to get a sense of how it looks like.</p>
<p>决策树是一个决策支持工具，它使用树形图或者决策模型以及可能性序列，包括偶然事件的结果、资源成本和效用。下图是其基本原理：</p>
<p><img src="https://static001.infoq.cn/resource/image/03/2f/03196b63116045238bd90168de7fa02f.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>From a business decision point of view, a decision tree is the minimum number of yes/no questions that one has to ask, to assess the probability of making a correct decision, most of the time. As a method, it allows you to approach the problem in a structured and systematic way to arrive at a logical conclusion.</p>
<p>从业务决策的角度来看，决策树是人们必须了解的最少的是 / 否问题，这样才能评估大多数时候做出正确决策的概率。作为一种方法，它允许你以结构化和系统化的方式来解决问题，从而得出合乎逻辑的结论。</p>
<h3 id="2-朴素贝叶斯分类-Naive-Bayesian-classification"><a href="#2-朴素贝叶斯分类-Naive-Bayesian-classification" class="headerlink" title="2. 朴素贝叶斯分类 (Naive Bayesian classification)"></a>2. 朴素贝叶斯分类 (Naive Bayesian classification)</h3><p>Naive Bayes classifiers are a family of simple probabilistic classifiers based on applying Bayes’ theorem with strong (naive) independence assumptions between the features. The featured image is the equation — with P(A|B) is posterior probability, P(B|A) is likelihood, P(A) is class prior probability, and P(B) is predictor prior probability.</p>
<p>朴素贝叶斯分类器是一类简单的概率分类器，它基于贝叶斯定理和特征间的强大的（朴素的）独立假设。图中是贝叶斯公式，其中 P（A|B）是后验概率，P（B|A）是似然，P（A）是类先验概率，P（B）是预测先验概率。</p>
<p><img src="https://static001.infoq.cn/resource/image/02/82/02afc9957795347a9529a71b0df68082.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>Some of real world examples are:</p>
<ul>
<li>To mark an email as spam or not spam</li>
<li>Classify a news article about technology, politics, or sports</li>
<li>Check a piece of text expressing positive emotions, or negative emotions?</li>
<li>Used for face recognition software.</li>
</ul>
<p>一些应用例子:</p>
<ul>
<li>判断垃圾邮件</li>
<li>对新闻的类别进行分类，比如科技、政治、运动</li>
<li>判断文本表达的感情是积极的还是消极的</li>
<li>人脸识别</li>
</ul>
<h3 id="3-最小二乘法（Ordinary-Least-Squares-Regression）"><a href="#3-最小二乘法（Ordinary-Least-Squares-Regression）" class="headerlink" title="3. 最小二乘法（Ordinary Least Squares Regression）"></a>3. 最小二乘法（Ordinary Least Squares Regression）</h3><p>If you know statistics, you probably have heard of linear regression before. Least squares is a method for performing linear regression. You can think of linear regression as the task of fitting a straight line through a set of points. There are multiple possible strategies to do this, and “ordinary least squares” strategy go like this — You can draw a line, and then for each of the data points, measure the vertical distance between the point and the line, and add these up; the fitted line would be the one where this sum of distances is as small as possible.</p>
<p>如果你懂统计学的话，你可能以前听说过线性回归。最小二乘法是一种计算线性回归的方法。你可以将线性回归看做通过一组点来拟合一条直线。实现这个有很多种方法，“最小二乘法”就像这样：你可以画一条直线，然后对于每一个数据点，计算每个点到直线的垂直距离，然后把它们加起来，那么最后得到的拟合直线就是距离和尽可能小的直线。</p>
<p><img src="https://static001.infoq.cn/resource/image/52/dc/528f69da2ec5c98287f968aa8c1d31dc.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>Linear refers the kind of model you are using to fit the data, while least squares refers to the kind of error metric you are minimizing over.</p>
<p>线性指的是你用来拟合数据的模型，而最小二乘法指的是你最小化的误差度量。</p>
<h3 id="4-逻辑回归-Logistic-Regression"><a href="#4-逻辑回归-Logistic-Regression" class="headerlink" title="4. 逻辑回归 (Logistic Regression)"></a>4. 逻辑回归 (Logistic Regression)</h3><p>Logistic regression is a powerful statistical way of modeling a binomial outcome with one or more explanatory variables. It measures the relationship between the categorical dependent variable and one or more independent variables by estimating probabilities using a logistic function, which is the cumulative logistic distribution.</p>
<p>逻辑回归是一个强大的统计学方法，它可以用一个或多个解释变量来表示一个二项式结果。它通过使用逻辑函数来估计概率，从而衡量类别依赖变量和一个或多个独立变量之间的关系，后者服从累计逻辑分布。</p>
<p><img src="https://static001.infoq.cn/resource/image/f5/6c/f559c1b4f5a61b579b0c9e906a439f6c.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>In general, regressions can be used in real-world applications such as:</p>
<ul>
<li>Credit Scoring</li>
<li>Measuring the success rates of marketing campaigns</li>
<li>Predicting the revenues of a certain product</li>
<li>Is there going to be an earthquake on a particular day?</li>
</ul>
<p>总的来说，逻辑回归可以用于以下几个真实应用场景：</p>
<ul>
<li>信用评分</li>
<li>计算营销活动的成功率</li>
<li>预测某个产品的收入</li>
<li>特定的某一天是否会发生地震</li>
</ul>
<h3 id="5-支持向量机（Support-Vector-Machine，SVM）"><a href="#5-支持向量机（Support-Vector-Machine，SVM）" class="headerlink" title="5. 支持向量机（Support Vector Machine，SVM）"></a>5. 支持向量机（Support Vector Machine，SVM）</h3><p>SVM is binary classification algorithm. Given a set of points of 2 types in N dimensional place, SVM generates a (N — 1) dimensional hyperplane to separate those points into 2 groups. Say you have some points of 2 types in a paper which are linearly separable. SVM will find a straight line which separates those points into 2 types and situated as far as possible from all those points.</p>
<p>SVM 是二进制分类算法。给定 N 维坐标下两种类型的点，SVM 生成（N-1）维的超平面来将这些点分成两组。假设你在平面上有两种类型的可以线性分离的点，SVM 将找到一条直线，将这些点分成两种类型，并且这条直线尽可能远离所有这些点。</p>
<p><img src="https://static001.infoq.cn/resource/image/b8/7d/b82961e4171788ac7433c4b4e219327d.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>In terms of scale, some of the biggest problems that have been solved using SVMs (with suitably modified implementations) are display advertising, human splice site recognition, image-based gender detection, large-scale image classification…</p>
<p>从规模上看，使用 SVM（经过适当的修改）解决的一些最大的问题包括显示广告、人类剪切位点识别（human splice site recognition）、基于图像的性别检测，大规模图像分类……</p>
<h3 id="6-集成方法（Ensemble-methods）"><a href="#6-集成方法（Ensemble-methods）" class="headerlink" title="6. 集成方法（Ensemble methods）"></a>6. 集成方法（Ensemble methods）</h3><p>Ensemble methods are learning algorithms that construct a set of classifiers and then classify new data points by taking a weighted vote of their predictions. The original ensemble method is Bayesian averaging, but more recent algorithms include error-correcting output coding, bagging, and boosting.</p>
<p>集成方法是学习算法，它通过构建一组分类器，然后通过它们的预测结果进行加权投票来对新的数据点进行分类。原始的集成方法是贝叶斯平均，但是最近的算法包括纠错输出编码、Bagging 和 Boosting。</p>
<p><img src="https://static001.infoq.cn/resource/image/3f/30/3f398562a900001e21e141085b286530.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>So how do ensemble methods work and why are they superior to individual models?</p>
<ul>
<li>They average out biases: If you average a bunch of democratic-leaning polls and republican-leaning polls together, you will get an average something that isn’t leaning either way.</li>
<li>They reduce the variance: The aggregate opinion of a bunch of models is less noisy than the single opinion of one of the models. In finance, this is called diversification — a mixed portfolio of many stocks will be much less variable than just one of the stocks alone. This is why your models will be better with more data points rather than fewer.</li>
<li>They are unlikely to over-fit: If you have individual models that didn’t over-fit, and you are combining the predictions from each model in a simple way (average, weighted average, logistic regression), then there’s no room for over-fitting.</li>
</ul>
<p>那么集成方法如何工作？并且为什么它们要优于单个模型？</p>
<ul>
<li>它们平均了单个模型的偏差：如果你将民主党的民意调查和共和党的民意调查在一起平均化，那么你将得到一个均衡的结果，不偏向任何一方。</li>
<li>它们减少了方差：一组模型的总体意见比其中任何一个模型的单一意见更加统一。在金融领域，这就是所谓的多元化，有许多股票的组合比一个单独的股票的不确定性更少，这也为什么你的模型在数据多的情况下会更好的原因。</li>
<li>它们不太可能过拟合：如果你有单个的模型没有过拟合，那么把这些模型的预测简单结合起来（平均、加权平均、逻辑回归），那么最后得到的模型也不会过拟合。</li>
</ul>
<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><h3 id="7-聚类算法（Clustering-Algorithms）"><a href="#7-聚类算法（Clustering-Algorithms）" class="headerlink" title="7. 聚类算法（Clustering Algorithms）"></a>7. 聚类算法（Clustering Algorithms）</h3><p>Clustering is the task of grouping a set of objects such that objects in the same group (<em>cluster</em>) are more similar to each other than to those in other groups.</p>
<p>聚类是将一系列对象分组的任务，目标是使相同组（集群）中的对象之间比其他组的对象更相似。</p>
<p><img src="https://static001.infoq.cn/resource/image/f9/0a/f9262a91a2fdb75ef398a082dc71c00a.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>Every clustering algorithm is different, and here are a couple of them:</p>
<ul>
<li>Centroid-based algorithms</li>
<li>Connectivity-based algorithms</li>
<li>Density-based algorithms</li>
<li>Probabilistic</li>
<li>Dimensionality Reduction</li>
<li>Neural networks / Deep Learning</li>
</ul>
<p>每一种聚类算法都不相同，下面是一些例子：</p>
<ul>
<li>基于质心的算法</li>
<li>基于连接的算法</li>
<li>基于密度的算法</li>
<li>概率</li>
<li>降维</li>
<li>神经网络 / 深度学习</li>
</ul>
<h3 id="8-主成分分析（Principal-Component-Analysis，PCA）"><a href="#8-主成分分析（Principal-Component-Analysis，PCA）" class="headerlink" title="8. 主成分分析（Principal Component Analysis，PCA）"></a>8. 主成分分析（Principal Component Analysis，PCA）</h3><p>PCA is a statistical procedure that uses an orthogonal transformation to convert a set of observations of possibly correlated variables into a set of values of linearly uncorrelated variables called principal components.</p>
<p>PCA 是一个统计学过程，它通过使用正交变换将一组可能存在相关性的变量的观测值转换为一组线性不相关的变量的值，转换后的变量就是所谓的主分量。</p>
<p><img src="https://static001.infoq.cn/resource/image/9e/92/9ec810f0a300d725e7226750e8d09e92.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>Some of the applications of PCA include compression, simplifying data for easier learning, visualization. Notice that domain knowledge is very important while choosing whether to go forward with PCA or not. It is not suitable in cases where data is noisy (all the components of PCA have quite a high variance).</p>
<p>PCA 的一些应用包括压缩、简化数据便于学习、可视化等。请注意，领域知识在选择是否继续使用 PCA 时非常重要。 数据嘈杂的情况（PCA 的所有成分具有很高的方差）并不适用。</p>
<h3 id="9-奇异值分解（Singular-Value-Decomposition，SVD）"><a href="#9-奇异值分解（Singular-Value-Decomposition，SVD）" class="headerlink" title="9. 奇异值分解（Singular Value Decomposition，SVD）"></a>9. 奇异值分解（Singular Value Decomposition，SVD）</h3><p>In linear algebra, SVD is a factorization of a real complex matrix. For a given <em>m \</em> n* matrix M, there exists a decomposition such that M = UΣV, where U and V are unitary matrices and Σ is a diagonal matrix.</p>
<p>在线性代数中，SVD 是复杂矩阵的因式分解。对于给定的 m * n 矩阵 M，存在分解使得 M=UΣV，其中 U 和 V 是酉矩阵，Σ是对角矩阵。</p>
<p><img src="https://static001.infoq.cn/resource/image/a2/f8/a254a50da32558e12f4c170a32ecdcf8.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>PCA is actually a simple application of SVD. In computer vision, the 1st face recognition algorithms used PCA and SVD in order to represent faces as a linear combination of “eigenfaces”, do dimensionality reduction, and then match faces to identities via simple methods; although modern methods are much more sophisticated, many still depend on similar techniques.</p>
<p>实际上，PCA 是 SVD 的一个简单应用。在计算机视觉中，第一个人脸识别算法使用 PCA 和 SVD 来将面部表示为“特征面”的线性组合，进行降维，然后通过简单的方法将面部匹配到身份，虽然现代方法更复杂，但很多方面仍然依赖于类似的技术。</p>
<h3 id="10-独立成分分析（Independent-Component-Analysis，ICA）"><a href="#10-独立成分分析（Independent-Component-Analysis，ICA）" class="headerlink" title="10. 独立成分分析（Independent Component Analysis，ICA）"></a>10. 独立成分分析（Independent Component Analysis，ICA）</h3><p>ICA is a statistical technique for revealing hidden factors that underlie sets of random variables, measurements, or signals. ICA defines a generative model for the observed multivariate data, which is typically given as a large database of samples. In the model, the data variables are assumed to be linear mixtures of some unknown latent variables, and the mixing system is also unknown. The latent variables are assumed non-gaussian and mutually independent, and they are called independent components of the observed data.</p>
<p>ICA 是一种统计技术，主要用于揭示随机变量、测量值或信号集中的隐藏因素。ICA 对观测到的多变量数据定义了一个生成模型，这通常是作为样本的一个大的数据库。在模型中，假设数据变量由一些未知的潜在变量线性混合，混合方式也是未知的。潜在变量被假定为非高斯分布并且相互独立，它们被称为观测数据的独立分量。</p>
<p><img src="https://static001.infoq.cn/resource/image/00/a1/007e627062309d6f80e25e1f935d11a1.jpg" alt="机器学习工程师必知的十大算法"></p>
<p>ICA is related to PCA, but it is a much more powerful technique that is capable of finding the underlying factors of sources when these classic methods fail completely. Its applications include digital images, document databases, economic indicators and psychometric measurements.</p>
<p>ICA 与 PCA 有关，但是当这些经典方法完全失效时，它是一种更强大的技术，能够找出源的潜在因素。 其应用包括数字图像、文档数据库、经济指标和心理测量。</p>
<p>Now go forth and wield your understanding of algorithms to create machine learning applications that make better experiences for people everywhere.</p>
<p>现在运用你对这些算法的理解去创造机器学习应用，为世界各地的人们带来更好的体验吧。</p>
<blockquote>
<p>本文译者：尚剑</p>
<p>本文编辑：闫玉良</p>
<p>中文地址：<a href="https://www.infoq.cn/article/10-algorithms-machine-learning-engineers-need-to-know/" target="_blank" rel="noopener">https://www.infoq.cn/article/10-algorithms-machine-learning-engineers-need-to-know/</a></p>
<p><strong>查看英文原文：<a href="http://www.kdnuggets.com/2016/08/10-algorithms-machine-learning-engineers.html/2" target="_blank" rel="noopener"> The 10 Algorithms Machine Learning Engineers Need to Know</a></strong></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>如果你是mac用户，这个问题不信你没遇到！</title>
    <url>/2020/01/07/%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%98%AFmac%E7%94%A8%E6%88%B7%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E4%B8%8D%E4%BF%A1%E4%BD%A0%E6%B2%A1%E9%81%87%E5%88%B0%EF%BC%81/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 

<p>Mac 用户在使用 python 的虚拟环境时，你现在或者将来一定会遇到此问题，早发现早治疗 ～</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>在虚拟环境中执行 <code>python</code> 等相关命令时，报如下所示错误：</p>
<img src="https://github.com/EthanYan6/pic/raw/master/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%8A%A5%E9%94%99-2.png" alt="报错2" style="zoom:50%;">

<p>使用 <code>pip</code> 命令报错依旧：</p>
<img src="https://github.com/EthanYan6/pic/raw/master/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%8A%A5%E9%94%99-1.png" alt="报错1" style="zoom:50%;">

<p>是不是很诡异？</p>
<h3 id="2-原因分析"><a href="#2-原因分析" class="headerlink" title="2.原因分析"></a>2.原因分析</h3><p>出现上述问题，在查询过 <code>Google</code> 和 <code>stackoverflow</code> 等之后，发现了共性：都是使用 <code>MAC</code> 的用户，而且使用了  <code>brew</code> 包管理工具。</p>
<p>在执行 <code>brew update</code> 命令之后会升级所有管理的模块，比如 <code>Python</code> 。因此遇到 <code>Python</code> 有版本更新时，嘻嘻，恭喜你中奖了。</p>
<p><code>Mac</code> 在创建虚拟环境后，会发现文件夹下有一些链接文件，各种软链接其实指向了系统的 <code>Python</code> （节省空间所致），所以当你更新了 <code>Python</code> 之后，它所在的路径中包含的版本号也会更新，路径立即失效（软链接其实就保存的就是绝对路径），你的虚拟环境也就无法正常启动了。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h3 id="3-解决办法"><a href="#3-解决办法" class="headerlink" title="3.解决办法"></a>3.解决办法</h3><p>网上有一些解决办法，如下：</p>
<p>1.既然知道原因，那么重新修复这些软链接不就好了？于是，开始了 <code>删除创建</code> 之旅。</p>
<blockquote>
<p>我滴个乖乖！你知道哪个犄角旮旯里还藏着一个不怀好意的软链接嘛？然后网友提供了各种命令：</p>
<p><code>find ~/.virtualenvs/my-virtual-env/ -type l</code> 别闹了好吗？几十个文件，我怎么弄？放弃放弃，如果你愿意，那么请查看这篇帖子仔细研究即可：<a href="https://stackoverflow.com/questions/23233252/broken-references-in-virtualenvs" target="_blank" rel="noopener">https://stackoverflow.com/questions/23233252/broken-references-in-virtualenvs</a></p>
</blockquote>
<p>2.重新装系统</p>
<blockquote>
<p>这个。。。不至于吧，杀鸡焉用宰牛刀？既然知道问题，解决就好了嘛</p>
</blockquote>
<p>3.删除虚拟环境</p>
<blockquote>
<p>这个听起来不错，这也正是我想讲的方法。前提是你有 <code>requirements.txt</code> 文件，要不然还是麻烦点使用办法 1 吧。</p>
</blockquote>
<h3 id="4-实操"><a href="#4-实操" class="headerlink" title="4.实操"></a>4.实操</h3><p>删除重建虚拟环境即可，但如果这么简单，还用往下讲解吗？笑话！以后再出现，难不成还在删除吗？且听我的骚操作。</p>
<p>删除虚拟环境后，再创建时，请使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtualenv --no-site-packages --always-copy 虚拟环境名称 -p python3</span><br></pre></td></tr></table></figure>

<p>1.<code>--no-site-packages</code> ：创建虚拟环境时，不会安装系统环境中的任何模块（也就是创建一个全新的环境）</p>
<p>2.<code>-p python3</code> 指定创建的虚拟环境为 <code>python3.x</code> 版本</p>
<p>3.<code>--always-copy</code> 可以跟踪系统 <code>python</code> 信息，即使你升级了系统的 <code>python</code> ，虚拟环境仍然可以使用。</p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>python</tag>
        <tag>virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS这些情况你也遇到过</title>
    <url>/2019/12/22/CentOS%E8%BF%99%E4%BA%9B%E6%83%85%E5%86%B5%E4%BD%A0%E4%B9%9F%E9%81%87%E5%88%B0%E8%BF%87/</url>
    <content><![CDATA[<center>Author: 闫玉良</center>
`CentOS` 虚拟机许久未用，忘记密码如何是好？删掉再来又岂能甘心？想安装某个命令，直接 `yum install` 就可以了吗？远程连接服务器报错该怎样操作？

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-CentOS-无法登陆情况下修改密码"><a href="#1-CentOS-无法登陆情况下修改密码" class="headerlink" title="1.CentOS 无法登陆情况下修改密码"></a>1.CentOS 无法登陆情况下修改密码</h2><p><strong>背景：</strong>虚拟机忘记 <code>root</code> 密码，不知如何登陆</p>
<p><strong>环境：</strong><code>CentOS</code>，<code>root</code> 账户</p>
<p><strong>操作：</strong></p>
<p>1.开启虚拟机，在进入系统前选择项页面，按 <code>e</code> 键进入系统配置文件</p>
<p>2.向下移动光标，找到 <code>Linux16</code> 开头，大概意思如下的一句话：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Linux16 /vmlinuz-3.10.0xxxxxx.x86_64 root=UUID=xxxxxxxx ro  crashkernel=auto rhgb quiet LANG=zh_CN.UTF-8</span><br></pre></td></tr></table></figure>

<p>3.在该行的最后加空格，输入 <code>init=/bin/sh</code></p>
<p>4.接下来按 <code>Ctrl + x</code> 组合键进入单用户模式</p>
<blockquote>
<p>等待一会，会发现已经进入系统，只不过，命令行前缀变为类似 <code>sh-4.2#</code> 的效果</p>
</blockquote>
<p>5.输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -o remount,rw /</span><br></pre></td></tr></table></figure>

<p>6.之后输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>

<p>7.接下来就是修改 <code>root</code> 账号密码了</p>
<blockquote>
<p>重复输入一个不少于8位的密码（密码在输入时是不显示的，只需要正确输入并回车即可）</p>
</blockquote>
<p>8.出现 <code>successfully</code> 字样表示修改成功，但要生效还需继续操作</p>
<p>9.输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch /.autorelabel</span><br></pre></td></tr></table></figure>

<p>10.操作完毕，还有一步：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exec /sbin/init</span><br></pre></td></tr></table></figure>

<p>接下来就是等待系统重启（可能需要几分钟，需耐心等待，勿中途关机）</p>
<h2 id="2-安装命令小技巧"><a href="#2-安装命令小技巧" class="headerlink" title="2.安装命令小技巧"></a>2.安装命令小技巧</h2><p>安装命令，大家一定会想到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install xxx</span><br></pre></td></tr></table></figure>

<p>但并非所有命令都是如此。有些则处于某工具包中，需要下载其基础环境，那该如何操作？</p>
<p>只需执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum search xxx</span><br></pre></td></tr></table></figure>

<p>耐心等待几分钟，直到执行完毕。然后安装最后提示模块即可。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum search killall</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Loaded plugins: fastestmirror, security</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"></span><br><span class="line">base: mirrors.163.com</span><br><span class="line">extras: mirrors.aliyun.com</span><br><span class="line">*&gt; updates: mirrors.aliyun.com</span><br><span class="line">-----------------------------------Matched:killall-----------------------------------/</span><br><span class="line">psmisc.x86_64 : Utilities for managing processes on your system</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可看到 <code>killall</code> 命令处于 <code>psmisc.x86_64</code> 中</p>
</blockquote>
<p>然后输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install psmisc.x86_64</span><br></pre></td></tr></table></figure>

<h2 id="3-远程连接服务器"><a href="#3-远程连接服务器" class="headerlink" title="3.远程连接服务器"></a>3.远程连接服务器</h2><p><strong>背景：</strong>使用 <code>ssh</code> 连接服务器进行相关操作，报错</p>
<p><strong>环境：</strong>本地 <code>MacOS</code>，服务器 <code>CentOS</code></p>
<p><strong>操作：</strong></p>
<p>1.使用命令进行远程连接，然后报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❱ ssh root@192.168.xx.xx</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint for the ECDSA key sent by the remote host is</span><br><span class="line">SHA256:ZBm9L5432tibaN5+weK4h9NJzqrc76lvxOUkVvSLGac.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /Users/ethanyan/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending ECDSA key in /Users/ethanyan/.ssh/known_hosts:6</span><br><span class="line">ECDSA host key for 192.168.xx.xx has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure>

<p>2.使用如下命令进行解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -R 你要访问的IP地址</span><br></pre></td></tr></table></figure>

<p>3.最后再次使用命令进行连接发现连接成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh 用户@你要访问的ip地址</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue脚手架搭建项目中的坑</title>
    <url>/2019/12/15/Vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<center>Author:闫玉良</center>
`Vue` 框架如同 `Python` 中的 `Django` 框架一样，让一切操作变得超级简单，只需在规定的目录下书写规定的代码即可，至于如何运作，框架自己搞定。此篇文章仅用于记录 `Vue` 项目中的一些小坑。

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>我发现 <code>Vue</code> 这个框架真的超级严格，不按规定书写代码，就报错给你看！这与 <code>Python</code> 不同，在 <code>Python</code> 中大多数人都会遵循 <code>PEP8</code> ，但毕竟只是规范，除了一些中大型企业会去 <code>review</code> 代码，小型企业都是随缘，全凭编程人员习惯。</p>
<p>虽然动不动就报错，但是好在报错信息超级丰富，可快速定位，除了逻辑问题，其他问题均可快速定位解决。</p>
<h4 id="1-空行坑"><a href="#1-空行坑" class="headerlink" title="1.空行坑"></a>1.空行坑</h4><p>在 <code>Vue</code> 中，每个文件代码都<strong>必须</strong>以空行结尾！否则提醒你：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Newline required at end of file but not found</span><br><span class="line"><span class="meta">#</span><span class="bash"> 结尾未看到规定的空行</span></span><br></pre></td></tr></table></figure>

<p>注意，还只能是一行，要不然会提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Too many blank lines at the end of file. Max of 0 allowed</span><br><span class="line"><span class="meta">#</span><span class="bash"> 结尾的空行太多了，超出最大限制</span></span><br></pre></td></tr></table></figure>

<h4 id="2-字符串的坑"><a href="#2-字符串的坑" class="headerlink" title="2.字符串的坑"></a>2.字符串的坑</h4><p>在 <code>Python</code> 中字符串，可以是单引号、双引号，还可以是三引号。但如果在你的 <code>js</code> 文件中向这样写道：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"CopClass"</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'今晚吃什么'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它会提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">✘  http://eslint.org/docs/rules/quotes  Strings must use singlequote</span><br><span class="line">src/components/EnterPage.vue:13:9</span><br><span class="line">  name: "CopClass",</span><br></pre></td></tr></table></figure>

<p>瞧，告诉你字符串必须使用单引号，还指出了具体的位置。</p>
<h4 id="3-空格坑"><a href="#3-空格坑" class="headerlink" title="3.空格坑"></a>3.空格坑</h4><p>在 <code>data</code> 传递参数 <code>msg</code> 时，可要注意了，像下面的几种情况都会报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// first</span></span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'今晚吃什么'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// second</span></span><br><span class="line">  data ()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'今晚吃什么'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// third</span></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      msg: <span class="string">'今晚吃什么'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>都会及时告诉你某某处缺少空格，请核查。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>扶我起来,我还可以学～</title>
    <url>/2019/12/12/%E6%89%B6%E6%88%91%E8%B5%B7%E6%9D%A5-%E6%88%91%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%AD%A6%EF%BD%9E/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
长路漫漫，唯夜作伴。虽然一天的工作头昏脑胀，但是仍然放不下我心心念念的前端啊，扶我起来，我还可以学～

<p>学习喜欢的事情，也是一种放松，come on！</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>上篇文章讲了 Vue 的一些基础概念，语法。今天上些难度。</p>
<h2 id="1-实例生命周期"><a href="#1-实例生命周期" class="headerlink" title="1.实例生命周期"></a>1.实例生命周期</h2><p>如同人的生老病死，实力对象也有其本身的生命周期。当我们深入了解每一个阶段之后，才会在合适的阶段添加合适的功能。那么如何在合适的阶段完成所需需求呢？那就用到了<strong>生命周期钩子</strong>。类比 Flask 中的请求钩子，Django 中的中间件，不知这样说你是否更好理解。下面我们就来看看有哪些钩子：</p>
<h3 id="1-1-beforeCreate"><a href="#1-1-beforeCreate" class="headerlink" title="1.1 beforeCreate"></a>1.1 beforeCreate</h3><p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p>
<h3 id="1-2-created"><a href="#1-2-created" class="headerlink" title="1.2 created"></a>1.2 created</h3><p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始</p>
<h3 id="1-3-beforeMount"><a href="#1-3-beforeMount" class="headerlink" title="1.3 beforeMount"></a>1.3 beforeMount</h3><p>在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<h3 id="1-4-mounted"><a href="#1-4-mounted" class="headerlink" title="1.4 mounted"></a>1.4 mounted</h3><p>实例挂载到 dom 之后被调用，可以当成是 vue 对象的 ready 方法来使用，一般用它来做 dom 的初始化操作。</p>
<h3 id="1-5-beforeUpdate"><a href="#1-5-beforeUpdate" class="headerlink" title="1.5 beforeUpdate"></a>1.5 beforeUpdate</h3><p>数据发生变化前调用</p>
<h3 id="1-6-updated"><a href="#1-6-updated" class="headerlink" title="1.6 updated"></a>1.6 updated</h3><p>数据发生变化后调用</p>
<h3 id="1-7-beforeDestroy"><a href="#1-7-beforeDestroy" class="headerlink" title="1.7 beforeDestroy"></a>1.7 beforeDestroy</h3><p>挂载完毕，数据更新完成之后；解除绑定，销毁子组件以及事件监听器之前调用。</p>
<h3 id="1-8-destroyed"><a href="#1-8-destroyed" class="headerlink" title="1.8 destroyed"></a>1.8 destroyed</h3><p>销毁完毕之后调用。</p>
<h2 id="2-表单输入绑定"><a href="#2-表单输入绑定" class="headerlink" title="2.表单输入绑定"></a>2.表单输入绑定</h2><p>可以用 v-model 指令在表单 <input> 及 <textarea> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素</textarea></p>
<h3 id="2-1单行文本框"><a href="#2-1单行文本框" class="headerlink" title="2.1单行文本框"></a>2.1单行文本框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-多行文本框"><a href="#2-2-多行文本框" class="headerlink" title="2.2 多行文本框"></a>2.2 多行文本框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Multiline message is:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"add multiple lines"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-复选框"><a href="#2-3-复选框" class="headerlink" title="2.3 复选框"></a>2.3 复选框</h3><p>单个复选框，绑定到布尔值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checked"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"checkbox"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>多个复选框，绑定到同一个数组：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'example-3'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"jack"</span> <span class="attr">value</span>=<span class="string">"Jack"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"jack"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"john"</span> <span class="attr">value</span>=<span class="string">"John"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"john"</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"mike"</span> <span class="attr">value</span>=<span class="string">"Mike"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"mike"</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#example-3',</span><br><span class="line">  data: &#123;</span><br><span class="line">    checkedNames: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-4-单选框"><a href="#2-4-单选框" class="headerlink" title="2.4 单选框"></a>2.4 单选框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"One"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"Two"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '#example-4',</span><br><span class="line">  data: &#123;</span><br><span class="line">    picked: ''</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-5-下拉框"><a href="#2-5-下拉框" class="headerlink" title="2.5 下拉框"></a>2.5 下拉框</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: '...',</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected:''</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-计算属性-amp-监听属性"><a href="#3-计算属性-amp-监听属性" class="headerlink" title="3.计算属性&amp;监听属性"></a>3.计算属性&amp;监听属性</h2><h3 id="3-1-计算属性"><a href="#3-1-计算属性" class="headerlink" title="3.1 计算属性"></a>3.1 计算属性</h3><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个表达式的功能是将message字符串进行反转，这种带有复杂逻辑的表达式，我们可以使用计算属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "&#123;&#123; message &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: '#example',</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: 'Hello'</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      return this.message.split('').reverse().join('')</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-侦听属性"><a href="#3-2-侦听属性" class="headerlink" title="3.2 侦听属性"></a>3.2 侦听属性</h3><p>侦听属性的作用是侦听某属性值的变化，从而做相应的操作，侦听属性是一个对象，它的键是要监听的对象或者变量，值一般是函数,当你侦听的元素发生变化时，需要执行的函数，这个函数有两个形参，第一个是当前值，第二个是变化后的值。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">'#app'</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            iNum:<span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        watch:&#123;</span><br><span class="line">            iNum:<span class="function"><span class="keyword">function</span>(<span class="params">newval,oldval</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(newval + <span class="string">' | '</span> + oldval) </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            fnAdd:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.iNum += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-过滤器"><a href="#4-过滤器" class="headerlink" title="4.过滤器"></a>4.过滤器</h2><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></span><br><span class="line">&#123;&#123; prize | RMB &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在v-bind中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"rawId | formatId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>过滤器实际上是一个函数，可以在一个组件的选项中定义组件内部过滤器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filters:&#123;</span><br><span class="line">  RMB:<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value==<span class="string">''</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'¥ '</span>+value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者在创建 Vue 实例之前全局定义过滤器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.filter(<span class="string">'Yuan'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(value==<span class="string">''</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value+<span class="string">'元'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此时过滤器’RMB’只能在定义它的对象接管标签内使用，而 ‘Yuan’ 可以全局使用</p>
<h2 id="5-数据交互"><a href="#5-数据交互" class="headerlink" title="5. 数据交互"></a>5. 数据交互</h2><p>vue.js没有集成ajax功能，要使用ajax功能，可以使用vue官方推荐的axios.js库来做ajax的交互。 axios库的下载地址：<a href="https://github.com/axios/axios/releases" target="_blank" rel="noopener">https://github.com/axios/axios/releases</a></p>
<h3 id="5-1-axios完整写法："><a href="#5-1-axios完整写法：" class="headerlink" title="5.1 axios完整写法："></a>5.1 axios完整写法：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>axios请求的写法也写成get方式后post方式。</p>
<h3 id="5-2-执行get请求"><a href="#5-2-执行get请求" class="headerlink" title="5.2 执行get请求"></a>5.2 执行get请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为给定 ID 的 user 创建请求</span></span><br><span class="line"><span class="comment">// then是请求成功时的响应，catch是请求失败时的响应</span></span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选地，上面的请求可以这样做</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="5-3-执行post请求"><a href="#5-3-执行post请求" class="headerlink" title="5.3 执行post请求"></a>5.3 执行post请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">  firstName: <span class="string">'Fred'</span>,</span><br><span class="line">  lastName: <span class="string">'Flintstone'</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="6-ES6-语法"><a href="#6-ES6-语法" class="headerlink" title="6.ES6 语法"></a>6.ES6 语法</h2><h3 id="6-1-变量声明let和const"><a href="#6-1-变量声明let和const" class="headerlink" title="6.1 变量声明let和const"></a>6.1 变量声明let和const</h3><p>let 和 const 是新增的声明变量的开头的关键字，在这之前，变量声明是用 var 关键字，这两个关键字和 var 的区别是，它们声明的变量没有预解析，let 和 const 的区别是，let 声明的是一般变量，const 申明的常量，不可修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(iNum01) <span class="comment">// 弹出undefined</span></span><br><span class="line"><span class="comment">// alert(iNum02); 报错，let关键字定义变量没有变量预解析</span></span><br><span class="line"><span class="comment">// alert(iNum03); 报错，const关键字定义变量没有变量预解析</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iNum01 = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 使用let关键字定义变量</span></span><br><span class="line"><span class="keyword">let</span> iNum02 = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// 使用const关键字定义变量</span></span><br><span class="line"><span class="keyword">const</span> iNum03 = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">alert(iNum01); <span class="comment">// 弹出6</span></span><br><span class="line">alert(iNum02); <span class="comment">// 弹出12</span></span><br><span class="line">alert(iNum03); <span class="comment">// 弹出24</span></span><br><span class="line"></span><br><span class="line">iNum01 = <span class="number">7</span>;</span><br><span class="line">iNum02 = <span class="number">13</span>;</span><br><span class="line"><span class="comment">//iNum03 = 25; // 报错,const定义的变量不可修改,const定义的变量是常量</span></span><br><span class="line"></span><br><span class="line">alert(iNum01)</span><br><span class="line">alert(iNum02); </span><br><span class="line">alert(iNum03);</span><br></pre></td></tr></table></figure>

<h3 id="6-2-箭头函数"><a href="#6-2-箭头函数" class="headerlink" title="6.2 箭头函数"></a>6.2 箭头函数</h3><p>可以把箭头函数理解成匿名函数的第二种写法，箭头函数的作用是可以在对象中绑定 this，解决了 JavaScript 中 this 指定混乱的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义函数的一般方式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">function fnRs(a,b)&#123;</span></span><br><span class="line"><span class="comment">    var rs = a + b;</span></span><br><span class="line"><span class="comment">    alert(rs);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">fnRs(1,2);        </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过匿名函数赋值来定义函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">var fnRs = function(a,b)&#123;</span></span><br><span class="line"><span class="comment">    var rs = a + b;</span></span><br><span class="line"><span class="comment">    alert(rs);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">fnRs(1,2);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过箭头函数的写法定义</span></span><br><span class="line"><span class="keyword">var</span> fnRs = <span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rs = a + b;</span><br><span class="line">    alert(rs);</span><br><span class="line">&#125;        </span><br><span class="line"><span class="comment">// fnRs(1,2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个参数可以省略小括号</span></span><br><span class="line"><span class="keyword">var</span> fnRs2 = <span class="function"><span class="params">a</span> =&gt;</span>&#123;</span><br><span class="line">    alert(a);</span><br><span class="line">&#125;</span><br><span class="line">fnRs2(<span class="string">'haha!'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数的作用，可以绑定对象中的this</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">'tom'</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    showName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;,<span class="number">1000</span>)            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.showName();</span><br></pre></td></tr></table></figure>

<h3 id="6-3-模块导入import和导出export"><a href="#6-3-模块导入import和导出export" class="headerlink" title="6.3 模块导入import和导出export"></a>6.3 模块导入import和导出export</h3><p>javascript 之前是没有模块的功能的，之前做 js 模块化开发，是用的一些 js 库来模拟实现的，在 ES6 中加入了模块的功能，和 python 语言一样，python 中一个文件就是一个模块，ES6 中，一个 js 文件就是一个模块，不同的是，js 文件中需要先导出 (export) 后，才能被其他 js 文件导入(import)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// model.js文件中导出</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>:<span class="string">'tom'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;person&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js文件夹中导入</span></span><br><span class="line"><span class="keyword">import</span> person <span class="keyword">from</span> <span class="string">'js/model.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js中使用模块</span></span><br><span class="line">person.name</span><br><span class="line">person.age</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面导出时使用了default关键字，如果不使用这个关键字，导入时需要加大括号：</span></span><br><span class="line"><span class="comment">import &#123;person&#125; from 'js/model.js'</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>目前ES6的模块功能需要在服务器环境下才可以运行。</p>
<h3 id="6-4-对象的简写"><a href="#6-4-对象的简写" class="headerlink" title="6.4 对象的简写"></a>6.4 对象的简写</h3><p>javascript 对象在 ES6 中可以做一些简写形式，了解这些简写形式，才能方便我们读懂一些在 javascript 代码中简写的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'李思'</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">var person = &#123;</span></span><br><span class="line"><span class="comment">    name:name,</span></span><br><span class="line"><span class="comment">    age:age,</span></span><br><span class="line"><span class="comment">    showname:function()&#123;</span></span><br><span class="line"><span class="comment">        alert(this.name);</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    showage:function()&#123;</span></span><br><span class="line"><span class="comment">        alert(this.age);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写成下面的形式</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    showname()&#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    showage()&#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.showname();</span><br><span class="line">person.showage();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端攻坚战</title>
    <url>/2019/12/09/%E5%89%8D%E7%AB%AF%E6%94%BB%E5%9D%9A%E6%88%98/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
前端三大新框架：Angular.js、React.js、Vue.js。今天我们来磕这个最常用，影响极广的框架：Vue.js。

<p>Vue.js可以作为一个js库来使用，也可以用它全套的工具来构建系统界面，这些可以根据项目的需要灵活选择，所以说，Vue.js是一套构建用户界面的渐进式框架。</p>
<blockquote>
<p>Vue的核心库只关注视图层，Vue的目标是通过尽可能简单的 API 实现响应的数据绑定，在这一点上Vue.js类似于后台的模板语言。</p>
<p>Vue也可以将界面拆分成一个个的组件，通过组件来构建界面，然后用自动化工具来生成单页面(SPA - single page application)系统。</p>
</blockquote>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-快速上手"><a href="#1-快速上手" class="headerlink" title="1.快速上手"></a>1.快速上手</h2><p>还是从最基本的使用开始回顾。</p>
<p>第一步，需要实例化一个 Vue 对象，像下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;<span class="attr">message</span>:<span class="string">'hello world!'</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>html 页面中 id 为 app 的标签就可以通过模版语法接收到此消息：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>是不是很眼熟？没错，和我们 python 后端的模版语法一样，所以就不要抵触，开开心心使用吧。</p>
<p>当然，我们还可以在 Vue 实例化过程中定义方法，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;<span class="attr">message</span>: <span class="string">'hello world!'</span>&#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    fnChangeMsg:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.message = <span class="string">'hello Vue.js!'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们可以使用下面的页面感受它的 <code>响应式</code> ：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fnChangeMsg"</span>&gt;</span></span><br><span class="line">    点击即可改变数据</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面我们分析一下这个阶段发生了什么：</p>
<p>首先，当创建一个 Vue 实例时，它会把 data 对象中所有属性添加到 Vue 的响应式系统中。当这些属性的值发生变化，视图将会匹配到更新之后的值。上面的例子，通过一个方法，改变 data 对象中的属性，使视图中的值随之变化，演示了响应式。</p>
<h2 id="2-模版语法"><a href="#2-模版语法" class="headerlink" title="2.模版语法"></a>2.模版语法</h2><p>模版语法的作用就是获取数据，并在 HTML 页面中进行展示。</p>
<blockquote>
<p>所有 Vue.js的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。</p>
</blockquote>
<h3 id="2-1-插入值"><a href="#2-1-插入值" class="headerlink" title="2.1 插入值"></a>2.1 插入值</h3><p>1.最最常见的一种是胡子语法，即双大括号，也就是上面示例中的样式。除了可以获取值，大括号中还支持写表达式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? 'YES' : 'No' &#125;&#125;</span><br><span class="line">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>2.还有一种情况，标签的属性需要获取值，这时就不能再次使用胡子语法了，可以改写为 <code>v-bind</code> 指令：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span> <span class="attr">vbind:title</span>=<span class="string">"tip"</span>&gt;</span>小闫劝你多喝热水<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-指令"><a href="#2-2-指令" class="headerlink" title="2.2 指令"></a>2.2 指令</h3><p>Vue 中指令就是带有前缀 <code>v-</code> 前缀的特殊属性。</p>
<blockquote>
<p>指令属性的值预期是单个JavaScript表达式，指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM。</p>
</blockquote>
<p>常见的指令有 <code>v-bind</code>、<code>v-if</code>、<code>v-on</code> 和 <code>v-for</code>。下面举两个例子进行演示即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据 ok 的布尔值来插入/移除 &lt;p&gt; 元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line">  是否显示这一段</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 监听按钮的 click 事件来执行 fnChangeMsg 方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"fnChangeMsg"</span>&gt;</span></span><br><span class="line">  按钮</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-缩写"><a href="#2-3-缩写" class="headerlink" title="2.3 缩写"></a>2.3 缩写</h3><p>v-bind 和 v-on 事件这两个指令因为经常的使用，所以提供了简写的方式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整的语法形式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 完整的语法形式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"fnChangeMsg"</span>&gt;</span></span><br><span class="line">  按钮</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fnChangeMsg"</span>&gt;</span></span><br><span class="line">  按钮</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-Class-属性设置"><a href="#2-4-Class-属性设置" class="headerlink" title="2.4 Class 属性设置"></a>2.4 Class 属性设置</h3><p>设置元素的 class 属性可以使用 v-bind 指令。因为它们的属性值可以是表达式，vue.js在这一块做了增强。表达式结果除了是字符串之外，还可以是对象或者数组。</p>
<h4 id="2-4-1-对象的情况"><a href="#2-4-1-对象的情况" class="headerlink" title="2.4.1 对象的情况"></a>2.4.1 对象的情况</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static"</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123;active:isActive,'text-danger':hasError &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>data 的属性值是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  hasError: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终渲染的效果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static active"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以给 v-bind:class 传一个对象引用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>data 属性值可以写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: true,</span><br><span class="line">    &apos;text-danger&apos;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-数组的情况"><a href="#2-4-2-数组的情况" class="headerlink" title="2.4.2 数组的情况"></a>2.4.2 数组的情况</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[activeClass, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: 'active',</span><br><span class="line">  errorClass: 'text-danger'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终渲染为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"active text-danger"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你也想根据条件切换列表中的 class，可以用三元表达式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>即当 isActive 值为 ture 时，属性为 activeClass，否则属性值为 <code>&#39;&#39;</code></p>
<blockquote>
<p>Js 的三元表达式：<code>条件 ? 为真时的结果 : 为假时的结果</code></p>
</blockquote>
<h3 id="2-5-条件"><a href="#2-5-条件" class="headerlink" title="2.5 条件"></a>2.5 条件</h3><p>一般通过条件指令来控制元素是显示还是隐藏，是创建还是销毁。</p>
<p>虽然语法有些许陌生，但是永远逃不了 if 、else if 、else 这三个东西，所有语言都是如此。那么我们来分情况看一下这三种情况如何书写：</p>
<h4 id="2-5-1-v-if"><a href="#2-5-1-v-if" class="headerlink" title="2.5.1 v-if"></a>2.5.1 v-if</h4><p>v-if 可以控制元素的创建或者销毁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-v-else"><a href="#2-5-2-v-else" class="headerlink" title="2.5.2 v-else"></a>2.5.2 v-else</h4><p>v-else 指令来表示 v-if 的 <code>else 块</code>，v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;</span><br><span class="line">  Now you see me</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Now you don&apos;t</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-v-else-if"><a href="#2-5-3-v-else-if" class="headerlink" title="2.5.3 v-else-if"></a>2.5.3 v-else-if</h4><p>v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;</span><br><span class="line">  B</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Not A/B/C</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-4-v-show"><a href="#2-5-4-v-show" class="headerlink" title="2.5.4 v-show"></a>2.5.4 v-show</h4><p>另一个用于根据条件展示元素的选项是 v-show 指令。用法和 v-if 大致一样，但是它不支持 v-else ,它和 v-if 的区别是，它制作元素样式的显示和隐藏，元素一直是存在的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-列表循环"><a href="#2-6-列表循环" class="headerlink" title="2.6 列表循环"></a>2.6 列表循环</h3><p>数一数，常用的指令还有俩，那快解决吧。</p>
<p>一种常用的情况–列表渲染，即通过遍历数组或者对象，渲染到页面中。这时就需要用到一个指令 v-for。同样我们通过数组和对象两种情况进行演示：</p>
<h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">    &#123;&#123; item &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>vue对象创建如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [<span class="string">'foo'</span>,<span class="string">'bar'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果想加上索引值，可以加上第二个参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span>&gt;</span></span><br><span class="line">    &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h4><p>也可以用 v-for 通过一个对象的属性来迭代</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"v-for-object"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"value in object"</span>&gt;</span></span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果想加上对象属性名，可以加上第二个参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"v-for-object"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(value,key) in object"</span>&gt;</span></span><br><span class="line">    &#123;&#123; key &#125;&#125;-&#123;&#123; value &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-7-事件相关"><a href="#2-7-事件相关" class="headerlink" title="2.7 事件相关"></a>2.7 事件相关</h3><h4 id="2-7-1-事件绑定方法"><a href="#2-7-1-事件绑定方法" class="headerlink" title="2.7.1 事件绑定方法"></a>2.7.1 事件绑定方法</h4><p>可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。</p>
<p>事件的处理，简单的逻辑可以写在指令中，复杂的就需要在 vue 对象的 methods 属性中指定处理函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;example-1&quot;&gt;</span><br><span class="line">  &lt;!-- 在指令中写处理逻辑 --&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;</span><br><span class="line">  &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">......</span><br><span class="line">var example1 = new Vue(&#123;</span><br><span class="line">  el: &apos;#example-1&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>methods 属性中指定处理函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;example-2&quot;&gt;</span><br><span class="line">  &lt;!-- greet 是在下面定义的方法名 --&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">var example2 = new Vue(&#123;</span><br><span class="line">  el: &apos;#example-2&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: &apos;Vue.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 在 `methods` 对象中定义方法</span><br><span class="line">  methods: &#123;</span><br><span class="line">    greet: function () &#123;</span><br><span class="line">      // `this` 在方法里指向当前 Vue 实例</span><br><span class="line">      alert(&apos;Hello &apos; + this.name + &apos;!&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-7-2-事件修饰符"><a href="#2-7-2-事件修饰符" class="headerlink" title="2.7.2 事件修饰符"></a>2.7.2 事件修饰符</h4><p>实际开发中，事件绑定有时候牵涉到阻止事件冒泡以及阻止默认行为，在 vue.js 可以加上事件修饰符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>继续死磕前端</title>
    <url>/2019/12/08/%E7%BB%A7%E7%BB%AD%E6%AD%BB%E7%A3%95%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
昨天将所有的基础知识进行了回顾，今天继续磕，不死不休～

<p>今天要说的便是 jquery 这个函数库，毕竟它影响范围之广，不会都不好意说自己会前端？</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h2><p>long long ago ～ 人们发现了一个好用的工具，它涵盖了常用的所有功能，还提供了很多相当方便的设计（如 Ajax）。因此，它的面世，如星星之火燎原之势迅猛发展，以至于微软公司把它作为官方库。</p>
<p>这个小小的 js 文件，你可以说他是插件，也可以称其为框架，随你喜欢，只要知道一点，它很好用就可以了。肯定有人会问如何下载之类的问题，其实我很不愿意回答，毕竟这些随意百度到的东西很浪费时间和文字，但是秉承着服务的宗旨，贴出以下链接：</p>
<p>1、<a href="http://jquery.com/" target="_blank" rel="noopener">http://jquery.com/</a> 官方网站</p>
<p>2、<a href="https://code.jquery.com/" target="_blank" rel="noopener">https://code.jquery.com/</a> 版本下载</p>
<h3 id="1-简单入门"><a href="#1-简单入门" class="headerlink" title="1.简单入门"></a>1.简单入门</h3><p>还记得上篇文章反复强调的一个问题嘛？就是 js 代码放在何处执行的问题。要么老老实实放置在所需应用样式的标签后面，要么将其丢到 window.onload 方法内部。</p>
<p>jquery 提供了一种速度更快，使用更便捷的方式，那便是 ready 方法。它长成了下面美丽的样子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>嫌弃它的臃肿，可以简写为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  xxx</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在是否顺眼了许多？</p>
<h4 id="1-1-jquery-选择器"><a href="#1-1-jquery-选择器" class="headerlink" title="1.1 jquery 选择器"></a>1.1 jquery 选择器</h4><p>还记到大明湖畔（CSS）的夏雨荷（选择器）吗？选择器可以快速定位到元素并为其应用样式效果。jquery 选择器的选择规则与 CSS 相同，只是目的是为其添加操作。</p>
<p>不要有任何心理负担，它相当简单，如下：</p>
<p>1.选择 id 为 Ethan 的元素（类比 id 选择器）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#Ethan'</span>)</span><br></pre></td></tr></table></figure>

<p>2.选择 class 为  Yan 的元素（类比类选择器）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.Yan'</span>)</span><br></pre></td></tr></table></figure>

<p>3.选择所有的 p 标签（类比标签选择器）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'p'</span>)</span><br></pre></td></tr></table></figure>

<p>4.选择 id 为 mylist 的元素下所有 li 标签下的 span 元素（类比层级选择器）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#mylist li span'</span>)</span><br></pre></td></tr></table></figure>

<p>5.选择 name 属性为 yan 的 input 元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'input[name=yan]'</span>)</span><br></pre></td></tr></table></figure>

<p>如果一类元素范围太广，需要更精确一些呢？可以使用如下的过滤条件：</p>
<p>1.has 包含条件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).has(<span class="string">'p'</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>包含 p 元素的 div 元素</p>
</blockquote>
<p>2.判等条件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).eq(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第 5 个 div 元素</p>
</blockquote>
<p>3.寻找条件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#box'</span>).find(<span class="string">'.myClass'</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>选择 id 是 box 元素中 class 为 myClass 的元素</p>
</blockquote>
<p>4.前一个元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#box'</span>).prev();</span><br></pre></td></tr></table></figure>

<p>5.后一个元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#box'</span>).next();</span><br></pre></td></tr></table></figure>

<p>已经知道了如何定位某个元素，那么如何定位一个精确的集合呢？这个也不难：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择id是box的元素之前所有的同辈元素</span></span><br><span class="line">$(<span class="string">'#box'</span>).prevAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择id是box的元素后面所有的同辈元素</span></span><br><span class="line">$(<span class="string">'#box'</span>).nextAll(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//选择id是box的元素的父元素</span></span><br><span class="line">$(<span class="string">'#box'</span>).parent(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//选择id是box的元素的所有子元素</span></span><br><span class="line">$(<span class="string">'#box'</span>).children(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//选择id是box的元素的同级元素</span></span><br><span class="line">$(<span class="string">'#box'</span>).siblings();</span><br></pre></td></tr></table></figure>

<p>有人会想，如果我写错了，没找到报错怎么办？大可放心，jquery 有容错机制，即使没有找到元素，也不会出错。还为你提供了验证是否找到的方法，那便是 length 属性。length 值为 0 时代表没选择到想要元素；为 1 则代表选择到了相应的元素。</p>
<p>除了选择元素，还可以选择样式呢！啥都能找到，强不强？既然都能找到了，重新赋值也必须到位！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取div的样式</span></span><br><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"width"</span>);</span><br><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"color"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"width"</span>,<span class="string">"20px"</span>);</span><br><span class="line">$(<span class="string">"div"</span>).css(<span class="string">"color"</span>,<span class="string">"red"</span>);</span><br></pre></td></tr></table></figure>

<p>如果你足够的细心，你也许会问，选择器一般都选择多个元素，那么你获取到的是哪一个元素的值呢？</p>
<p>答：第一个。</p>
<p>再看看其他操作样式的类名吧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为id为div1的对象追加样式divClass2</span></span><br><span class="line">$(<span class="string">"#div1"</span>).addClass(<span class="string">"divClass2"</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除id为div1的对象的class名为divClass的样式</span></span><br><span class="line">$(<span class="string">"#div1"</span>).removeClass(<span class="string">"divClass"</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除多个样式</span></span><br><span class="line">$(<span class="string">"#div1"</span>).removeClass(<span class="string">"divClass divClass2"</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 重复切换anotherClass样式</span></span><br><span class="line">$(<span class="string">"#div1"</span>).toggleClass(<span class="string">"anotherClass"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-绑定点击事件"><a href="#1-2-绑定点击事件" class="headerlink" title="1.2 绑定点击事件"></a>1.2 绑定点击事件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#btn'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 内部的 this 指的是原生对象</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 使用 jquery 对象用 $(this)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>js 对象与 jquery 对象有些许不同，jquery 对象是对 js 对象的封装，然后让其拥有了 jquery 的操作方法。他俩之间可以相互转换。</p>
<p>DOM 对象转 jquery 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(js对象)</span><br></pre></td></tr></table></figure>

<p>jquery 对象转 DOM 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery对象[index];    <span class="comment">//方式1 （推荐使用）</span></span><br><span class="line"></span><br><span class="line">jQuery对象.get(index); <span class="comment">//方式2</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>获取元素的索引值可以使用 index() 方法</p>
<h4 id="1-3-jquery-动画"><a href="#1-3-jquery-动画" class="headerlink" title="1.3 jquery 动画"></a>1.3 jquery 动画</h4><p>通过 animate 方法可以设置元素某属性值上的动画，动画执行完后会执行一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#div1'</span>).animate(&#123;</span><br><span class="line">    width:<span class="number">300</span>,</span><br><span class="line">    height:<span class="number">300</span></span><br><span class="line">&#125;,<span class="number">1000</span>,<span class="string">'swing'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'done!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>animate 参数详解</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    animate参数：</span></span><br><span class="line"><span class="comment">    参数一：要改变的样式属性值，写成字典的形式</span></span><br><span class="line"><span class="comment">    参数二：动画持续的时间，单位为毫秒，一般不写单位</span></span><br><span class="line"><span class="comment">    参数三：动画曲线，默认为‘swing’，缓冲运动，还可以设置为‘linear’，匀速运动</span></span><br><span class="line"><span class="comment">    参数四：动画回调函数，动画完成后执行的匿名函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-进阶"><a href="#2-进阶" class="headerlink" title="2.进阶"></a>2.进阶</h3><h4 id="2-1-特殊效果"><a href="#2-1-特殊效果" class="headerlink" title="2.1 特殊效果"></a>2.1 特殊效果</h4><p>1.<code>fadeIn()</code> 淡入</p>
<p>2.<code>fadeOut()</code> 淡出</p>
<p>3.<code>hide()</code> 隐藏</p>
<p>4.<code>show()</code> 显示</p>
<p>5.<code>toggle()</code> 切换元素的可见状态</p>
<p>6.<code>slideDown()</code> 向下展开</p>
<p>7.<code>slideUp()</code> 向上卷起</p>
<p>8.<code>slideToggle()</code> 依次展开或卷起某个元素</p>
<p><strong>Example</strong>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$btn.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">'#div1'</span>).fadeIn(<span class="number">1000</span>,</span><br><span class="line">                   <span class="string">'swing'</span>,</span><br><span class="line">                   <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    									alert(<span class="string">'done'</span>);</span><br><span class="line">  								&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在看过很多属性时，不知道大家是否发现了一个规律：凡是成对出现的属性，一般都有一个组合属性，名字带有 <code>toggle</code></p>
</blockquote>
<h4 id="2-2-链式调用"><a href="#2-2-链式调用" class="headerlink" title="2.2 链式调用"></a>2.2 链式调用</h4><p>链式调用，其实就是将多个方法一直拼接在对象后面，像链条一样调用。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#div1'</span>) <span class="comment">// id为div1的元素</span></span><br><span class="line">.children(<span class="string">'ul'</span>) <span class="comment">//该元素下面的ul子元素</span></span><br><span class="line">.slideDown(<span class="string">'fast'</span>) <span class="comment">//高度从零变到实际高度来显示ul元素</span></span><br><span class="line">.parent()  <span class="comment">//跳到ul的父元素，也就是id为div1的元素</span></span><br><span class="line">.siblings()  <span class="comment">//跳到div1元素平级的所有兄弟元素</span></span><br><span class="line">.children(<span class="string">'ul'</span>) <span class="comment">//这些兄弟元素中的ul子元素</span></span><br><span class="line">.slideUp(<span class="string">'fast'</span>);  <span class="comment">//高度实际高度变换到零来隐藏ul元素</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>换行是为了加注释解释每一个方法，其实它为一行。</p>
</blockquote>
<h4 id="2-3-属性操作"><a href="#2-3-属性操作" class="headerlink" title="2.3 属性操作"></a>2.3 属性操作</h4><p>还记得昨天总结中 js 对象如何获取元素内容嘛？没错，是 <code>innerHTML</code>。jquery 中则是使用 html() 方法获取和设置 html 内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line"><span class="keyword">var</span> $htm = $(<span class="string">'#div1'</span>).html();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 html 内容</span></span><br><span class="line">$(<span class="string">'#div1'</span>).html(<span class="string">'&lt;span&gt;xxx&lt;/span&gt;'</span>);</span><br></pre></td></tr></table></figure>

<p>jquery 中获取或者设置某个属性值时可以使用如下方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取出图片的地址</span></span><br><span class="line"><span class="keyword">var</span> $src = $(<span class="string">'#img1'</span>).prop(<span class="string">'src'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置图片的地址和alt属性</span></span><br><span class="line">$(<span class="string">'#img1'</span>).prop(&#123;<span class="attr">src</span>: <span class="string">"test.jpg"</span>, <span class="attr">alt</span>: <span class="string">"Test Image"</span> &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-4-事件"><a href="#2-4-事件" class="headerlink" title="2.4 事件"></a>2.4 事件</h4><p><strong>常用的一些事件函数</strong>：</p>
<p>1.<code>blur()</code> 元素失去焦点</p>
<p>2.<code>focus()</code> 元素获得焦点</p>
<p>3.<code>click()</code> 鼠标单击</p>
<p>4.<code>mouseover()</code> 鼠标进入（进入子元素也触发）</p>
<p>5.<code>mouseout()</code> 鼠标离开（离开子元素也触发）</p>
<p>6.<code>mouseenter()</code> 鼠标进入（进入子元素不触发）</p>
<p>7.<code>mouseleave()</code> 鼠标离开（离开子元素不触发）</p>
<p>8.<code>hover()</code> 同时为mouseenter和mouseleave事件指定处理函数</p>
<p>9.<code>ready()</code> DOM加载完成</p>
<p>10.<code>submit()</code> 用户递交表单</p>
<h4 id="2-5-正则表达式-表单验证"><a href="#2-5-正则表达式-表单验证" class="headerlink" title="2.5 正则表达式-表单验证"></a>2.5 正则表达式-表单验证</h4><p>正则表达式无比强大，处处可以看见其身影。当我们验证邮箱格式、手机号、身份证号时必不可少，那么 jquery 中如何使用呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'规则'</span>, <span class="string">'可选参数'</span>);</span><br><span class="line"><span class="keyword">var</span> re=<span class="regexp">/规则/</span>参数;</span><br></pre></td></tr></table></figure>

<p>大家可以看到，其由规则与参数两部分组成。其中规则老生常谈，我们再复习一遍：</p>
<p><code>\d</code> 匹配一个数字，即0-9</p>
<p><code>\D</code> 匹配一个非数字，即除了0-9</p>
<p><code>\w</code> 匹配一个单词字符（字母、数字、下划线）</p>
<p><code>\W</code> 匹配任何非单词字符。等价于<code>[^A-Za-z0-9_]</code></p>
<p><code>\s</code> 匹配一个空白符</p>
<p><code>\S</code> 匹配一个非空白符</p>
<p><code>\b</code> 匹配单词边界</p>
<p><code>\B</code> 匹配非单词边界</p>
<p><code>.</code> 匹配一个任意字符</p>
<p><strong>量词</strong>：</p>
<p><code>?</code> 出现零次或一次（最多出现一次）</p>
<p><code>+</code> 出现一次或多次（至少出现一次）</p>
<p><code>*</code> 出现零次或多次（任意次）</p>
<p><code>{n}</code> 出现n次</p>
<p><code>{n,m}</code> 出现n到m次</p>
<p><code>{n,}</code> 至少出现n次</p>
<p><strong>范围</strong>：使用中括号将可选内容列出，代表内容中任意一个</p>
<p><code>[abc123]</code> : 匹配‘abc123’中的任意一个字符</p>
<p><code>[a-z0-9]</code> : 匹配a到z或者0到9中的任意一个字符</p>
<p><strong>限制开头与结尾</strong>：</p>
<p><code>^</code> 以紧挨的元素开头</p>
<p><code>$</code> 以紧挨的元素结尾</p>
<p>那么<strong>参数</strong>部分，常用的有：</p>
<p><code>g</code>： global，全文搜索，默认搜索到第一个结果接停止</p>
<p><code>i</code>： ingore case，忽略大小写，默认大小写敏感</p>
<p>还有常用的<strong>函数</strong></p>
<p><code>test</code></p>
<p>用法：<code>正则.test(字符串)</code> 匹配成功，就返回真，否则就返回假</p>
<p><strong>正则默认规则</strong> </p>
<p>匹配成功就结束，不会继续匹配，区分大小写</p>
<p>下面给大家个福利，总结了常用的正则表达式，直接复制粘贴即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户名验证：(数字字母或下划线6到20位)</span></span><br><span class="line"><span class="keyword">var</span> reUser = <span class="regexp">/^\w&#123;6,20&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邮箱验证：        </span></span><br><span class="line"><span class="keyword">var</span> reMail = <span class="regexp">/^[a-z0-9][\w\.\-]*@[a-z0-9\-]+(\.[a-z]&#123;2,5&#125;)&#123;1,2&#125;$/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//密码验证：</span></span><br><span class="line"><span class="keyword">var</span> rePass = <span class="regexp">/^[\w!@#$%^&amp;*]&#123;6,20&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手机号码验证：</span></span><br><span class="line"><span class="keyword">var</span> rePhone = <span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>;</span><br></pre></td></tr></table></figure>


<h3 id="3-高级"><a href="#3-高级" class="headerlink" title="3.高级"></a>3.高级</h3><h4 id="3-1-事件冒泡"><a href="#3-1-事件冒泡" class="headerlink" title="3.1 事件冒泡"></a>3.1 事件冒泡</h4><p>先来看看什么是事件冒泡：</p>
<blockquote>
<p>在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。</p>
</blockquote>
<p>就这样一层一层往上冒的效果，我们形象的称为冒泡。那么它有什么作用呢？</p>
<p>答：事件冒泡允许多个操作被集中处理（把事件处理器添加到一个父级元素上，避免把事件处理器添加到多个子级元素上），它还可以让你在对象层的不同级别捕获事件。</p>
<p>这只是一种机制，但是我们并不是任何情况下都需要，那么可以将其关掉。通过：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.stopPropagation();</span><br></pre></td></tr></table></figure>

<p>既然说起阻止事件冒泡了，那么我们也提一下如何阻止表单提交吧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure>

<p>实际开发中其实常常将其混合使用，也就是两句话写在一起使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// event.stopPropagation();</span></span><br><span class="line"><span class="comment">// event.preventDefault();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并写法：</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-事件委托"><a href="#3-2-事件委托" class="headerlink" title="3.2 事件委托"></a>3.2 事件委托</h4><p>同样，先来看定义：</p>
<blockquote>
<p>事件委托就是利用冒泡的原理，把事件加到父级上，通过判断事件来源的子集，执行相应的操作，事件委托首先可以极大减少事件绑定次数，提高性能；其次可以让新加入的子元素也可以拥有相同的操作。</p>
</blockquote>
<p><strong>一般绑定事件的写法</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">    $ali = $(&apos;#list li&apos;);</span><br><span class="line">    $ali.click(function() &#123;</span><br><span class="line">        $(this).css(&#123;background:&apos;red&apos;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p><strong>事件委托的写法</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">    $list = $(&apos;#list&apos;);</span><br><span class="line">    $list.delegate(&apos;li&apos;, &apos;click&apos;, function() &#123;</span><br><span class="line">        $(this).css(&#123;background:&apos;red&apos;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-Dom-操作"><a href="#3-3-Dom-操作" class="headerlink" title="3.3 Dom 操作"></a>3.3 Dom 操作</h4><p>Dom 操作也叫做元素节点操作，它指的是改变html的标签结构，它有两种情况：</p>
<p>1、移动现有标签的位置</p>
<p>2、将新创建的标签插入到现有的标签中 </p>
<p><strong>创建新标签</strong> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $div = $(<span class="string">'&lt;div&gt;'</span>); <span class="comment">//创建一个空的div</span></span><br><span class="line"><span class="keyword">var</span> $div2 = $(<span class="string">'&lt;div&gt;这是一个div元素&lt;/div&gt;'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>移动或者插入标签的方法</strong> </p>
<p>1、<code>append()</code> 和 <code>appendTo()</code>：在现存元素的内部，从后面放入元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $span = $(<span class="string">'&lt;span&gt;这是一个span元素&lt;/span&gt;'</span>);</span><br><span class="line">$(<span class="string">'#div1'</span>).append($span);</span><br><span class="line">......</span><br><span class="line">&lt;div id=<span class="string">"div1"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>2、<code>prepend()</code> 和 <code>prependTo()</code>：在现存元素的内部，从前面放入元素</p>
<p>3、<code>after()</code> 和 <code>insertAfter()</code>：在现存元素的外部，从后面放入元素</p>
<p>4、<code>before()</code> 和 <code>insertBefore()</code>：在现存元素的外部，从前面放入元素</p>
<p><strong>删除标签</strong> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#div1'</span>).remove();</span><br></pre></td></tr></table></figure>

<h4 id="3-4-对象"><a href="#3-4-对象" class="headerlink" title="3.4 对象"></a>3.4 对象</h4><p>JavaScript 的对象，可以简单的理解为一个键值对的集合，也就是 python 中的字典，键就是调用每个值的名称，值就是变量、函数、对象这些。</p>
<p>面向对象编程深入人心，有着 python 、java 的基础，大家应该不难理解。接下来说一下 js 中如何创建一个对象，并对其进行操作。</p>
<p>1.创建一个对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Ethan'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello'</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.添加属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.name = <span class="string">'tom'</span>;</span><br><span class="line">person.age = <span class="string">'99'</span>;</span><br></pre></td></tr></table></figure>

<p>3.添加方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name + <span class="string">'你好'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.调用方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.sayHello();</span><br><span class="line">person.age;</span><br></pre></td></tr></table></figure>

<h3 id="4-Ajax"><a href="#4-Ajax" class="headerlink" title="4.Ajax"></a>4.Ajax</h3><p>ajax一个前后台配合的技术，它可以让 javascript 发送 http 请求，与后台通信，获取数据和信息。ajax 技术的原理是实例化 xmlhttp 对象，使用此对象与后台通信。jquery 将它封装成了一个函数 <code>$.ajax()</code>，我们可以直接用这个函数来执行ajax请求。</p>
<p>此部分<strong>超级重要！超级重要！超级重要！</strong></p>
<blockquote>
<p>ajax需要在服务器环境下运行。</p>
</blockquote>
<p>先来看一个示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/change_data'</span>,</span><br><span class="line">    type: <span class="string">'GET'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    data:&#123;<span class="string">'code'</span>:<span class="number">300268</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.done(<span class="function"><span class="keyword">function</span>(<span class="params">dat</span>) </span>&#123;</span><br><span class="line">    alert(dat.name);</span><br><span class="line">&#125;)</span><br><span class="line">.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'服务器超时，请重试！'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后看一下其中的参数：</p>
<p>1、<code>url</code> 请求地址</p>
<p>2、<code>type</code> 请求方式，默认是 <code>GET</code>，常用的还有 <code>POST</code></p>
<p>3、<code>dataType</code> 设置返回的数据格式，常用的是 <code>json</code> 格式，也可以设置为<code>html</code></p>
<p>4、<code>data</code> 设置发送给服务器的数据</p>
<p>5、<code>success</code> 设置请求成功后的回调函数</p>
<p>6、<code>error</code> 设置请求失败后的回调函数</p>
<p>7、<code>async</code> 设置是否异步，默认值是 <code>true</code>，表示异步</p>
<p>简写方式：</p>
<p><code>$.ajax</code> 按照请求方式可以简写成 <code>$.get</code> 或者 <code>$.post</code> 方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="keyword">get</span>("/change_data", &#123;<span class="string">'code'</span>:<span class="number">300268</span>&#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">dat,status</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(status==<span class="string">'success'</span>)&#123;</span><br><span class="line">    	alert(dat.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">'json'</span>);</span><br><span class="line"></span><br><span class="line">$.post(<span class="string">"/change_data"</span>, &#123;<span class="string">'code'</span>:<span class="number">300268</span>&#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">dat</span>)</span>&#123;</span><br><span class="line">    alert(dat.name);</span><br><span class="line">&#125;,<span class="string">'json'</span>);</span><br></pre></td></tr></table></figure>

<p>我们经常会听到两个词：局部刷新 和 无刷新。这是什么意思呢？</p>
<p>答：ajax可以实现局部刷新，也叫做无刷新，无刷新指的是整个页面不刷新，只是局部刷新，ajax可以自己发送http请求，不用通过浏览器的地址栏，所以页面整体不会刷新，ajax获取到后台数据，更新页面显示数据的部分，就做到了页面局部刷新。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕前端ing～</title>
    <url>/2019/12/07/%E6%AD%BB%E7%A3%95%E5%89%8D%E7%AB%AFing%EF%BD%9E/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
这么久没有发文，很多人关心我是否离开了这个美丽的世界 ... 这些同学，是如何居心？出来，我保证不打死你们。不过很久没有更新文章，确实抱歉，我的错，我有罪 ～（小声逼逼：我又不是签约作家，还被逼出了连载的味道，也是没谁了。）

<p>今天咱们唠唠前端那点事儿，和前端死磕到底。</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<blockquote>
<p>当然并不是和可爱的前端们发生争执，而是和那些标签、js、框架死磕到底。</p>
</blockquote>
<p>说起来惭愧，许久没有碰过代码（除了偶尔的脚本），<code>python</code> 生疏已久，前端的 <code>html</code> 、<code>css</code> 和 <code>javascript</code> 更是遗忘在了奈何桥的另一头。作为一个热爱学习的三好青年，怎会允许此事发生？今天咱们就先来回顾一下这些基础知识。以下内容根据 HTML 、CSS 、JS 的顺序进行回顾，文章篇幅较长，可以跳读。</p>
<h2 id="1-HTML"><a href="#1-HTML" class="headerlink" title="1.HTML"></a>1.HTML</h2><p>大家好，我是 html ，学名为超文本标记语言。在浏览器上处处可以看到我的身影。当然，我自己不会如此伟大，身后支撑有一个团队，他们是<strong>化妆师</strong> CSS 和<strong>动作指导</strong> Javascript。</p>
<p>我身上有很多的标签，经过化妆师 CSS 的修饰，才得以展现如此靓丽的一面（让一些开了美颜、瘦脸、拉长身高的小姐姐自愧不如）。那么，简单的数数我身上有哪些标签。</p>
<h3 id="1-1-标签"><a href="#1-1-标签" class="headerlink" title="1.1 标签"></a>1.1 标签</h3><p>1.<code>head</code> 标签，里面会包含一些个 <code>meta</code> 标签、<code>title</code> 标签（网页的标题就是这个小东东）。你以为这些就够了？它里面能嵌入 <code>style</code> （样式标签，内容为 CSS 代码），还可以嵌入 <code>script</code> （内容为 JavaScript 代码），内容极为丰富。</p>
<p>2.<code>body</code> 标签作为身体，大部分的页面内容就自此处啦。</p>
<p>3.<code>h</code> 是标题标签</p>
<p>4.<code>div</code> 是块状标签</p>
<p>5.<code>p</code> 是段落标签</p>
<p>6.<code>br</code> 是换行标签，它是单个出现的标签</p>
<p>7.<code>img</code> 是图片标签，他也是单个出现的标签</p>
<p>8.<code>a</code> 是超链接标签，点击可跳转其他链接</p>
<p>9.<code>ul</code> 和 <code>li</code> 组成了无序标签；而 <code>ol</code> 则是有序标签</p>
<p>10.<code>form</code> 是表单（其中 action 属性定义提交地址；method 属性则是确定表单提交的方式）</p>
<p>11.<code>label</code> 是标注标签。比如一个输入框前面标注为姓名，意思就是让用户输入姓名。</p>
<p>12.<code>input</code> 是输入框。type 属性确定其内容：text 是单行文本，password 是密码框，radio 是单选框，checkbox 是复选框，file 是上传文件，submit 是提交按钮，reset 是重置按钮，button 是普通按钮。</p>
<p>13.<code>textarea</code> 则是多行文本输入框</p>
<p>14.<code>select</code> 是下拉表单</p>
<p>15.<code>option</code> 与 <code>select</code> 配合使用，意思即下拉表单中的选项</p>
<p>16.<code>span</code> 标签则是一些特殊格式文本的标签</p>
<p>17.<code>table</code> 是表格标签，与其配合的有 <code>tr</code> 行标签， <code>th</code> 表头单元格， <code>td</code> 普通单元格</p>
<h3 id="1-2-实体符号以及注释"><a href="#1-2-实体符号以及注释" class="headerlink" title="1.2 实体符号以及注释"></a>1.2 实体符号以及注释</h3><p>大家都知道国人写文章的习惯为段首缩进两字符，如果在 <code>p</code> 标签起始位置手敲俩空格后，页面展示会发现怎么只有一个空格？？？那是因为被浏览器吃了，想要显示多个空格，就需要空格的实体符号了。那便是 <code>&amp;nbsp;</code>。</p>
<p>另外，为了防止歧义的产生，还有俩实体符合值得一提，那便是大于号和小于号。毕竟它们长得太像标签的尖括号了。小于号表示为<code>&amp;lt;</code>；大于号表示为 <code>&amp;gt;</code></p>
<p>注释为 <code>&lt;!-- xxx --&gt;</code></p>
<h3 id="1-3-行元素与行内元素"><a href="#1-3-行元素与行内元素" class="headerlink" title="1.3 行元素与行内元素"></a>1.3 行元素与行内元素</h3><p><strong>行元素</strong>就是单独占一行的标签，也就是后面再有标签去要到下一行去！咱们看看都有谁这么霸道，不要脸：标题标签 <code>h</code>（标题嘛，情有可原）；段落标签 <code>p</code> （凑合着也说的过去）；<code>div</code> 标签（这个东西就把它理解成容器吧，毕竟它没有语义，中性的很～）</p>
<p><strong>行内元素</strong>就是老实人，只占自己的位置。元素之间可以排开（设置宽高是无效的，它的宽和高是由内容撑开的）。这些老实人都有谁呢？图片标签 <code>img</code>  和通用内联容器标签 <code>span</code> 以及超链接标签  <code>a</code></p>
<h3 id="1-4-布局"><a href="#1-4-布局" class="headerlink" title="1.4 布局"></a>1.4 布局</h3><p>不想做将军的士兵，不是好士兵。论谋略、论布局，咱也有一手。</p>
<p><strong>口诀</strong>是：先行后列、先整体再局部、先大后小</p>
<p>即先按照行的方式，将页面整体分开，再给每一行进行内容填充。</p>
<h2 id="2-CSS"><a href="#2-CSS" class="headerlink" title="2.CSS"></a>2.CSS</h2><p>化妆师 CSS 就是美容整形专家了，它控制着 html 的美与丑。</p>
<blockquote>
<p>它有个名字叫做 层叠样式表</p>
</blockquote>
<h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">  属性: 值;</span><br><span class="line">  ...</span><br><span class="line">  属性: 值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择器下面会大幅介绍，所以不要担心。属性和值嘛就很简单，比如字体颜色是红色，字体是仿宋，想起了被论文支配的恐惧 …</p>
<h3 id="2-2-选择器"><a href="#2-2-选择器" class="headerlink" title="2.2 选择器"></a>2.2 选择器</h3><p>选择器其实并不复杂，它就是选择内容，然后为其添加样式，如何准确的选择要加样式的内容呢？就依靠下列选择器啦。</p>
<h4 id="2-2-1-标签选择器"><a href="#2-2-1-标签选择器" class="headerlink" title="2.2.1 标签选择器"></a>2.2.1 标签选择器</h4><p>这是最简单的选择器，直接选择标签，其影响范围之广可想而之，所以大型项目里面可是很少使用的，慎用！</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">color</span>: red&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-类选择器"><a href="#2-2-2-类选择器" class="headerlink" title="2.2.2 类选择器"></a>2.2.2 类选择器</h4><p>类这个字从何而来呢？它其实是根据标签的一个 <code>class</code> 属性命名的。多个标签想要渲染同样的效果，可设置相同的类。然后根据类名来选择元素即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.newbox</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-层级选择器"><a href="#2-2-3-层级选择器" class="headerlink" title="2.2.3 层级选择器"></a>2.2.3 层级选择器</h4><p>层级选择器则是依据标签的层级结果，即嵌套格式进行选择。它可以结合标签选择器与类选择器来一同使用。</p>
<p>比如有个 html 结构如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"new"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为 <code>span</code> 标签加个颜色：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.con</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-id-选择器"><a href="#2-2-4-id-选择器" class="headerlink" title="2.2.4 id 选择器"></a>2.2.4 id 选择器</h4><p>id 为标签的名字。在数据库中 id 一般为唯一键，此处同理。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#box</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5-组选择器"><a href="#2-2-5-组选择器" class="headerlink" title="2.2.5 组选择器"></a>2.2.5 组选择器</h4><p>组选择器便是选择一组内容，为其统一添加样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>,<span class="selector-class">.box8</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-6-伪类选择器"><a href="#2-2-6-伪类选择器" class="headerlink" title="2.2.6 伪类选择器"></a>2.2.6 伪类选择器</h4><p>有一个常用的伪类选择器，它就是 hover ，表示鼠标悬浮于元素上时的状态。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-盒子模型"><a href="#2-3-盒子模型" class="headerlink" title="2.3 盒子模型"></a>2.3 盒子模型</h3><p>提到前端，不得不提到一个东西，那便是盒子模型。也就是浏览器中常看到的下列图片：</p>
<img src="https://github.com/EthanYan6/pic/raw/master/%E6%AD%BB%E7%A3%95%E5%89%8D%E7%AB%AFing%EF%BD%9E/Snipaste_2019-12-07_15-33-11.png" alt="哟，老弟？什么年代了，网速还加载不出我的图片啊？换光纤吧！此处为盒子模型图片" style="zoom:50%;">

<p>盒子模型主要还是为了理解如下几个概念而形象化的东西。</p>
<p>前一段时间在淘宝买了个毛绒玩具（蓝胖子），收到快递，在拆解过程中：</p>
<p>1.width 装玩具的盒子的宽度</p>
<p>2.height 装玩具的盒子的宽度</p>
<p>3.border 装玩具的盒子的厚度</p>
<p>4.padding 玩具和盒子之间的距离（蓝胖子不能压瘪，要不然差评，所以它被保护的很好）</p>
<p>5.margin 我快递盒子和放快递的大盒子之间的距离</p>
<p>有个现象是，当盒子的长和宽固定后， border 和 padding 增加，都会改变整体的尺寸，为什么呢？</p>
<p>因为 padding 增加后（即玩具和盒子之间的填充泡沫太多了）盒子被撑大了；border 增加后（商家比较有良心，换了个特厚实的盒子），所以快递变大了。</p>
<h3 id="2-4-常用属性"><a href="#2-4-常用属性" class="headerlink" title="2.4 常用属性"></a>2.4 常用属性</h3><p>1.width 设置标签的宽</p>
<p>2.height 设置标签的高</p>
<p>3.background 设置标签的背景色</p>
<p>4.border 设置边框线：border-top 即上边框；同理其他为 border-left、border-right 和 border-bottom</p>
<p>5.padding 设置元素内容与边框间的距离（即蓝胖子和快递盒之间的距离）</p>
<p>6.margin 设置元素和外界的距离</p>
<p>7.float 设置元素浮动</p>
<p>8.color 设置文字颜色</p>
<p>9.font-size 设置文字大小</p>
<p>10.font-family 设置文字字体</p>
<p>11.font-weight 设置是否加粗</p>
<p>12.line-height 设置行高</p>
<p>13.text-decoration 设置文字下划线</p>
<p>14.text-align 设置文字水平对齐方式</p>
<p>15.text-indent 设置文字首行缩进</p>
<blockquote>
<p>css 中的注释为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* xxx */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>16.display 设置元素的类型与隐藏。（none 为隐藏；inline 为行内元素；block 为块元素）</p>
<p>17.overflow 设置元素溢出时的动作。（visible 为内容会难看的被显示在元素框外，溢出；hidden 去掉超出的内容，只显示元素框内内容；scroll 则是现实滚动条，可以上下滚动显示全部内容；auto 则是如果内容超出去才会显示滚动条）</p>
<h3 id="2-5-定位"><a href="#2-5-定位" class="headerlink" title="2.5 定位"></a>2.5 定位</h3><h4 id="2-5-1-绝对定位"><a href="#2-5-1-绝对定位" class="headerlink" title="2.5.1 绝对定位"></a>2.5.1 绝对定位</h4><p>找一个参照物来固定元素本身，优先去查找上一个设置了定位的元素，没有的话就是 body 了。然后根据它固定位置，脱离文档流</p>
<h4 id="2-5-2-相对定位"><a href="#2-5-2-相对定位" class="headerlink" title="2.5.2 相对定位"></a>2.5.2 相对定位</h4><p>设置相对定位的元素，一般设置父级相对定位，而子集绝对定位。</p>
<h4 id="2-5-3-固定定位"><a href="#2-5-3-固定定位" class="headerlink" title="2.5.3 固定定位"></a>2.5.3 固定定位</h4><p>以浏览器窗口为参照物，脱离文档流，以不变应万变。</p>
<blockquote>
<p>文档流就是那些标签，它们按照顺序从上往下，从左到右的排列着，当然符合块元素与行内元素的特性。脱离文档流就是飘起来了，它们怎么排列，不受文档流的影响。</p>
</blockquote>
<h3 id="2-6-权重"><a href="#2-6-权重" class="headerlink" title="2.6 权重"></a>2.6 权重</h3><p>CSS 的权重是衡量显示样式的优先级。权重值大的优先显示，如果权重值相同，后写的样式会覆盖掉前面的样式。</p>
<p>1.内联样式权重值最高，毕竟是标签的一部分，亲人嘛。权重值为 1000</p>
<p>2.ID 选择器仅次于内联样式，权重值为 100</p>
<p>3.类和伪类选择器权重值为 10</p>
<p>4.标签选择器权重值为 1</p>
<h2 id="3-Javascript"><a href="#3-Javascript" class="headerlink" title="3.Javascript"></a>3.Javascript</h2><p>希望看到这里，你还有耐心读下去。如果看不下去了，就先收藏一下，去喝杯水，休息一会。</p>
<p>Javascript 也是一种弱类型的语言，它的变量类型不像 Java、C 等需要提前声明，而是由赋的值类型决定，你给我个整数，我就是数字类型。</p>
<p>它定义变量的<strong>语法</strong>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">666</span></span><br><span class="line"><span class="keyword">var</span> sTr = <span class="string">'Ethan Yan'</span></span><br></pre></td></tr></table></figure>

<p>当然你也可以偷懒，多个变量定义，只用一个 <code>var</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">666</span>,sTr=<span class="string">'Ethan Yan'</span></span><br></pre></td></tr></table></figure>

<p>同时它有 <strong>5 种基本数据类型</strong>：</p>
<p>1.number</p>
<p>2.string</p>
<p>3.boolean</p>
<p>4.undefined</p>
<p>5.null</p>
<p>还有一种<strong>复合类型</strong>：object</p>
<p>它不严格缩进，全凭自己喜好，因为它的<strong>语句都以封号结尾</strong>，不像 python 一样，缩进错误疯狂报错。</p>
<p>它的注释如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	xxx</span></span><br><span class="line"><span class="comment">	多行注释</span></span><br><span class="line"><span class="comment">	xxx</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>然后就是<strong>命名规范</strong>，毕竟你定义 xxx 没人能够理解。</p>
<p><strong>变量、函数、属性、函数参数命名规范</strong>：</p>
<p>1.区分大小写</p>
<p>2.第一个字符必须是字母，下划线或者美元符号。（千万别以数字开头命名了，我真的很奇怪，总是有人以数字开头命名）</p>
<p>3.其他字符可以是字母、下划线、美元符号和数字</p>
<p>还有一种比较美观的命名方式，大家可以借鉴一下，那就是<strong>匈牙利命名风格</strong>：</p>
<p>1.如果是对象（Object）就写为：oDiv</p>
<p>2.如果是数组（Array）就写为：aItems</p>
<p>3.如果是浮点数（Float）就写为：fPrice</p>
<p>规律即：变量类型小写首字母加上变量名</p>
<h3 id="3-1-函数"><a href="#3-1-函数" class="headerlink" title="3.1 函数"></a>3.1 函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnAlert</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数执行</span></span><br><span class="line">fnAlert()</span><br></pre></td></tr></table></figure>

<p>上面的函数就是弹出一句话 <code>hello!</code></p>
<p>如果想给函数传参数，则可以使用如下方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnAlert</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  alert(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">alert(<span class="number">222222</span>)</span><br></pre></td></tr></table></figure>

<p>具有返回值的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnAdd</span>(<span class="params">iNum01,iNum02</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> iRs = iNum01 + iNum02;</span><br><span class="line">  <span class="keyword">return</span> iRs;</span><br><span class="line">  alert(<span class="string">'complete!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iCount = fnAdd(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">alert(iCount); <span class="comment">// 弹出7</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-1-变量和函数的预解析"><a href="#3-1-1-变量和函数的预解析" class="headerlink" title="3.1.1 变量和函数的预解析"></a>3.1.1 变量和函数的预解析</h4><p>1.js <strong>底层解析过程</strong>分为两个阶段，那就是编译阶段和执行阶段。所以会发生一件有意思的事情，那就是你在定义一个函数之前，调用这个函数，同样执行正确。为什么？因为编译阶段已经将函数定义过了。（是不是很不可思议）</p>
<p>2.变量如果先调用再定义，为什么不回出现相同的现象？因为变量在编译阶段，会先将其赋值为 undefined 类型，所以先使用变量，再声明变量也不会报错，但是会得到一个 undefined 类型的变量。</p>
<h3 id="3-2-条件语句"><a href="#3-2-条件语句" class="headerlink" title="3.2 条件语句"></a>3.2 条件语句</h3><h4 id="3-2-1-if-else"><a href="#3-2-1-if-else" class="headerlink" title="3.2.1 if-else"></a>3.2.1 if-else</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> iNum2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> sTr;</span><br><span class="line"><span class="keyword">if</span>(iNum1&gt;iNum2)&#123;</span><br><span class="line">  sTr = <span class="string">'大于'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  sTr = <span class="string">'小于'</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(sTr);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-if-elseif-else"><a href="#3-2-2-if-elseif-else" class="headerlink" title="3.2.2 if-elseif-else"></a>3.2.2 if-elseif-else</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">  xxx;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">  xxx;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-获取元素方式"><a href="#3-3-获取元素方式" class="headerlink" title="3.3 获取元素方式"></a>3.3 获取元素方式</h3><p>如果一个元素定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"div1"</span>&gt;这是一个div元素&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>想要获取该元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意获取到的变量是一个对象，并不是值。想要取值，使用<code>oDiv.innerHTML</code> 即可做到</p>
</blockquote>
<p>对了，写 js 时，有一个问题需要注意：</p>
<p>如果 script 标签内容（要获取某一个元素的值）在元素之前，那么获取不到，因为未被声明（代码从上往下执行，而且得到的结果不是 undefined 而是 null）。如果你非要这么变态的写，当然也有办法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">'div2'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>window.onload</code> 函数会在页面加载完之后执行，所以你将你的变态代码扔进去，js 写在哪里都正确。</p>
<h3 id="3-4-操作元素的属性"><a href="#3-4-操作元素的属性" class="headerlink" title="3.4 操作元素的属性"></a>3.4 操作元素的属性</h3><p>语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 = 元素.属性名  <span class="comment">// 读取属性</span></span><br><span class="line">元素.属性名 = 新属性值   <span class="comment">// 改写属性</span></span><br></pre></td></tr></table></figure>

<p>读取属性名时的属性名写法可有些讲究了：</p>
<p>1.普通属性，即 html 中的属性，直接写就完事了</p>
<p>2.class 类属性需要改写。如：className</p>
<p>3.style 属性有横杠的也需要改写。如 font-size 改写为 .fontSize</p>
<h3 id="3-5-事件属性以及匿名函数"><a href="#3-5-事件属性以及匿名函数" class="headerlink" title="3.5 事件属性以及匿名函数"></a>3.5 事件属性以及匿名函数</h3><h4 id="3-5-1-事件属性"><a href="#3-5-1-事件属性" class="headerlink" title="3.5.1 事件属性"></a>3.5.1 事件属性</h4><p>大家经常进行的鼠标点击、鼠标移入、鼠标移出都就是事件属性。我们可以通过将函数名赋值给元素事件属性的方式将事件和函数关联起来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oBtn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"></span><br><span class="line">oBtn.onclick = myalert;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myalert</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'ok!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-2-匿名函数"><a href="#3-5-2-匿名函数" class="headerlink" title="3.5.2 匿名函数"></a>3.5.2 匿名函数</h4><p>js 中匿名函数很好写，我们改写上一段代码为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oBtn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意下面写法</span></span><br><span class="line">oBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'ok!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-数组及操作方法"><a href="#3-6-数组及操作方法" class="headerlink" title="3.6 数组及操作方法"></a>3.6 数组及操作方法</h3><p>如同 python 中的列表，定义数组可以有下面两种方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aList = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> aList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组的长度</span></span><br><span class="line">alert(aList.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用下标取出数组的0号数据</span></span><br><span class="line">alert(aList[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组成员通过一个分隔符合并成字符串</span></span><br><span class="line"><span class="comment">// 弹出 1-2-3</span></span><br><span class="line">alert(aList.join(<span class="string">'-'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组最后增加成员3</span></span><br><span class="line">aList.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组最后删除成员</span></span><br><span class="line">aList.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组反转</span></span><br><span class="line">aList.reverse();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组中元素第一次出现的1的索引值</span></span><br><span class="line">aList.indexOf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第2个元素开始，删除1个元素，然后在此位置增加'7,8,9'三个元素</span></span><br><span class="line">aList.aplice(<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-7-循环语句"><a href="#3-7-循环语句" class="headerlink" title="3.7 循环语句"></a>3.7 循环语句</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 0 开始，只要 i 小于 len 就会一直执行，没执行一次代码，i 进行加 1 操作。</p>
<h3 id="3-8-字符串相关方法"><a href="#3-8-字符串相关方法" class="headerlink" title="3.8 字符串相关方法"></a>3.8 字符串相关方法</h3><p>1.直接用 <code>+</code> 进行拼接操作</p>
<p>2.parseInt() 将数字字符串转化为整数</p>
<p>3.parseFloat() 将数字字符串转化为小数</p>
<p>4.split() 把一个字符串分隔成字符串组成的数组</p>
<p>5.indexOf() 查找字符串是否含有某字符</p>
<p>6.substring() 截取字符串 </p>
<blockquote>
<p>用法： substring(start,end)（不包括end）</p>
</blockquote>
<p><strong>字符串反转</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str = &apos;asdfj12jlsdkf098&apos;;</span><br><span class="line">var str2 = str.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line"></span><br><span class="line">alert(str2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先转化成数组，再利用数组的反转方法即可实现</p>
</blockquote>
<h3 id="3-9-定时器"><a href="#3-9-定时器" class="headerlink" title="3.9 定时器"></a>3.9 定时器</h3><p>setTimeout  只执行一次的定时器 </p>
<p>clearTimeout 关闭只执行一次的定时器</p>
<p>setInterval  反复执行的定时器</p>
<p>clearInterval 关闭反复执行的定时器</p>
<h3 id="3-10-封闭函数"><a href="#3-10-封闭函数" class="headerlink" title="3.10 封闭函数"></a>3.10 封闭函数</h3><p>封闭函数的三种写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>其实也属于匿名函数，即创建完函数立即调用，省略了函数名。</p>
<p>当然它并不是没事干，定义这么个东西好玩儿，它是为了防止命名冲突。</p>
<blockquote>
<p>封闭函数可以创造一个独立的空间，在封闭函数内定义的变量和函数不会影响外部同名的函数和变量，可以避免命名冲突，在页面上引入多个js文件时，用这种方式添加js文件比较安全.</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab 执行python脚本不生效？（续）</title>
    <url>/2019/11/17/%E6%89%A7%E8%A1%8Cpython%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
Linux 设置定时任务，crontab 执行 python 脚本不生效的问题：
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>尝试方法：</p>
<p>1.给 python 脚本第一行添加如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然 python 解释器的路径要按照自己情况进行填写。</p>
</blockquote>
<p>2.如果 python 脚本报错，模块未找到等等，尝试如下方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">'xxx&lt;第三方模块的路径&gt;'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是虚拟环境，有可能此路径不同，可以通过下列命令查看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> elasticsearch</span><br><span class="line">&gt;elasticsearch.__file__</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后将路径复制到 <code>sys.path.append(&#39;&#39;)</code> 中的引号即可，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D:\\E\\python_virtual\\fbl5n\\lib\\site-packages</span><br></pre></td></tr></table></figure>
<p>3.python 脚本中不涉及复杂的逻辑，简单的函数即函数调用即可，如果出现下列代码，请去掉：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br></pre></td></tr></table></figure>
<p>它会将 crontab 在调用的时候搞晕。</p>
<p>4.可以写一个 shell 脚本去调用 python 脚本，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/bash</span></span><br><span class="line">cd /opt</span><br><span class="line">/usr/bin/python3 mail_reminder.py &gt;&gt; log.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>0 表示stdin标准输入<br>1 表示stdout标准输出<br>2 表示stderr标准错误<br>&amp; 表示等同于的意思<br>2&gt;&amp;1 表示2的输出重定向等同于1</p>
</blockquote>
<p>5.当报错编码问题时可以尝试使用如下方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/bash </span></span><br><span class="line">cd /opt </span><br><span class="line">PYTHONIOENCODING=utf-8 /usr/bin/python3 mail_reminder.py &gt;&gt; log.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
        <tag>crontab</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>MacBook Pro你真的会使用吗？</title>
    <url>/2019/11/17/MacBookPro%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
那些不使用鼠标的人是否是打肿脸充胖子？因囊中羞涩而安装的xx软件装不上怎么办？MacBook Pro真的那么好用吗？下面为您解答

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>经过不懈的努力，小闫同学终于使用上了 MacBook Pro，先小小的炫耀一番。（不要打我哈~）</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/MacBookPro%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F/IMG_0212.jpg" alt="小闫同学的 MacBook Pro"></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/MacBookPro%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F/IMG_0211.jpg" alt="小闫同学的 MacBook Pro"></p>
<p>激动的心，颤抖的手，打开了笔记本才发现我是个弟弟，怎么用？经过了一番研究，将电脑弄死好几次的探索，终于入了门。分享给大家吧。</p>
<p>首先 macOS 是类 Linux 系统，因此会命令的童鞋超级好上手。其次，都说Mac 可以提高生产力，可以解放鼠标，怎么做到的呢？那就是超级丰富的快捷键以及非常大块且灵敏的触摸板的功劳了。</p>
<p>一拿到手，第一件事请将触摸板设置成 <strong>tap to click（单击）</strong>。设置方式为依次点击如下按钮：左上角的苹果logo -&gt; System Preferences -&gt; trackpad -&gt; 勾选 tap to click。（这样就不需要点按触摸板了）</p>
<p>第二件事请打开 <strong>three finger drag （三指拖拽）</strong>功能。设置方式如下：左上角的苹果logo -&gt; System Preferences -&gt; Accessibility -&gt; Pointer control -&gt; 点击右方左下角的 trackpad options -&gt; 勾选 enable dragging -&gt; 选择 three finger drag。</p>
<p>第三件事请设置 <strong>Hot corners （触摸角功能）</strong>。设置方式如下：在桌面任意位置鼠标右键（或者触摸板双指触碰一下）-&gt; change desktop background -&gt; screen saver -&gt; Hot corners。我将右下角设置为了 Lock Screen ，只要鼠标往右下角一划或者在触摸板上往右下角一划即可锁屏走人。</p>
<p>这都是一些简单但是非常提高效率设置，那么 Mac 上是如何提高生产力的呢？光这些可不够，下面再介绍一些常用操作。</p>
<p>在 Mac 上面，command 键等同于 Windows 上的 control 键，所以复制粘贴你懂得 ~ 下面快来学习一些 Mac 的小知识吧！</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>1.快速将当前窗口最大化： </p>
<p><code>control + command + F</code></p>
<p>再次按上述快捷键即可恢复原样 </p>
<p>2.快速将当前窗口最小化： </p>
<p><code>command + M</code></p>
<blockquote>
<p>如果当前窗口处于最大化状态，那么此命令无效 </p>
</blockquote>
<p>3.快速将最小化的窗口调出来： </p>
<p>​    3.1 先使用如下快捷键，打开所有的应用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command + tab</span><br></pre></td></tr></table></figure>

<p>​    3.2 按住 command 键不松开，按 tab 键向后选择，按 shift + tab 键向前选择</p>
<p>​    3.3 选中图标之后按住 option 键，松开 command 键即可打开应用</p>
<p>4.类似 home 键和 end 键的快捷操作：</p>
<p>​    4.1 快速移动到行首：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">control + A</span><br></pre></td></tr></table></figure>

<p>​    4.2 快速移动到行尾：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">control + E</span><br></pre></td></tr></table></figure>

<p>​    4.3 到下一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">control + N</span><br></pre></td></tr></table></figure>

<p>​    4.4 到上一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">control + P</span><br></pre></td></tr></table></figure>

<p>​    4.5 从光标处开始删除，知道行尾：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">control + K</span><br></pre></td></tr></table></figure>



<h2 id="安装软件出现文件已损坏"><a href="#安装软件出现文件已损坏" class="headerlink" title="安装软件出现文件已损坏"></a>安装软件出现文件已损坏</h2><p>1.关闭软件，点击取消，先别着急移到废纸篓 </p>
<p>2.输入如下命令，开启安装任何应用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure>

<p>3.如果是10.15的新系统，有可能还是失败，那么输入如下命令即可解决： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xattr -cr /Applications/MindNode.app</span><br></pre></td></tr></table></figure>

<p>​    3.1 上方的命令是先输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xattr -cr</span><br></pre></td></tr></table></figure>

<p>​    3.2 然后将损坏的应用图标拖到终端命令后，按回车即可 </p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>快捷键</tag>
        <tag>MacBook Pro</tag>
      </tags>
  </entry>
  <entry>
    <title>bat脚本常用命令</title>
    <url>/2019/11/14/bat%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<center>Author：闫玉良</center>
bat 脚本？如果不是从事微软开发相关工作的人员，是不是感觉很耳熟但是又好像不熟悉？还等什么，一睹为快

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>bat 脚本是 windows 上所用的脚本，我们经常使用的 cmd 一些命令就可以使用。也许你会说为什么不使用 powershell 脚本？因为古老的一些服务器上面没有安装 powershell 你信不信？比如 windows server 2003。</p>
<p>很荣幸，我遇到了，没有什么办法，只能查阅相关资料迎难而上了！脚本其实很简单，下面做一个记录，供大家有需要时获取：</p>
<h4 id="1-设置变量"><a href="#1-设置变量" class="headerlink" title="1.设置变量"></a>1.设置变量</h4><p>设置变量使用 <code>SET</code> 关键字，语法如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">SET 变量名=变量值</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.<strong>变量名与变量值一定要紧挨等于号！！！</strong>否则报错到怀疑人生。</p>
<p>2.变量值如果是个字符串，直接写内容，不需要加双引号。（是不是很方便）</p>
</blockquote>
<h4 id="2-使用变量"><a href="#2-使用变量" class="headerlink" title="2.使用变量"></a>2.使用变量</h4><p>使用变量时语法如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">%变量名%</span><br></pre></td></tr></table></figure>

<h4 id="3-判断语句"><a href="#3-判断语句" class="headerlink" title="3.判断语句"></a>3.判断语句</h4><p>判断语句必不可少，if … else… 语法如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件 (</span><br><span class="line">	条件成立执行内容</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">	条件不成立执行内容</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="4-回显"><a href="#4-回显" class="headerlink" title="4.回显"></a>4.回显</h4><p>类似于 python 中的 print 函数，即将后方的内容打印输出：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">echo 我就是要回显的内容</span><br></pre></td></tr></table></figure>

<h4 id="5-创建文件夹"><a href="#5-创建文件夹" class="headerlink" title="5.创建文件夹"></a>5.创建文件夹</h4><p>创建目录你还在想 <code>mkdir</code> 的时候，windows 已经考虑简化了：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">md 文件夹路径</span><br></pre></td></tr></table></figure>

<blockquote>
<p>之所以写文件夹路径，是因为可以创建嵌套目录啊！不需要任何参数，简单不简单？</p>
</blockquote>
<h4 id="6-输出内容到文件"><a href="#6-输出内容到文件" class="headerlink" title="6.输出内容到文件"></a>6.输出内容到文件</h4><p>大家如果熟悉 Linux 系统，那么对于重定向命令一定很熟悉了，bat 脚本完全一样，如果是创建一个文件，或者已有文件覆盖内容的话，可以使用 <code>&gt;</code> 命令；如果是要往加过里面追加内容的话，直接使用 <code>&gt;&gt;</code> 即可。示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo test content &gt; C:\test\test.txt</span><br></pre></td></tr></table></figure>

<h4 id="7-关闭系统信息回显"><a href="#7-关闭系统信息回显" class="headerlink" title="7.关闭系统信息回显"></a>7.关闭系统信息回显</h4><p>我们在执行脚本的时候，系统会执行 N 多步可知，不可知的步骤，因此会输出大量的信息，如果只想看自己回显的信息呢？可以使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要再文件的开头书写</p>
</blockquote>
<h4 id="8-标题"><a href="#8-标题" class="headerlink" title="8.标题"></a>8.标题</h4><p>小黑窗口左上角的字该怎么改呢？看下方：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@title monitoring_log by EthanYan</span><br></pre></td></tr></table></figure>

<h4 id="9-其他"><a href="#9-其他" class="headerlink" title="9.其他"></a>9.其他</h4><p>如果你看其他人写的脚本，也许会在文件开头看到这样一句：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mode con lines=5 cols=40</span><br></pre></td></tr></table></figure>

<p>它是设置显示内容的小黑窗口大小的命令。lines 指的是高，cols 指宽度。</p>
]]></content>
      <categories>
        <category>windows</category>
        <category>script</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title>python 字符串前面的那些特殊字符</title>
    <url>/2019/11/04/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E9%9D%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<center>Author：闫玉良</center>
对于 Python 的字符串大家并不陌生，引号引用即为字符串。那么字符串前面经常加的一些特殊字母就让初学者懵逼了，今天我们就来详细讲一下 ......

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<h2 id="1-u"><a href="#1-u" class="headerlink" title="1.u"></a>1.u</h2><p>作为程序员，看到 <code>u</code> 字符，首先想到的便是 <code>Unicode</code> 这个单词。没错，它确实也代表此含义。目的是告知后面字符串采用 <code>Unicode</code> 编码格式，应用对象自然是容易出现问题的<strong>中文字符串</strong>。</p>
<p>有时我们存储完成后，再次取用发现格式不一致，或者显示乱码等问题，使用 <code>u</code> 便很好解决了。</p>
<h2 id="2-f"><a href="#2-f" class="headerlink" title="2.f"></a>2.f</h2><p>这个字符经常看到，不知你是否还注意到一个现象，那便是出现此字符的字符串，字符串中必定会有大括号。哈哈，忘记也没有关系，要不然我讲什么呢？</p>
<p>此字符代表的是在后面字符串中可以使用大括号（大括号中可以使用 <code>python</code> 表达式）。如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">f"testfile-<span class="subst">&#123;str(time.time()).replace(<span class="string">'.'</span>,<span class="string">''</span>)&#125;</span>.txt"</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">testfile<span class="number">-15728489624240513.</span>txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样我们在字符串中就可以随心所欲的使用任何表达式，不再通过 <code>+</code> 拼接各种字符串了。</p>
</blockquote>
<h2 id="3-r"><a href="#3-r" class="headerlink" title="3.r"></a>3.r</h2><p><code>r</code> 这个字符是否更眼熟了？没错，在学习正则表达式时，大家都见过。此字符含义与其相同，代表将字符串中各种特殊符号进行转义，字符串中内容 <code>所见即所得</code> 。比如 ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">r'你好：\n您的快递'</span></span><br></pre></td></tr></table></figure>

<p>其中的 <code>\n</code> 不再表示换行符，而是反斜杠加字母 <code>\n</code></p>
<h2 id="4-b"><a href="#4-b" class="headerlink" title="4.b"></a>4.b</h2><p>这个字符就更常见了，它表示 <code>bytes</code> 类型。它可以与字符串类型相互转换，使用 <code>encode</code> 与 <code>decode</code>。</p>
<h3 id="bytes-gt-string"><a href="#bytes-gt-string" class="headerlink" title="bytes -&gt; string"></a>bytes -&gt; string</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">by = <span class="string">b'test'</span></span><br><span class="line">by.decode(<span class="string">'utf8'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="string-gt-bytes"><a href="#string-gt-bytes" class="headerlink" title="string -&gt; bytes"></a>string -&gt; bytes</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">'test'</span></span><br><span class="line">str.encode(<span class="string">'utf8'</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab定时执行python脚本不成功解决方案</title>
    <url>/2019/10/31/crontab%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8Cpython%E8%84%9A%E6%9C%AC%E4%B8%8D%E6%88%90%E5%8A%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
目前有一个需求是定时执行某个 python 脚本，但是在 Linux 上设置 crontab 后，不生效？手动执行生效？于是使用下面的方法执行即可：

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>大体思路为先写一个 <code>shell</code> 脚本，脚本中执行 <code>python</code> 文件，然后定时执行 <code>shell</code> 脚本即可。具体原因不明，正在探索中 …… 目前只提供一种解决方案。</p>
<p>1.使用如下命令创建脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi start.sh</span><br></pre></td></tr></table></figure>

<p>2.然后在 <code>start.sh</code> 脚本中结合本身情况输入内容，示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/bash</span></span><br><span class="line">cd /opt</span><br><span class="line">/usr/bin/python3 /opt/test_mail.py</span><br></pre></td></tr></table></figure>

<p>3.然后使用如下命令，编辑定时任务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<p>4.假如设定每天 8 点执行脚本，设置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 8 * * * /opt/start.sh</span><br></pre></td></tr></table></figure>

<p>5.保存定时任务，几分钟后自动生效。</p>
<blockquote>
<p><strong>注意</strong>：所有的路径都使用<strong>绝对路径</strong>，否则仍然无效。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>python</tag>
        <tag>crontab</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>python导入导出pip环境中所有模块</title>
    <url>/2019/10/28/python%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BApip%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%89%80%E6%9C%89%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
刚入职接手项目，python 环境如何搭建？项目依赖模块如何安装？备份环境时如何将所有 pip 安装的模块导出？请看下文

<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>导出所有模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip freeze &gt;requirements.txt</span><br></pre></td></tr></table></figure>

<p>导入所有模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：执行此命令时<strong>需要联网</strong>，其原理还是依次对文件中每一个模块进行 <code>pip install</code></p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python后端面试汇总</title>
    <url>/2019/10/28/Python%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
只身打入敌人内部，亲身经历，题目汇总，亲情大奉献，请点击以下链接观看：

<p><a href="http://mp.weixin.qq.com/mp/homepage?__biz=Mzg3NTA0OTM1OQ==&hid=8&sn=811ae175b0ce7f4208d0a3bea3157ac0&scene=18#wechat_redirect" target="_blank" rel="noopener">python面试题大汇总</a></p>
<a id="more"></a>









<p>点进来干什么，题目全在链接里面了 ~ </p>
<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo命令速查小册</title>
    <url>/2019/10/27/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
最近都在搭建自己的博客，不断的调整显示效果，以及添加一些初始功能，总算大体框架完成，细枝末节尚待商榷。小闫同学的博客地址为  http://www.pythonnote.cn/  ，希望大家多多捧场 ~ 当然也希望大家多多关注公众号『全栈技术精选』

<p>先来几张效果图压场，deng ~ deng ~ dengdeng</p>
<a id="more"></a>

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/blog1.png" alt></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/blog2.png" alt></p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/blog3.png" alt></p>
<p>前端超牛逼的效果有没有感动到 ~ 这当然不是我自己做的，还要感谢 Jonathan Klughertz</p>
<p>如果认为这篇文章要教如何搭建个人博客，那就让你失望了，因为百度上面相关教程太多太多，我不认为自己写的比其他人更详细更好。只是给大家指引一下方向即可。</p>
<p>搭建博客的过程中使用到了框架 Node.js、HEXO 以及 GitHub 。</p>
<p>下面就经常使用到的 hexo 的命令做一个总结，方便在使用过程中快速查阅。</p>
<h4 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo n "article name"</span><br><span class="line">或者</span><br><span class="line">hexo new "article name"</span><br></pre></td></tr></table></figure>

<h4 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>其实上述为 3 个命令，为了节省时间，我经常联合使用。</p>
<blockquote>
<p>hexo clean 清除缓存</p>
<p>hexo g 生成静态页面（generate）</p>
<p>hexo d 部署（deploy）</p>
</blockquote>
<h4 id="本地效果预览"><a href="#本地效果预览" class="headerlink" title="本地效果预览"></a>本地效果预览</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<blockquote>
<p>s 为 server 的简写，因此你也可以写成 hexo server。hexo 的命令大多都是如此</p>
</blockquote>
<h4 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h4><p>首页会根据分页效果展示文章，如果不设置摘要，文章会拉长页面篇幅。</p>
<p>我们只需要在文章摘要后添加一行内容即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<p>最后效果图为：</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/blog4.png" alt></p>
<h4 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h4><p>先执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page "tags"</span><br></pre></td></tr></table></figure>

<p>再在目录 <code>source/tags/index.md</code> 中添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-05-27 13:47:40</span><br><span class="line">type: "tags"</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>最后只需要在写文章时添加 <code>tags</code> 属性即可。</p>
<p>如果只添加一个标签：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tags: test</span><br></pre></td></tr></table></figure>

<p>多标签，文章开头添加：（yaml语法）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line">- test1</span><br><span class="line">- test2</span><br><span class="line">- test3</span><br></pre></td></tr></table></figure>

<h4 id="添加文章分类目录"><a href="#添加文章分类目录" class="headerlink" title="添加文章分类目录"></a>添加文章分类目录</h4><p>添加分类如同标签一样，只需要将 <code>tags</code> 换成 <code>categories</code> 即可，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page "categories"</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>如下形式，同篇文章添加多个目录和标签：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">数据结构</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">数据结构</span></span><br></pre></td></tr></table></figure>

<p><strong>同篇文章添加多个目录和标签时，请将与其他文章共同的目录放置在前面，优先级高一些。</strong>比如，文章A归为目录算法和机器学习下，文章B归为目录算法和数据结构下。他们在划分目录时，需如下填写：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章A</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">机器学习</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章B</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">数据结构</span></span><br></pre></td></tr></table></figure>

<p>如果先写各自不同的目录，再写共同目录时，会在前端目录展示页面中出现重复目录。因为框架在创建目录时，会按如下形式创建表示目录的文件夹，以上述例子示范：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">算法</span></span><br><span class="line"><span class="string">├──</span> <span class="string">机器学习</span></span><br><span class="line"><span class="string">└──</span> <span class="string">数据结构</span></span><br><span class="line"><span class="comment"># 框架会先创建一个算法的文件夹，然后在算法文件夹下创建两个其他文件夹，这样避免目录重复</span></span><br></pre></td></tr></table></figure>

<p>如果在目录填写时按如下情况：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章A</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">机器学习</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章B</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">数据结构</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">算法</span></span><br></pre></td></tr></table></figure>

<p>框架在生成目录时：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">机器学习</span></span><br><span class="line"><span class="string">└──</span> <span class="string">算法</span></span><br><span class="line"></span><br><span class="line"><span class="string">数据结构</span></span><br><span class="line"><span class="string">└──</span> <span class="string">算法</span></span><br><span class="line"><span class="comment"># 框架会先生成每篇文章中各自不同的目录，然后在其下创建算法目录，造成重复</span></span><br></pre></td></tr></table></figure>

<p>框架在生成目录时，会优先创建写在首位的目录，再创建写在后面为止的目录，所以在展示所有的目录时，会出现重复的两个 <code>算法</code> 目录。</p>
<h4 id="文章中插入图片"><a href="#文章中插入图片" class="headerlink" title="文章中插入图片"></a>文章中插入图片</h4><p>如果在 Markdown 中直接插图，再转成静态页面时，路径会找不到，导致图片无法正常显示。解决办法有很多，我最喜欢的便是利用 GitHub 新建一个放置图片的仓库（当然很多人使用七牛云也很方便），然后在文章中使用插入连接的方式插入图片即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">![](https://github.com/EthanYan6/pic/raw/master/hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%B0%8F%E5%86%8C/blog1.png)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>连接地址利用以下步骤获取：打开GitHub图片仓库后，看到 Download 按钮，右键复制链接</p>
</blockquote>
<h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p>大家首先需要去腾讯云或者阿里云购买一个域名，然后备案，再通过解析绑定个人博客地址。百度教程超详细，不过多阐述</p>
<p>命令暂且总结到此，预知后事如何，且听下回分解 ~</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch 中这些必备 API 你晓得嘛？</title>
    <url>/2019/10/25/Elasticsearch%20%E4%B8%AD%E8%BF%99%E4%BA%9B%E5%BF%85%E5%A4%87%20API%20%E4%BD%A0%E6%99%93%E5%BE%97%E5%98%9B%EF%BC%9F/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
## 1.索引备份迁移

<p>众所周知，ES 中的 mapping 只能在索引建立初期进行创建，且建立之后不可更改。mapping 对应的字段会映射成指定类型，未定义字段则自动映射，一般为 text 类型。那么想更改索引名或者更改某字段的 mapping 时，是否就束手无策了呢？当然不是！！！官方提供了一个接口，供索引备份迁移操作使用，那便是 <strong>reindex</strong>。当旧索引与新索引在同一节点时，效率相当高，万条数据瞬间完成（<code>大约只需0.4s</code>）。数百万数据也只需几分钟即可完成 操作，是不是很溜呢？快来学习一下吧。</p>
 <a id="more"></a> 

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p><strong>请求方式：POST</strong></p>
<p><strong>请求 API <code>_reindex</code></strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"source"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"要备份的索引名"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dest"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"新建的索引名"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果新索引中有数据，且 id 与旧索引中重复，那么会进行覆盖操作。</p>
</blockquote>
<p>但是当数据量实在太大，高达几十 G 的时候，速度就会变得很慢，那是因为它底层还是利用了 scroll 操作。该如何进行<strong>优化</strong>呢？可以提升批量操作的文档数大小，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"source"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"要备份的索引名"</span>,</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">5000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dest"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>  : <span class="string">"新建的索引名"</span>,</span><br><span class="line">    <span class="attr">"routing"</span>: <span class="string">"=cat"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>批量操作大小是如何确定的呢？是根据文档数以及文档容量进行确定的。根据查阅资料得知，一个好的起点是<strong>每批处理数据 5-15 MB</strong>，这是个什么概念？</p>
<blockquote>
<p>1000 个 1kb 的文档大约 1MB；1000 个 100kb 的文档是 100MB。</p>
</blockquote>
<p>然后<strong>逐步增加每批处理数据容量</strong>，进行调优，直到最终性能无法再次提升。还有一个方法，那便是提升硬件，比如<strong>换固态</strong>，你懂得~</p>
<p>还有一种方法提升写入效率，这是终极操作，那便是 <code>sliced</code>。<code>reindex</code> 支持 Sliced Scroll 操作。它的原理可以简单的理解为将每次的 Scroll 请求分解，分解后并行化请求，从而提升效率。方式为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _reindex?slices=5&amp;refresh</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"source"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"要备份的索引名"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dest"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"新建的索引名"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-删除索引中指定的数据"><a href="#2-删除索引中指定的数据" class="headerlink" title="2.删除索引中指定的数据"></a>2.删除索引中指定的数据</h2><p><strong>请求方式：POST</strong></p>
<p><strong>请求 API <code>_delete_by_query</code></strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"字段名"</span>: <span class="string">"字段值"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法便是先查出指定数据再删除。</p>
</blockquote>
<h2 id="3-设置副本数、分片、动态映射"><a href="#3-设置副本数、分片、动态映射" class="headerlink" title="3. 设置副本数、分片、动态映射"></a>3. 设置副本数、分片、动态映射</h2><p>设置这些指标项可在建立 mapping 时一同设置。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>:&#123;</span><br><span class="line">        <span class="attr">"index"</span>:&#123;</span><br><span class="line">            // 刷新间隔</span><br><span class="line">            "refresh_interval":"3s"</span><br><span class="line">        &#125;,</span><br><span class="line">        // 副本数</span><br><span class="line">        "number_of_replicas":"0",</span><br><span class="line">        // 切片（分布在每个节点上的切片）</span><br><span class="line">        "number_of_shards":"1"</span><br><span class="line">    &#125;,</span><br><span class="line">    "mappings":&#123;</span><br><span class="line">        "_doc":&#123;</span><br><span class="line">            // 自动映射为 keyword 类型而不是默认的text类型</span><br><span class="line">            "dynamic_templates":[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"string_fields"</span>:&#123;</span><br><span class="line">                        <span class="attr">"match"</span>:<span class="string">"*"</span>,</span><br><span class="line">                        <span class="attr">"match_mapping_type"</span>:<span class="string">"string"</span>,</span><br><span class="line">                        <span class="attr">"mapping"</span>:&#123;</span><br><span class="line">                            <span class="attr">"type"</span>:<span class="string">"keyword"</span>,</span><br><span class="line">                            <span class="attr">"norms"</span>:<span class="literal">false</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            // 建立mapping</span><br><span class="line">            "properties":&#123;</span><br><span class="line">                "mydate":&#123;</span><br><span class="line">                    "type":"date",</span><br><span class="line">                    "format":"yyyy/MM/dd HH:mm:ss||date_time||strict_date_time"</span><br><span class="line">                &#125;,</span><br><span class="line">                "字段名":&#123;</span><br><span class="line">                    "type":"字段类型"</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 上传大文件</title>
    <url>/2019/10/25/Git%20%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
我们知道 github 上面限制每次推送的文件不能超过 100M，否则报错失败，那么非要推送大文件呢？有没有什么解决办法呢？答案当然是肯定的。这就用到了 `Git LFS` 。

 <a id="more"></a> 

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<p>因为只试验了 windows 平台，本文以此为例。其他系统可上网搜如何下载安装对应版本的 <code>git-lfs</code>。</p>
<h2 id="1-windows-平台安装-git-lfs"><a href="#1-windows-平台安装-git-lfs" class="headerlink" title="1.windows 平台安装 git-lfs"></a>1.windows 平台安装 git-lfs</h2><p>1.先打开网址：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">https://github.com/git-lfs/git-lfs/releases</span></span><br></pre></td></tr></table></figure>

<p>2.然后点击最新版本的版本号，将页面拉取到最底部，下载安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Windows Installer</span><br></pre></td></tr></table></figure>

<p>3.运行下载的 exe 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">windows installer</span><br></pre></td></tr></table></figure>

<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><p>1.打开 <code>git bash</code>，首先输入下列命令开启 lfs 功能：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure>

<p>2.然后使用如下命令进行大文件追踪，然后会生成文件 <code>.gitattributes</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git lfs track '大文件名'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 追踪大文件test.tar.gz</span></span><br><span class="line">git lfs track 'test.tar.gz'</span><br></pre></td></tr></table></figure>

<p>3.添加文件 <code>.gittributes</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .gitattributes</span><br></pre></td></tr></table></figure>

<p>4.然后提交文件 <code>.gitattributes</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m 'submit .gitattributes file'</span><br></pre></td></tr></table></figure>

<p>5.将文件 <code>.gitattributes</code> 推送到远程仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>6.添加大文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add test.tar.gz</span><br></pre></td></tr></table></figure>

<p>7.提交大文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m 'submit big file.'</span><br></pre></td></tr></table></figure>

<p>8.直接推送大文件到远程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>然后你就会发现大文件推送到远程的 github 仓库了。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>常用 es 查询盘点</title>
    <url>/2019/10/25/%E5%B8%B8%E7%94%A8-es-%E6%9F%A5%E8%AF%A2%E7%9B%98%E7%82%B9/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
熟悉了关系型数据库的结构概念以及查询，再去使用属于非关系型数据库的 Elasticsearch 时，简直是噩梦。第一道难关便是概念上的转换。索引？类型？文档？what？

 <a id="more"></a> 

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<blockquote>
<p>下面是概念上的对应，大家可以类比了解</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns</span><br><span class="line">Elasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields</span><br></pre></td></tr></table></figure>

<p>熟悉了各种概念后，下一道难关便是增删改查，而最最常用的是<strong>查询</strong>！如同 SQL 一样，它有一套自己的查询语句，称为 DSL。所以，下面为大家总结一下常用的查询，然后你就可以像翻字典一样，用时瞄两眼了 ~ 嘿嘿，真他娘的是个天才 … </p>
<h3 id="1-基础的不能再基础查询"><a href="#1-基础的不能再基础查询" class="headerlink" title="1.基础的不能再基础查询"></a>1.基础的不能再基础查询</h3><p><strong>查询所有的索引及容量：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _cat/indices</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>GET</code> 代表请求方式；<code>_cat/indices</code> 代表查询部分。访问的 <code>url</code> 写全为：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">localhost:9200/_cat/indices</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>查询某一索引的映射结构：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET 索引名/_mapping</span><br></pre></td></tr></table></figure>

<p><strong>查询所有的相同前缀索引：（如以 yan 开头）</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET yan*/_search</span><br></pre></td></tr></table></figure>

<p><strong>查询所有索引模板：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _template</span><br></pre></td></tr></table></figure>

<p><strong>查询具体索引模板：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _template/模板名</span><br></pre></td></tr></table></figure>

<p><strong>查询集群健康状态：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _cluster/health</span><br></pre></td></tr></table></figure>

<p><strong>查询所有节点：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _cat/nodes</span><br></pre></td></tr></table></figure>

<p><strong>查询索引及分片的分布：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _cat/shards</span><br></pre></td></tr></table></figure>

<p><strong>查询所有插件:</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET _cat/plugins</span><br></pre></td></tr></table></figure>

<h3 id="2-有点难度的查询"><a href="#2-有点难度的查询" class="headerlink" title="2.有点难度的查询"></a>2.有点难度的查询</h3><p><strong>查询某个索引的全部数据：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "match_all": &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然你也可以直接写 URL 查询（默认返回 10 条文档）：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">localhost:9200/索引名/_search?pretty</span></span><br></pre></td></tr></table></figure>
<p>pretty参数是为了浏览器显示的美观一些。</p>
</blockquote>
<p><strong>根据某一字段精确查询：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "term": &#123; "字段名" : "值" &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据某一字段模糊匹配：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "match": &#123; "字段名" : "值" &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据某一字段值进行范围查找：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "range": &#123;</span><br><span class="line">    	# 字段名: 条件</span><br><span class="line">        "age":&#123; "gte" : 15 , "lte" : 25 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>gte 是大于等于；lte 是小于等于</p>
</blockquote>
<p><strong>根据条件进行过滤查询：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "filter": &#123;</span><br><span class="line">        "term":&#123;"字段":"值"&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多条件”或”关系：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">	"query": &#123;</span><br><span class="line">		"bool": &#123;</span><br><span class="line">			"should": [&#123;</span><br><span class="line">				"term": &#123;</span><br><span class="line">					"字段": "值"</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, &#123;</span><br><span class="line">				"match": &#123;</span><br><span class="line">					"字段": "值"</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多条件”与”关系：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must" : [&#123;</span><br><span class="line">        "match" : &#123;</span><br><span class="line">          "name" : "Ethanyan"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        "range":&#123;</span><br><span class="line">        "age":&#123;</span><br><span class="line">          "from" : 18 , "to" : 26</span><br><span class="line">        &#125; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>严格匹配：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must" : &#123;</span><br><span class="line">        "range" : &#123;</span><br><span class="line">          "age" : &#123; "from" : 18, "to" : 26 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>严格不匹配：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must_not" : &#123;</span><br><span class="line">        "term" : &#123;</span><br><span class="line">          "name" : "Ethanyan"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复合查询：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">	"query": &#123;</span><br><span class="line">		"bool": &#123;</span><br><span class="line">			"should": [&#123;</span><br><span class="line">					"match": &#123;</span><br><span class="line">						"age": 18</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,  </span><br><span class="line">				&#123;</span><br><span class="line">					"match": &#123;</span><br><span class="line">						"age": 26</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			],</span><br><span class="line">			"filter": &#123; </span><br><span class="line">				"match": &#123;  </span><br><span class="line">					"name": "Ethanyan" </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h3><p>1.索引名、模板名之类的名称不能出现字母大写</p>
<p>2.在查询时，需要写 DSL 语句，所以需要携带请求体，那么为什么还是 get 请求？</p>
<p>答：原则上 get 请求不能携带请求体，但凡事有例外，试验后确实可以，我也不晓得为什么。下方为官方文档，全为 get 请求：</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/%E5%B8%B8%E7%94%A8-es-%E6%9F%A5%E8%AF%A2%E7%9B%98%E7%82%B9/esquery.png" alt="esquery"></p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 彻底删除某个commit的方法</title>
    <url>/2019/10/25/Git-%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AAcommit%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[ <center>Author：闫玉良</center> 
如果因为一些原因，需要删除某个错误的 `commit`，而且需要干净的操作，彻底让其消失，不留痕迹，该如何操作？

 <a id="more"></a> 

<p><strong><em>更多精彩文章请关注公众号『Pythonnote』或者『全栈技术精选』</em></strong></p>
<blockquote>
<p>我向仓库提交了一个大文件，大约 300M，push 失败（因为 git 最大能提交 100M 文件），删除本地文件不行，尝试过修改配置文件，解除 git 只能提交小于 100M 文件的限制，但是未起作用。只能通过删除包含提交此文件的 commit 解决。</p>
</blockquote>
<p>废话少说，直奔主题。</p>
<p>1.首先输入如下命令查看历史提交的 commit：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重要的是<strong>记下</strong>要删除的 commit 的<strong>上一条</strong> commit 的 <strong>commit号</strong>。如下图，如果要删除箭头所指的 commit，需要记录红框中的 commit号：</p>
</blockquote>
<p><img src="https://github.com/EthanYan6/pic/raw/master/Git-%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AAcommit%E7%9A%84%E6%96%B9%E6%B3%95/gitlog.png" alt="gitlog"></p>
<p>2.然后执行如下的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase -i commit号</span><br></pre></td></tr></table></figure>

<p>会出现如下界面：</p>
<p><img src="https://github.com/EthanYan6/pic/raw/master/Git-%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AAcommit%E7%9A%84%E6%96%B9%E6%B3%95/gitrebase.png" alt="gitrebase"></p>
<p>3.然后将要删除的 commit号 的前缀 <code>pick</code> 改为 <code>drop</code>。</p>
<p>4.然后可以通过如下命令再次查看是否已经删除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p>5.最后通过如下命令将现在的状态推送到远程仓库即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin HEAD -force</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
